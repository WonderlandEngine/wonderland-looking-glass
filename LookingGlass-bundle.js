var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/howler/dist/howler.js
var require_howler = __commonJS({
  "node_modules/howler/dist/howler.js"(exports) {
    (function() {
      "use strict";
      var HowlerGlobal2 = function() {
        this.init();
      };
      HowlerGlobal2.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var self2 = this || Howler2;
          self2._counter = 1e3;
          self2._html5AudioPool = [];
          self2.html5PoolSize = 10;
          self2._codecs = {};
          self2._howls = [];
          self2._muted = false;
          self2._volume = 1;
          self2._canPlayEvent = "canplaythrough";
          self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
          self2.masterGain = null;
          self2.noAudio = false;
          self2.usingWebAudio = true;
          self2.autoSuspend = true;
          self2.ctx = null;
          self2.autoUnlock = true;
          self2._setup();
          return self2;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(vol) {
          var self2 = this || Howler2;
          vol = parseFloat(vol);
          if (!self2.ctx) {
            setupAudioContext();
          }
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            self2._volume = vol;
            if (self2._muted) {
              return self2;
            }
            if (self2.usingWebAudio) {
              self2.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            }
            for (var i = 0; i < self2._howls.length; i++) {
              if (!self2._howls[i]._webAudio) {
                var ids = self2._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self2._howls[i]._soundById(ids[j]);
                  if (sound && sound._node) {
                    sound._node.volume = sound._volume * vol;
                  }
                }
              }
            }
            return self2;
          }
          return self2._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(muted) {
          var self2 = this || Howler2;
          if (!self2.ctx) {
            setupAudioContext();
          }
          self2._muted = muted;
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler2.ctx.currentTime);
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (!self2._howls[i]._webAudio) {
              var ids = self2._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound = self2._howls[i]._soundById(ids[j]);
                if (sound && sound._node) {
                  sound._node.muted = muted ? true : sound._muted;
                }
              }
            }
          }
          return self2;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          var self2 = this || Howler2;
          for (var i = 0; i < self2._howls.length; i++) {
            self2._howls[i].stop();
          }
          return self2;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          var self2 = this || Howler2;
          for (var i = self2._howls.length - 1; i >= 0; i--) {
            self2._howls[i].unload();
          }
          if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
            self2.ctx.close();
            self2.ctx = null;
            setupAudioContext();
          }
          return self2;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(ext) {
          return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var self2 = this || Howler2;
          self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
          self2._autoSuspend();
          if (!self2.usingWebAudio) {
            if (typeof Audio !== "undefined") {
              try {
                var test = new Audio();
                if (typeof test.oncanplaythrough === "undefined") {
                  self2._canPlayEvent = "canplay";
                }
              } catch (e) {
                self2.noAudio = true;
              }
            } else {
              self2.noAudio = true;
            }
          }
          try {
            var test = new Audio();
            if (test.muted) {
              self2.noAudio = true;
            }
          } catch (e) {
          }
          if (!self2.noAudio) {
            self2._setupCodecs();
          }
          return self2;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var self2 = this || Howler2;
          var audioTest = null;
          try {
            audioTest = typeof Audio !== "undefined" ? new Audio() : null;
          } catch (err) {
            return self2;
          }
          if (!audioTest || typeof audioTest.canPlayType !== "function") {
            return self2;
          }
          var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
          var ua = self2._navigator ? self2._navigator.userAgent : "";
          var checkOpera = ua.match(/OPR\/([0-6].)/g);
          var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
          var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
          var safariVersion = ua.match(/Version\/(.*?) /);
          var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
          self2._codecs = {
            mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!mpegTest,
            opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
          };
          return self2;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var self2 = this || Howler2;
          if (self2._audioUnlocked || !self2.ctx) {
            return;
          }
          self2._audioUnlocked = false;
          self2.autoUnlock = false;
          if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
            self2._mobileUnloaded = true;
            self2.unload();
          }
          self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
          var unlock = function(e) {
            while (self2._html5AudioPool.length < self2.html5PoolSize) {
              try {
                var audioNode = new Audio();
                audioNode._unlocked = true;
                self2._releaseHtml5Audio(audioNode);
              } catch (e2) {
                self2.noAudio = true;
                break;
              }
            }
            for (var i = 0; i < self2._howls.length; i++) {
              if (!self2._howls[i]._webAudio) {
                var ids = self2._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self2._howls[i]._soundById(ids[j]);
                  if (sound && sound._node && !sound._node._unlocked) {
                    sound._node._unlocked = true;
                    sound._node.load();
                  }
                }
              }
            }
            self2._autoResume();
            var source = self2.ctx.createBufferSource();
            source.buffer = self2._scratchBuffer;
            source.connect(self2.ctx.destination);
            if (typeof source.start === "undefined") {
              source.noteOn(0);
            } else {
              source.start(0);
            }
            if (typeof self2.ctx.resume === "function") {
              self2.ctx.resume();
            }
            source.onended = function() {
              source.disconnect(0);
              self2._audioUnlocked = true;
              document.removeEventListener("touchstart", unlock, true);
              document.removeEventListener("touchend", unlock, true);
              document.removeEventListener("click", unlock, true);
              document.removeEventListener("keydown", unlock, true);
              for (var i2 = 0; i2 < self2._howls.length; i2++) {
                self2._howls[i2]._emit("unlock");
              }
            };
          };
          document.addEventListener("touchstart", unlock, true);
          document.addEventListener("touchend", unlock, true);
          document.addEventListener("click", unlock, true);
          document.addEventListener("keydown", unlock, true);
          return self2;
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var self2 = this || Howler2;
          if (self2._html5AudioPool.length) {
            return self2._html5AudioPool.pop();
          }
          var testPlay = new Audio().play();
          if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
            testPlay.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
          }
          return new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(audio) {
          var self2 = this || Howler2;
          if (audio._unlocked) {
            self2._html5AudioPool.push(audio);
          }
          return self2;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var self2 = this;
          if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (self2._howls[i]._webAudio) {
              for (var j = 0; j < self2._howls[i]._sounds.length; j++) {
                if (!self2._howls[i]._sounds[j]._paused) {
                  return self2;
                }
              }
            }
          }
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
          }
          self2._suspendTimer = setTimeout(function() {
            if (!self2.autoSuspend) {
              return;
            }
            self2._suspendTimer = null;
            self2.state = "suspending";
            var handleSuspension = function() {
              self2.state = "suspended";
              if (self2._resumeAfterSuspend) {
                delete self2._resumeAfterSuspend;
                self2._autoResume();
              }
            };
            self2.ctx.suspend().then(handleSuspension, handleSuspension);
          }, 3e4);
          return self2;
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var self2 = this;
          if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
            self2.ctx.resume().then(function() {
              self2.state = "running";
              for (var i = 0; i < self2._howls.length; i++) {
                self2._howls[i]._emit("resume");
              }
            });
            if (self2._suspendTimer) {
              clearTimeout(self2._suspendTimer);
              self2._suspendTimer = null;
            }
          } else if (self2.state === "suspending") {
            self2._resumeAfterSuspend = true;
          }
          return self2;
        }
      };
      var Howler2 = new HowlerGlobal2();
      var Howl2 = function(o) {
        var self2 = this;
        if (!o.src || o.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        self2.init(o);
      };
      Howl2.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(o) {
          var self2 = this;
          if (!Howler2.ctx) {
            setupAudioContext();
          }
          self2._autoplay = o.autoplay || false;
          self2._format = typeof o.format !== "string" ? o.format : [o.format];
          self2._html5 = o.html5 || false;
          self2._muted = o.mute || false;
          self2._loop = o.loop || false;
          self2._pool = o.pool || 5;
          self2._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
          self2._rate = o.rate || 1;
          self2._sprite = o.sprite || {};
          self2._src = typeof o.src !== "string" ? o.src : [o.src];
          self2._volume = o.volume !== void 0 ? o.volume : 1;
          self2._xhr = {
            method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
            headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
            withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
          };
          self2._duration = 0;
          self2._state = "unloaded";
          self2._sounds = [];
          self2._endTimers = {};
          self2._queue = [];
          self2._playLock = false;
          self2._onend = o.onend ? [{ fn: o.onend }] : [];
          self2._onfade = o.onfade ? [{ fn: o.onfade }] : [];
          self2._onload = o.onload ? [{ fn: o.onload }] : [];
          self2._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
          self2._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
          self2._onpause = o.onpause ? [{ fn: o.onpause }] : [];
          self2._onplay = o.onplay ? [{ fn: o.onplay }] : [];
          self2._onstop = o.onstop ? [{ fn: o.onstop }] : [];
          self2._onmute = o.onmute ? [{ fn: o.onmute }] : [];
          self2._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
          self2._onrate = o.onrate ? [{ fn: o.onrate }] : [];
          self2._onseek = o.onseek ? [{ fn: o.onseek }] : [];
          self2._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
          self2._onresume = [];
          self2._webAudio = Howler2.usingWebAudio && !self2._html5;
          if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
            Howler2._unlockAudio();
          }
          Howler2._howls.push(self2);
          if (self2._autoplay) {
            self2._queue.push({
              event: "play",
              action: function() {
                self2.play();
              }
            });
          }
          if (self2._preload && self2._preload !== "none") {
            self2.load();
          }
          return self2;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var self2 = this;
          var url = null;
          if (Howler2.noAudio) {
            self2._emit("loaderror", null, "No audio support.");
            return;
          }
          if (typeof self2._src === "string") {
            self2._src = [self2._src];
          }
          for (var i = 0; i < self2._src.length; i++) {
            var ext, str5;
            if (self2._format && self2._format[i]) {
              ext = self2._format[i];
            } else {
              str5 = self2._src[i];
              if (typeof str5 !== "string") {
                self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              ext = /^data:audio\/([^;,]+);/i.exec(str5);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(str5.split("?", 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              }
            }
            if (!ext) {
              console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
            }
            if (ext && Howler2.codecs(ext)) {
              url = self2._src[i];
              break;
            }
          }
          if (!url) {
            self2._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          self2._src = url;
          self2._state = "loading";
          if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
            self2._html5 = true;
            self2._webAudio = false;
          }
          new Sound2(self2);
          if (self2._webAudio) {
            loadBuffer(self2);
          }
          return self2;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(sprite, internal) {
          var self2 = this;
          var id = null;
          if (typeof sprite === "number") {
            id = sprite;
            sprite = null;
          } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
            return null;
          } else if (typeof sprite === "undefined") {
            sprite = "__default";
            if (!self2._playLock) {
              var num = 0;
              for (var i = 0; i < self2._sounds.length; i++) {
                if (self2._sounds[i]._paused && !self2._sounds[i]._ended) {
                  num++;
                  id = self2._sounds[i]._id;
                }
              }
              if (num === 1) {
                sprite = null;
              } else {
                id = null;
              }
            }
          }
          var sound = id ? self2._soundById(id) : self2._inactiveSound();
          if (!sound) {
            return null;
          }
          if (id && !sprite) {
            sprite = sound._sprite || "__default";
          }
          if (self2._state !== "loaded") {
            sound._sprite = sprite;
            sound._ended = false;
            var soundId = sound._id;
            self2._queue.push({
              event: "play",
              action: function() {
                self2.play(soundId);
              }
            });
            return soundId;
          }
          if (id && !sound._paused) {
            if (!internal) {
              self2._loadQueue("play");
            }
            return sound._id;
          }
          if (self2._webAudio) {
            Howler2._autoResume();
          }
          var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
          var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
          var timeout = duration * 1e3 / Math.abs(sound._rate);
          var start = self2._sprite[sprite][0] / 1e3;
          var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
          sound._sprite = sprite;
          sound._ended = false;
          var setParams = function() {
            sound._paused = false;
            sound._seek = seek;
            sound._start = start;
            sound._stop = stop;
            sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
          };
          if (seek >= stop) {
            self2._ended(sound);
            return;
          }
          var node = sound._node;
          if (self2._webAudio) {
            var playWebAudio = function() {
              self2._playLock = false;
              setParams();
              self2._refreshBuffer(sound);
              var vol = sound._muted || self2._muted ? 0 : sound._volume;
              node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              sound._playStart = Howler2.ctx.currentTime;
              if (typeof node.bufferSource.start === "undefined") {
                sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
              } else {
                sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
              }
              if (timeout !== Infinity) {
                self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
              }
              if (!internal) {
                setTimeout(function() {
                  self2._emit("play", sound._id);
                  self2._loadQueue();
                }, 0);
              }
            };
            if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
              playWebAudio();
            } else {
              self2._playLock = true;
              self2.once("resume", playWebAudio);
              self2._clearTimer(sound._id);
            }
          } else {
            var playHtml5 = function() {
              node.currentTime = seek;
              node.muted = sound._muted || self2._muted || Howler2._muted || node.muted;
              node.volume = sound._volume * Howler2.volume();
              node.playbackRate = sound._rate;
              try {
                var play = node.play();
                if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                  self2._playLock = true;
                  setParams();
                  play.then(function() {
                    self2._playLock = false;
                    node._unlocked = true;
                    if (!internal) {
                      self2._emit("play", sound._id);
                    } else {
                      self2._loadQueue();
                    }
                  }).catch(function() {
                    self2._playLock = false;
                    self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    sound._ended = true;
                    sound._paused = true;
                  });
                } else if (!internal) {
                  self2._playLock = false;
                  setParams();
                  self2._emit("play", sound._id);
                }
                node.playbackRate = sound._rate;
                if (node.paused) {
                  self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                if (sprite !== "__default" || sound._loop) {
                  self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
                } else {
                  self2._endTimers[sound._id] = function() {
                    self2._ended(sound);
                    node.removeEventListener("ended", self2._endTimers[sound._id], false);
                  };
                  node.addEventListener("ended", self2._endTimers[sound._id], false);
                }
              } catch (err) {
                self2._emit("playerror", sound._id, err);
              }
            };
            if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
              node.src = self2._src;
              node.load();
            }
            var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
            if (node.readyState >= 3 || loadedNoReadyState) {
              playHtml5();
            } else {
              self2._playLock = true;
              self2._state = "loading";
              var listener = function() {
                self2._state = "loaded";
                playHtml5();
                node.removeEventListener(Howler2._canPlayEvent, listener, false);
              };
              node.addEventListener(Howler2._canPlayEvent, listener, false);
              self2._clearTimer(sound._id);
            }
          }
          return sound._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "pause",
              action: function() {
                self2.pause(id);
              }
            });
            return self2;
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            self2._clearTimer(ids[i]);
            var sound = self2._soundById(ids[i]);
            if (sound && !sound._paused) {
              sound._seek = self2.seek(ids[i]);
              sound._rateSeek = 0;
              sound._paused = true;
              self2._stopFade(ids[i]);
              if (sound._node) {
                if (self2._webAudio) {
                  if (!sound._node.bufferSource) {
                    continue;
                  }
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound._node);
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.pause();
                }
              }
            }
            if (!arguments[1]) {
              self2._emit("pause", sound ? sound._id : null);
            }
          }
          return self2;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(id, internal) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "stop",
              action: function() {
                self2.stop(id);
              }
            });
            return self2;
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            self2._clearTimer(ids[i]);
            var sound = self2._soundById(ids[i]);
            if (sound) {
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              sound._paused = true;
              sound._ended = true;
              self2._stopFade(ids[i]);
              if (sound._node) {
                if (self2._webAudio) {
                  if (sound._node.bufferSource) {
                    if (typeof sound._node.bufferSource.stop === "undefined") {
                      sound._node.bufferSource.noteOff(0);
                    } else {
                      sound._node.bufferSource.stop(0);
                    }
                    self2._cleanBuffer(sound._node);
                  }
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.currentTime = sound._start || 0;
                  sound._node.pause();
                  if (sound._node.duration === Infinity) {
                    self2._clearSound(sound._node);
                  }
                }
              }
              if (!internal) {
                self2._emit("stop", sound._id);
              }
            }
          }
          return self2;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(muted, id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "mute",
              action: function() {
                self2.mute(muted, id);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            if (typeof muted === "boolean") {
              self2._muted = muted;
            } else {
              return self2._muted;
            }
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              sound._muted = muted;
              if (sound._interval) {
                self2._stopFade(sound._id);
              }
              if (self2._webAudio && sound._node) {
                sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.muted = Howler2._muted ? true : muted;
              }
              self2._emit("mute", sound._id);
            }
          }
          return self2;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var self2 = this;
          var args = arguments;
          var vol, id;
          if (args.length === 0) {
            return self2._volume;
          } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              vol = parseFloat(args[0]);
            }
          } else if (args.length >= 2) {
            vol = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "volume",
                action: function() {
                  self2.volume.apply(self2, args);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              self2._volume = vol;
            }
            id = self2._getSoundIds(id);
            for (var i = 0; i < id.length; i++) {
              sound = self2._soundById(id[i]);
              if (sound) {
                sound._volume = vol;
                if (!args[2]) {
                  self2._stopFade(id[i]);
                }
                if (self2._webAudio && sound._node && !sound._muted) {
                  sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
                } else if (sound._node && !sound._muted) {
                  sound._node.volume = vol * Howler2.volume();
                }
                self2._emit("volume", sound._id);
              }
            }
          } else {
            sound = id ? self2._soundById(id) : self2._sounds[0];
            return sound ? sound._volume : 0;
          }
          return self2;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(from, to, len5, id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "fade",
              action: function() {
                self2.fade(from, to, len5, id);
              }
            });
            return self2;
          }
          from = Math.min(Math.max(0, parseFloat(from)), 1);
          to = Math.min(Math.max(0, parseFloat(to)), 1);
          len5 = parseFloat(len5);
          self2.volume(from, id);
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              if (!id) {
                self2._stopFade(ids[i]);
              }
              if (self2._webAudio && !sound._muted) {
                var currentTime = Howler2.ctx.currentTime;
                var end = currentTime + len5 / 1e3;
                sound._volume = from;
                sound._node.gain.setValueAtTime(from, currentTime);
                sound._node.gain.linearRampToValueAtTime(to, end);
              }
              self2._startFadeInterval(sound, from, to, len5, ids[i], typeof id === "undefined");
            }
          }
          return self2;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(sound, from, to, len5, id, isGroup) {
          var self2 = this;
          var vol = from;
          var diff = to - from;
          var steps = Math.abs(diff / 0.01);
          var stepLen = Math.max(4, steps > 0 ? len5 / steps : len5);
          var lastTick = Date.now();
          sound._fadeTo = to;
          sound._interval = setInterval(function() {
            var tick = (Date.now() - lastTick) / len5;
            lastTick = Date.now();
            vol += diff * tick;
            vol = Math.round(vol * 100) / 100;
            if (diff < 0) {
              vol = Math.max(to, vol);
            } else {
              vol = Math.min(to, vol);
            }
            if (self2._webAudio) {
              sound._volume = vol;
            } else {
              self2.volume(vol, sound._id, true);
            }
            if (isGroup) {
              self2._volume = vol;
            }
            if (to < from && vol <= to || to > from && vol >= to) {
              clearInterval(sound._interval);
              sound._interval = null;
              sound._fadeTo = null;
              self2.volume(to, sound._id);
              self2._emit("fade", sound._id);
            }
          }, stepLen);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(id) {
          var self2 = this;
          var sound = self2._soundById(id);
          if (sound && sound._interval) {
            if (self2._webAudio) {
              sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
            }
            clearInterval(sound._interval);
            sound._interval = null;
            self2.volume(sound._fadeTo, id);
            sound._fadeTo = null;
            self2._emit("fade", id);
          }
          return self2;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var self2 = this;
          var args = arguments;
          var loop, id, sound;
          if (args.length === 0) {
            return self2._loop;
          } else if (args.length === 1) {
            if (typeof args[0] === "boolean") {
              loop = args[0];
              self2._loop = loop;
            } else {
              sound = self2._soundById(parseInt(args[0], 10));
              return sound ? sound._loop : false;
            }
          } else if (args.length === 2) {
            loop = args[0];
            id = parseInt(args[1], 10);
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            sound = self2._soundById(ids[i]);
            if (sound) {
              sound._loop = loop;
              if (self2._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.loop = loop;
                if (loop) {
                  sound._node.bufferSource.loopStart = sound._start || 0;
                  sound._node.bufferSource.loopEnd = sound._stop;
                  if (self2.playing(ids[i])) {
                    self2.pause(ids[i], true);
                    self2.play(ids[i], true);
                  }
                }
              }
            }
          }
          return self2;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var self2 = this;
          var args = arguments;
          var rate, id;
          if (args.length === 0) {
            id = self2._sounds[0]._id;
          } else if (args.length === 1) {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              rate = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            rate = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof rate === "number") {
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "rate",
                action: function() {
                  self2.rate.apply(self2, args);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              self2._rate = rate;
            }
            id = self2._getSoundIds(id);
            for (var i = 0; i < id.length; i++) {
              sound = self2._soundById(id[i]);
              if (sound) {
                if (self2.playing(id[i])) {
                  sound._rateSeek = self2.seek(id[i]);
                  sound._playStart = self2._webAudio ? Howler2.ctx.currentTime : sound._playStart;
                }
                sound._rate = rate;
                if (self2._webAudio && sound._node && sound._node.bufferSource) {
                  sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
                } else if (sound._node) {
                  sound._node.playbackRate = rate;
                }
                var seek = self2.seek(id[i]);
                var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
                var timeout = duration * 1e3 / Math.abs(sound._rate);
                if (self2._endTimers[id[i]] || !sound._paused) {
                  self2._clearTimer(id[i]);
                  self2._endTimers[id[i]] = setTimeout(self2._ended.bind(self2, sound), timeout);
                }
                self2._emit("rate", sound._id);
              }
            }
          } else {
            sound = self2._soundById(id);
            return sound ? sound._rate : self2._rate;
          }
          return self2;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var self2 = this;
          var args = arguments;
          var seek, id;
          if (args.length === 0) {
            if (self2._sounds.length) {
              id = self2._sounds[0]._id;
            }
          } else if (args.length === 1) {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else if (self2._sounds.length) {
              id = self2._sounds[0]._id;
              seek = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            seek = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          if (typeof id === "undefined") {
            return 0;
          }
          if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
            self2._queue.push({
              event: "seek",
              action: function() {
                self2.seek.apply(self2, args);
              }
            });
            return self2;
          }
          var sound = self2._soundById(id);
          if (sound) {
            if (typeof seek === "number" && seek >= 0) {
              var playing = self2.playing(id);
              if (playing) {
                self2.pause(id, true);
              }
              sound._seek = seek;
              sound._ended = false;
              self2._clearTimer(id);
              if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
                sound._node.currentTime = seek;
              }
              var seekAndEmit = function() {
                if (playing) {
                  self2.play(id, true);
                }
                self2._emit("seek", id);
              };
              if (playing && !self2._webAudio) {
                var emitSeek = function() {
                  if (!self2._playLock) {
                    seekAndEmit();
                  } else {
                    setTimeout(emitSeek, 0);
                  }
                };
                setTimeout(emitSeek, 0);
              } else {
                seekAndEmit();
              }
            } else {
              if (self2._webAudio) {
                var realTime = self2.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
                var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
              } else {
                return sound._node.currentTime;
              }
            }
          }
          return self2;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(id) {
          var self2 = this;
          if (typeof id === "number") {
            var sound = self2._soundById(id);
            return sound ? !sound._paused : false;
          }
          for (var i = 0; i < self2._sounds.length; i++) {
            if (!self2._sounds[i]._paused) {
              return true;
            }
          }
          return false;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(id) {
          var self2 = this;
          var duration = self2._duration;
          var sound = self2._soundById(id);
          if (sound) {
            duration = self2._sprite[sound._sprite][1] / 1e3;
          }
          return duration;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          var self2 = this;
          var sounds = self2._sounds;
          for (var i = 0; i < sounds.length; i++) {
            if (!sounds[i]._paused) {
              self2.stop(sounds[i]._id);
            }
            if (!self2._webAudio) {
              self2._clearSound(sounds[i]._node);
              sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
              sounds[i]._node.removeEventListener(Howler2._canPlayEvent, sounds[i]._loadFn, false);
              sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
              Howler2._releaseHtml5Audio(sounds[i]._node);
            }
            delete sounds[i]._node;
            self2._clearTimer(sounds[i]._id);
          }
          var index = Howler2._howls.indexOf(self2);
          if (index >= 0) {
            Howler2._howls.splice(index, 1);
          }
          var remCache = true;
          for (i = 0; i < Howler2._howls.length; i++) {
            if (Howler2._howls[i]._src === self2._src || self2._src.indexOf(Howler2._howls[i]._src) >= 0) {
              remCache = false;
              break;
            }
          }
          if (cache && remCache) {
            delete cache[self2._src];
          }
          Howler2.noAudio = false;
          self2._state = "unloaded";
          self2._sounds = [];
          self2 = null;
          return null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(event, fn, id, once) {
          var self2 = this;
          var events = self2["_on" + event];
          if (typeof fn === "function") {
            events.push(once ? { id, fn, once } : { id, fn });
          }
          return self2;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(event, fn, id) {
          var self2 = this;
          var events = self2["_on" + event];
          var i = 0;
          if (typeof fn === "number") {
            id = fn;
            fn = null;
          }
          if (fn || id) {
            for (i = 0; i < events.length; i++) {
              var isId = id === events[i].id;
              if (fn === events[i].fn && isId || !fn && isId) {
                events.splice(i, 1);
                break;
              }
            }
          } else if (event) {
            self2["_on" + event] = [];
          } else {
            var keys = Object.keys(self2);
            for (i = 0; i < keys.length; i++) {
              if (keys[i].indexOf("_on") === 0 && Array.isArray(self2[keys[i]])) {
                self2[keys[i]] = [];
              }
            }
          }
          return self2;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(event, fn, id) {
          var self2 = this;
          self2.on(event, fn, id, 1);
          return self2;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(event, id, msg) {
          var self2 = this;
          var events = self2["_on" + event];
          for (var i = events.length - 1; i >= 0; i--) {
            if (!events[i].id || events[i].id === id || event === "load") {
              setTimeout(function(fn) {
                fn.call(this, id, msg);
              }.bind(self2, events[i].fn), 0);
              if (events[i].once) {
                self2.off(event, events[i].fn, events[i].id);
              }
            }
          }
          self2._loadQueue(event);
          return self2;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(event) {
          var self2 = this;
          if (self2._queue.length > 0) {
            var task = self2._queue[0];
            if (task.event === event) {
              self2._queue.shift();
              self2._loadQueue();
            }
            if (!event) {
              task.action();
            }
          }
          return self2;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(sound) {
          var self2 = this;
          var sprite = sound._sprite;
          if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
            setTimeout(self2._ended.bind(self2, sound), 100);
            return self2;
          }
          var loop = !!(sound._loop || self2._sprite[sprite][2]);
          self2._emit("end", sound._id);
          if (!self2._webAudio && loop) {
            self2.stop(sound._id, true).play(sound._id);
          }
          if (self2._webAudio && loop) {
            self2._emit("play", sound._id);
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._playStart = Howler2.ctx.currentTime;
            var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
            self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
          }
          if (self2._webAudio && !loop) {
            sound._paused = true;
            sound._ended = true;
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            self2._clearTimer(sound._id);
            self2._cleanBuffer(sound._node);
            Howler2._autoSuspend();
          }
          if (!self2._webAudio && !loop) {
            self2.stop(sound._id, true);
          }
          return self2;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(id) {
          var self2 = this;
          if (self2._endTimers[id]) {
            if (typeof self2._endTimers[id] !== "function") {
              clearTimeout(self2._endTimers[id]);
            } else {
              var sound = self2._soundById(id);
              if (sound && sound._node) {
                sound._node.removeEventListener("ended", self2._endTimers[id], false);
              }
            }
            delete self2._endTimers[id];
          }
          return self2;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(id) {
          var self2 = this;
          for (var i = 0; i < self2._sounds.length; i++) {
            if (id === self2._sounds[i]._id) {
              return self2._sounds[i];
            }
          }
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var self2 = this;
          self2._drain();
          for (var i = 0; i < self2._sounds.length; i++) {
            if (self2._sounds[i]._ended) {
              return self2._sounds[i].reset();
            }
          }
          return new Sound2(self2);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var self2 = this;
          var limit = self2._pool;
          var cnt = 0;
          var i = 0;
          if (self2._sounds.length < limit) {
            return;
          }
          for (i = 0; i < self2._sounds.length; i++) {
            if (self2._sounds[i]._ended) {
              cnt++;
            }
          }
          for (i = self2._sounds.length - 1; i >= 0; i--) {
            if (cnt <= limit) {
              return;
            }
            if (self2._sounds[i]._ended) {
              if (self2._webAudio && self2._sounds[i]._node) {
                self2._sounds[i]._node.disconnect(0);
              }
              self2._sounds.splice(i, 1);
              cnt--;
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(id) {
          var self2 = this;
          if (typeof id === "undefined") {
            var ids = [];
            for (var i = 0; i < self2._sounds.length; i++) {
              ids.push(self2._sounds[i]._id);
            }
            return ids;
          } else {
            return [id];
          }
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(sound) {
          var self2 = this;
          sound._node.bufferSource = Howler2.ctx.createBufferSource();
          sound._node.bufferSource.buffer = cache[self2._src];
          if (sound._panner) {
            sound._node.bufferSource.connect(sound._panner);
          } else {
            sound._node.bufferSource.connect(sound._node);
          }
          sound._node.bufferSource.loop = sound._loop;
          if (sound._loop) {
            sound._node.bufferSource.loopStart = sound._start || 0;
            sound._node.bufferSource.loopEnd = sound._stop || 0;
          }
          sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
          return self2;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(node) {
          var self2 = this;
          var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
          if (Howler2._scratchBuffer && node.bufferSource) {
            node.bufferSource.onended = null;
            node.bufferSource.disconnect(0);
            if (isIOS) {
              try {
                node.bufferSource.buffer = Howler2._scratchBuffer;
              } catch (e) {
              }
            }
          }
          node.bufferSource = null;
          return self2;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(node) {
          var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
          if (!checkIE) {
            node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
          }
        }
      };
      var Sound2 = function(howl) {
        this._parent = howl;
        this.init();
      };
      Sound2.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var self2 = this;
          var parent = self2._parent;
          self2._muted = parent._muted;
          self2._loop = parent._loop;
          self2._volume = parent._volume;
          self2._rate = parent._rate;
          self2._seek = 0;
          self2._paused = true;
          self2._ended = true;
          self2._sprite = "__default";
          self2._id = ++Howler2._counter;
          parent._sounds.push(self2);
          self2.create();
          return self2;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var self2 = this;
          var parent = self2._parent;
          var volume = Howler2._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
          if (parent._webAudio) {
            self2._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
            self2._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
            self2._node.paused = true;
            self2._node.connect(Howler2.masterGain);
          } else if (!Howler2.noAudio) {
            self2._node = Howler2._obtainHtml5Audio();
            self2._errorFn = self2._errorListener.bind(self2);
            self2._node.addEventListener("error", self2._errorFn, false);
            self2._loadFn = self2._loadListener.bind(self2);
            self2._node.addEventListener(Howler2._canPlayEvent, self2._loadFn, false);
            self2._endFn = self2._endListener.bind(self2);
            self2._node.addEventListener("ended", self2._endFn, false);
            self2._node.src = parent._src;
            self2._node.preload = parent._preload === true ? "auto" : parent._preload;
            self2._node.volume = volume * Howler2.volume();
            self2._node.load();
          }
          return self2;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var self2 = this;
          var parent = self2._parent;
          self2._muted = parent._muted;
          self2._loop = parent._loop;
          self2._volume = parent._volume;
          self2._rate = parent._rate;
          self2._seek = 0;
          self2._rateSeek = 0;
          self2._paused = true;
          self2._ended = true;
          self2._sprite = "__default";
          self2._id = ++Howler2._counter;
          return self2;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var self2 = this;
          self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
          self2._node.removeEventListener("error", self2._errorFn, false);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var self2 = this;
          var parent = self2._parent;
          parent._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (Object.keys(parent._sprite).length === 0) {
            parent._sprite = { __default: [0, parent._duration * 1e3] };
          }
          if (parent._state !== "loaded") {
            parent._state = "loaded";
            parent._emit("load");
            parent._loadQueue();
          }
          self2._node.removeEventListener(Howler2._canPlayEvent, self2._loadFn, false);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var self2 = this;
          var parent = self2._parent;
          if (parent._duration === Infinity) {
            parent._duration = Math.ceil(self2._node.duration * 10) / 10;
            if (parent._sprite.__default[1] === Infinity) {
              parent._sprite.__default[1] = parent._duration * 1e3;
            }
            parent._ended(self2);
          }
          self2._node.removeEventListener("ended", self2._endFn, false);
        }
      };
      var cache = {};
      var loadBuffer = function(self2) {
        var url = self2._src;
        if (cache[url]) {
          self2._duration = cache[url].duration;
          loadSound(self2);
          return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
          var data = atob(url.split(",")[1]);
          var dataView = new Uint8Array(data.length);
          for (var i = 0; i < data.length; ++i) {
            dataView[i] = data.charCodeAt(i);
          }
          decodeAudioData(dataView.buffer, self2);
        } else {
          var xhr = new XMLHttpRequest();
          xhr.open(self2._xhr.method, url, true);
          xhr.withCredentials = self2._xhr.withCredentials;
          xhr.responseType = "arraybuffer";
          if (self2._xhr.headers) {
            Object.keys(self2._xhr.headers).forEach(function(key) {
              xhr.setRequestHeader(key, self2._xhr.headers[key]);
            });
          }
          xhr.onload = function() {
            var code = (xhr.status + "")[0];
            if (code !== "0" && code !== "2" && code !== "3") {
              self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
              return;
            }
            decodeAudioData(xhr.response, self2);
          };
          xhr.onerror = function() {
            if (self2._webAudio) {
              self2._html5 = true;
              self2._webAudio = false;
              self2._sounds = [];
              delete cache[url];
              self2.load();
            }
          };
          safeXhrSend(xhr);
        }
      };
      var safeXhrSend = function(xhr) {
        try {
          xhr.send();
        } catch (e) {
          xhr.onerror();
        }
      };
      var decodeAudioData = function(arraybuffer, self2) {
        var error = function() {
          self2._emit("loaderror", null, "Decoding audio data failed.");
        };
        var success = function(buffer) {
          if (buffer && self2._sounds.length > 0) {
            cache[self2._src] = buffer;
            loadSound(self2, buffer);
          } else {
            error();
          }
        };
        if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
          Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
        } else {
          Howler2.ctx.decodeAudioData(arraybuffer, success, error);
        }
      };
      var loadSound = function(self2, buffer) {
        if (buffer && !self2._duration) {
          self2._duration = buffer.duration;
        }
        if (Object.keys(self2._sprite).length === 0) {
          self2._sprite = { __default: [0, self2._duration * 1e3] };
        }
        if (self2._state !== "loaded") {
          self2._state = "loaded";
          self2._emit("load");
          self2._loadQueue();
        }
      };
      var setupAudioContext = function() {
        if (!Howler2.usingWebAudio) {
          return;
        }
        try {
          if (typeof AudioContext !== "undefined") {
            Howler2.ctx = new AudioContext();
          } else if (typeof webkitAudioContext !== "undefined") {
            Howler2.ctx = new webkitAudioContext();
          } else {
            Howler2.usingWebAudio = false;
          }
        } catch (e) {
          Howler2.usingWebAudio = false;
        }
        if (!Howler2.ctx) {
          Howler2.usingWebAudio = false;
        }
        var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
        var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
          var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
          if (Howler2._navigator && !safari) {
            Howler2.usingWebAudio = false;
          }
        }
        if (Howler2.usingWebAudio) {
          Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
          Howler2.masterGain.connect(Howler2.ctx.destination);
        }
        Howler2._setup();
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return {
            Howler: Howler2,
            Howl: Howl2
          };
        });
      }
      if (typeof exports !== "undefined") {
        exports.Howler = Howler2;
        exports.Howl = Howl2;
      }
      if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal2;
        global.Howler = Howler2;
        global.Howl = Howl2;
        global.Sound = Sound2;
      } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal2;
        window.Howler = Howler2;
        window.Howl = Howl2;
        window.Sound = Sound2;
      }
    })();
    (function() {
      "use strict";
      HowlerGlobal.prototype._pos = [0, 0, 0];
      HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
      HowlerGlobal.prototype.stereo = function(pan) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        for (var i = self2._howls.length - 1; i >= 0; i--) {
          self2._howls[i].stereo(pan);
        }
        return self2;
      };
      HowlerGlobal.prototype.pos = function(x, y, z) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        y = typeof y !== "number" ? self2._pos[1] : y;
        z = typeof z !== "number" ? self2._pos[2] : z;
        if (typeof x === "number") {
          self2._pos = [x, y, z];
          if (typeof self2.ctx.listener.positionX !== "undefined") {
            self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
          } else {
            self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
          }
        } else {
          return self2._pos;
        }
        return self2;
      };
      HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        var or = self2._orientation;
        y = typeof y !== "number" ? or[1] : y;
        z = typeof z !== "number" ? or[2] : z;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x === "number") {
          self2._orientation = [x, y, z, xUp, yUp, zUp];
          if (typeof self2.ctx.listener.forwardX !== "undefined") {
            self2.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
          } else {
            self2.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
          }
        } else {
          return or;
        }
        return self2;
      };
      Howl.prototype.init = function(_super) {
        return function(o) {
          var self2 = this;
          self2._orientation = o.orientation || [1, 0, 0];
          self2._stereo = o.stereo || null;
          self2._pos = o.pos || null;
          self2._pannerAttr = {
            coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
            coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
            coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
            distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
            maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
            panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
            refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
            rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
          };
          self2._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
          self2._onpos = o.onpos ? [{ fn: o.onpos }] : [];
          self2._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
          return _super.call(this, o);
        };
      }(Howl.prototype.init);
      Howl.prototype.stereo = function(pan, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "stereo",
            action: function() {
              self2.stereo(pan, id);
            }
          });
          return self2;
        }
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        if (typeof id === "undefined") {
          if (typeof pan === "number") {
            self2._stereo = pan;
            self2._pos = [pan, 0, 0];
          } else {
            return self2._stereo;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (typeof pan === "number") {
              sound._stereo = pan;
              sound._pos = [pan, 0, 0];
              if (sound._node) {
                sound._pannerAttr.panningModel = "equalpower";
                if (!sound._panner || !sound._panner.pan) {
                  setupPanner(sound, pannerType);
                }
                if (pannerType === "spatial") {
                  if (typeof sound._panner.positionX !== "undefined") {
                    sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                    sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                    sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setPosition(pan, 0, 0);
                  }
                } else {
                  sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                }
              }
              self2._emit("stereo", sound._id);
            } else {
              return sound._stereo;
            }
          }
        }
        return self2;
      };
      Howl.prototype.pos = function(x, y, z, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "pos",
            action: function() {
              self2.pos(x, y, z, id);
            }
          });
          return self2;
        }
        y = typeof y !== "number" ? 0 : y;
        z = typeof z !== "number" ? -0.5 : z;
        if (typeof id === "undefined") {
          if (typeof x === "number") {
            self2._pos = [x, y, z];
          } else {
            return self2._pos;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (typeof x === "number") {
              sound._pos = [x, y, z];
              if (sound._node) {
                if (!sound._panner || sound._panner.pan) {
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(x, y, z);
                }
              }
              self2._emit("pos", sound._id);
            } else {
              return sound._pos;
            }
          }
        }
        return self2;
      };
      Howl.prototype.orientation = function(x, y, z, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "orientation",
            action: function() {
              self2.orientation(x, y, z, id);
            }
          });
          return self2;
        }
        y = typeof y !== "number" ? self2._orientation[1] : y;
        z = typeof z !== "number" ? self2._orientation[2] : z;
        if (typeof id === "undefined") {
          if (typeof x === "number") {
            self2._orientation = [x, y, z];
          } else {
            return self2._orientation;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (typeof x === "number") {
              sound._orientation = [x, y, z];
              if (sound._node) {
                if (!sound._panner) {
                  if (!sound._pos) {
                    sound._pos = self2._pos || [0, 0, -0.5];
                  }
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.orientationX !== "undefined") {
                  sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setOrientation(x, y, z);
                }
              }
              self2._emit("orientation", sound._id);
            } else {
              return sound._orientation;
            }
          }
        }
        return self2;
      };
      Howl.prototype.pannerAttr = function() {
        var self2 = this;
        var args = arguments;
        var o, id, sound;
        if (!self2._webAudio) {
          return self2;
        }
        if (args.length === 0) {
          return self2._pannerAttr;
        } else if (args.length === 1) {
          if (typeof args[0] === "object") {
            o = args[0];
            if (typeof id === "undefined") {
              if (!o.pannerAttr) {
                o.pannerAttr = {
                  coneInnerAngle: o.coneInnerAngle,
                  coneOuterAngle: o.coneOuterAngle,
                  coneOuterGain: o.coneOuterGain,
                  distanceModel: o.distanceModel,
                  maxDistance: o.maxDistance,
                  refDistance: o.refDistance,
                  rolloffFactor: o.rolloffFactor,
                  panningModel: o.panningModel
                };
              }
              self2._pannerAttr = {
                coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
                coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
                coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self2._coneOuterGain,
                distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self2._distanceModel,
                maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self2._maxDistance,
                refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self2._refDistance,
                rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self2._rolloffFactor,
                panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self2._panningModel
              };
            }
          } else {
            sound = self2._soundById(parseInt(args[0], 10));
            return sound ? sound._pannerAttr : self2._pannerAttr;
          }
        } else if (args.length === 2) {
          o = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          sound = self2._soundById(ids[i]);
          if (sound) {
            var pa = sound._pannerAttr;
            pa = {
              coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
              coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
              coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
              distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
              maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
              refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
              rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
              panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
            };
            var panner = sound._panner;
            if (panner) {
              panner.coneInnerAngle = pa.coneInnerAngle;
              panner.coneOuterAngle = pa.coneOuterAngle;
              panner.coneOuterGain = pa.coneOuterGain;
              panner.distanceModel = pa.distanceModel;
              panner.maxDistance = pa.maxDistance;
              panner.refDistance = pa.refDistance;
              panner.rolloffFactor = pa.rolloffFactor;
              panner.panningModel = pa.panningModel;
            } else {
              if (!sound._pos) {
                sound._pos = self2._pos || [0, 0, -0.5];
              }
              setupPanner(sound, "spatial");
            }
          }
        }
        return self2;
      };
      Sound.prototype.init = function(_super) {
        return function() {
          var self2 = this;
          var parent = self2._parent;
          self2._orientation = parent._orientation;
          self2._stereo = parent._stereo;
          self2._pos = parent._pos;
          self2._pannerAttr = parent._pannerAttr;
          _super.call(this);
          if (self2._stereo) {
            parent.stereo(self2._stereo);
          } else if (self2._pos) {
            parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
          }
        };
      }(Sound.prototype.init);
      Sound.prototype.reset = function(_super) {
        return function() {
          var self2 = this;
          var parent = self2._parent;
          self2._orientation = parent._orientation;
          self2._stereo = parent._stereo;
          self2._pos = parent._pos;
          self2._pannerAttr = parent._pannerAttr;
          if (self2._stereo) {
            parent.stereo(self2._stereo);
          } else if (self2._pos) {
            parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
          } else if (self2._panner) {
            self2._panner.disconnect(0);
            self2._panner = void 0;
            parent._refreshBuffer(self2);
          }
          return _super.call(this);
        };
      }(Sound.prototype.reset);
      var setupPanner = function(sound, type) {
        type = type || "spatial";
        if (type === "spatial") {
          sound._panner = Howler.ctx.createPanner();
          sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
          sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
          sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
          sound._panner.distanceModel = sound._pannerAttr.distanceModel;
          sound._panner.maxDistance = sound._pannerAttr.maxDistance;
          sound._panner.refDistance = sound._pannerAttr.refDistance;
          sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
          sound._panner.panningModel = sound._pannerAttr.panningModel;
          if (typeof sound._panner.positionX !== "undefined") {
            sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
            sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
            sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
          }
          if (typeof sound._panner.orientationX !== "undefined") {
            sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
            sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
            sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
          }
        } else {
          sound._panner = Howler.ctx.createStereoPanner();
          sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
        }
        sound._panner.connect(sound._node);
        if (!sound._paused) {
          sound._parent.pause(sound._id, true).play(sound._id, true);
        }
      };
    })();
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim)
          last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim)
          last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals7(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals7(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals7(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len5, start, end, list;
      for (i = 0, len5 = holeIndices.length; i < len5; i++) {
        start = holeIndices[i] * dim;
        end = i < len5 - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx)
              return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals7(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals7(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len5 = holeIndices.length; i < len5; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len5 - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/lib/EventTarget.js
var PRIVATE, EventTarget2;
var init_EventTarget = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/lib/EventTarget.js"() {
    PRIVATE = Symbol("@@webxr-polyfill/EventTarget");
    EventTarget2 = class {
      constructor() {
        this[PRIVATE] = {
          listeners: /* @__PURE__ */ new Map()
        };
      }
      /**
       * @param {string} type
       * @param {Function} listener
       */
      addEventListener(type, listener) {
        if (typeof type !== "string") {
          throw new Error("`type` must be a string");
        }
        if (typeof listener !== "function") {
          throw new Error("`listener` must be a function");
        }
        const typedListeners = this[PRIVATE].listeners.get(type) || [];
        typedListeners.push(listener);
        this[PRIVATE].listeners.set(type, typedListeners);
      }
      /**
       * @param {string} type
       * @param {Function} listener
       */
      removeEventListener(type, listener) {
        if (typeof type !== "string") {
          throw new Error("`type` must be a string");
        }
        if (typeof listener !== "function") {
          throw new Error("`listener` must be a function");
        }
        const typedListeners = this[PRIVATE].listeners.get(type) || [];
        for (let i = typedListeners.length; i >= 0; i--) {
          if (typedListeners[i] === listener) {
            typedListeners.pop();
          }
        }
      }
      /**
       * @param {string} type
       * @param {object} event
       */
      dispatchEvent(type, event) {
        const typedListeners = this[PRIVATE].listeners.get(type) || [];
        const queue = [];
        for (let i = 0; i < typedListeners.length; i++) {
          queue[i] = typedListeners[i];
        }
        for (let listener of queue) {
          listener(event);
        }
        if (typeof this[`on${type}`] === "function") {
          this[`on${type}`](event);
        }
      }
    };
  }
});

// ../node_modules/gl-matrix/src/gl-matrix/common.js
var EPSILON2, ARRAY_TYPE2, degree2;
var init_common = __esm({
  "../node_modules/gl-matrix/src/gl-matrix/common.js"() {
    EPSILON2 = 1e-6;
    ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
    degree2 = Math.PI / 180;
  }
});

// ../node_modules/gl-matrix/src/gl-matrix/mat4.js
function create7() {
  let out = new ARRAY_TYPE2(16);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function identity4(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function invert4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply5(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function fromRotationTranslation3(out, q, v) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;
  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function getTranslation3(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getRotation2(out, mat) {
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function perspective2(out, fovy, aspect, near, far) {
  let f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var init_mat4 = __esm({
  "../node_modules/gl-matrix/src/gl-matrix/mat4.js"() {
    init_common();
  }
});

// ../node_modules/gl-matrix/src/gl-matrix/vec3.js
function create8() {
  let out = new ARRAY_TYPE2(3);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone6(a) {
  var out = new ARRAY_TYPE2(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length5(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function fromValues6(x, y, z) {
  let out = new ARRAY_TYPE2(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy7(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function add6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function normalize5(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len5 = x * x + y * y + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    out[0] = a[0] * len5;
    out[1] = a[1] * len5;
    out[2] = a[2] * len5;
  }
  return out;
}
function dot5(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross2(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformQuat2(out, a, q) {
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  let x = a[0], y = a[1], z = a[2];
  let uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  let uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  let w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function angle2(a, b) {
  let tempA = fromValues6(a[0], a[1], a[2]);
  let tempB = fromValues6(b[0], b[1], b[2]);
  normalize5(tempA, tempA);
  normalize5(tempB, tempB);
  let cosine = dot5(tempA, tempB);
  if (cosine > 1) {
    return 0;
  } else if (cosine < -1) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
var len4, forEach3;
var init_vec3 = __esm({
  "../node_modules/gl-matrix/src/gl-matrix/vec3.js"() {
    init_common();
    len4 = length5;
    forEach3 = function() {
      let vec = create8();
      return function(a, stride, offset2, count, fn, arg) {
        let i, l;
        if (!stride) {
          stride = 3;
        }
        if (!offset2) {
          offset2 = 0;
        }
        if (count) {
          l = Math.min(count * stride + offset2, a.length);
        } else {
          l = a.length;
        }
        for (i = offset2; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
        }
        return a;
      };
    }();
  }
});

// ../node_modules/gl-matrix/src/gl-matrix/mat3.js
function create9() {
  let out = new ARRAY_TYPE2(9);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
var init_mat3 = __esm({
  "../node_modules/gl-matrix/src/gl-matrix/mat3.js"() {
    init_common();
  }
});

// ../node_modules/gl-matrix/src/gl-matrix/vec4.js
function create10() {
  let out = new ARRAY_TYPE2(4);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone7(a) {
  let out = new ARRAY_TYPE2(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues7(x, y, z, w) {
  let out = new ARRAY_TYPE2(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy8(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function normalize6(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len5 = x * x + y * y + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    out[0] = x * len5;
    out[1] = y * len5;
    out[2] = z * len5;
    out[3] = w * len5;
  }
  return out;
}
var forEach4;
var init_vec4 = __esm({
  "../node_modules/gl-matrix/src/gl-matrix/vec4.js"() {
    init_common();
    forEach4 = function() {
      let vec = create10();
      return function(a, stride, offset2, count, fn, arg) {
        let i, l;
        if (!stride) {
          stride = 4;
        }
        if (!offset2) {
          offset2 = 0;
        }
        if (count) {
          l = Math.min(count * stride + offset2, a.length);
        } else {
          l = a.length;
        }
        for (i = offset2; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          vec[3] = a[i + 3];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
          a[i + 3] = vec[3];
        }
        return a;
      };
    }();
  }
});

// ../node_modules/gl-matrix/src/gl-matrix/quat.js
function create11() {
  let out = new ARRAY_TYPE2(4);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle2(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply6(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function slerp2(out, a, b, t) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];
  let omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON2) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert5(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot7 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  let invDot = dot7 ? 1 / dot7 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function fromMat32(out, m) {
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    let i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    let j = (i + 1) % 3;
    let k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler2(out, x, y, z) {
  let halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  let sx = Math.sin(x);
  let cx = Math.cos(x);
  let sy = Math.sin(y);
  let cy = Math.cos(y);
  let sz = Math.sin(z);
  let cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
var clone8, fromValues8, copy9, normalize7, rotationTo2, sqlerp2, setAxes2;
var init_quat = __esm({
  "../node_modules/gl-matrix/src/gl-matrix/quat.js"() {
    init_common();
    init_mat3();
    init_vec3();
    init_vec4();
    clone8 = clone7;
    fromValues8 = fromValues7;
    copy9 = copy8;
    normalize7 = normalize6;
    rotationTo2 = function() {
      let tmpvec3 = create8();
      let xUnitVec3 = fromValues6(1, 0, 0);
      let yUnitVec3 = fromValues6(0, 1, 0);
      return function(out, a, b) {
        let dot7 = dot5(a, b);
        if (dot7 < -0.999999) {
          cross2(tmpvec3, xUnitVec3, a);
          if (len4(tmpvec3) < 1e-6)
            cross2(tmpvec3, yUnitVec3, a);
          normalize5(tmpvec3, tmpvec3);
          setAxisAngle2(out, tmpvec3, Math.PI);
          return out;
        } else if (dot7 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross2(tmpvec3, a, b);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot7;
          return normalize7(out, out);
        }
      };
    }();
    sqlerp2 = function() {
      let temp1 = create11();
      let temp2 = create11();
      return function(out, a, b, c, d, t) {
        slerp2(temp1, a, d, t);
        slerp2(temp2, b, c, t);
        slerp2(out, temp1, temp2, 2 * t * (1 - t));
        return out;
      };
    }();
    setAxes2 = function() {
      let matr = create9();
      return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize7(out, fromMat32(out, matr));
      };
    }();
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRRigidTransform.js
var PRIVATE2, XRRigidTransform2;
var init_XRRigidTransform = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRRigidTransform.js"() {
    init_mat4();
    init_vec3();
    init_quat();
    PRIVATE2 = Symbol("@@webxr-polyfill/XRRigidTransform");
    XRRigidTransform2 = class {
      // no arguments: identity transform
      // (Float32Array): transform based on matrix
      // (DOMPointReadOnly): transform based on position without any rotation
      // (DOMPointReadOnly, DOMPointReadOnly): transform based on position and
      // orientation quaternion
      constructor() {
        this[PRIVATE2] = {
          matrix: null,
          position: null,
          orientation: null,
          inverse: null
        };
        if (arguments.length === 0) {
          this[PRIVATE2].matrix = identity4(new Float32Array(16));
        } else if (arguments.length === 1) {
          if (arguments[0] instanceof Float32Array) {
            this[PRIVATE2].matrix = arguments[0];
          } else {
            this[PRIVATE2].position = this._getPoint(arguments[0]);
            this[PRIVATE2].orientation = DOMPointReadOnly.fromPoint({
              x: 0,
              y: 0,
              z: 0,
              w: 1
            });
          }
        } else if (arguments.length === 2) {
          this[PRIVATE2].position = this._getPoint(arguments[0]);
          this[PRIVATE2].orientation = this._getPoint(arguments[1]);
        } else {
          throw new Error("Too many arguments!");
        }
        if (this[PRIVATE2].matrix) {
          let position = create8();
          getTranslation3(position, this[PRIVATE2].matrix);
          this[PRIVATE2].position = DOMPointReadOnly.fromPoint({
            x: position[0],
            y: position[1],
            z: position[2]
          });
          let orientation = create11();
          getRotation2(orientation, this[PRIVATE2].matrix);
          this[PRIVATE2].orientation = DOMPointReadOnly.fromPoint({
            x: orientation[0],
            y: orientation[1],
            z: orientation[2],
            w: orientation[3]
          });
        } else {
          this[PRIVATE2].matrix = identity4(new Float32Array(16));
          fromRotationTranslation3(
            this[PRIVATE2].matrix,
            fromValues8(
              this[PRIVATE2].orientation.x,
              this[PRIVATE2].orientation.y,
              this[PRIVATE2].orientation.z,
              this[PRIVATE2].orientation.w
            ),
            fromValues6(
              this[PRIVATE2].position.x,
              this[PRIVATE2].position.y,
              this[PRIVATE2].position.z
            )
          );
        }
      }
      /**
       * Try to convert arg to a DOMPointReadOnly if it isn't already one.
       * @param {*} arg
       * @return {DOMPointReadOnly}
       */
      _getPoint(arg) {
        if (arg instanceof DOMPointReadOnly) {
          return arg;
        }
        return DOMPointReadOnly.fromPoint(arg);
      }
      /**
       * @return {Float32Array}
       */
      get matrix() {
        return this[PRIVATE2].matrix;
      }
      /**
       * @return {DOMPointReadOnly}
       */
      get position() {
        return this[PRIVATE2].position;
      }
      /**
       * @return {DOMPointReadOnly}
       */
      get orientation() {
        return this[PRIVATE2].orientation;
      }
      /**
       * @return {XRRigidTransform}
       */
      get inverse() {
        if (this[PRIVATE2].inverse === null) {
          let invMatrix = identity4(new Float32Array(16));
          invert4(invMatrix, this[PRIVATE2].matrix);
          this[PRIVATE2].inverse = new XRRigidTransform2(invMatrix);
          this[PRIVATE2].inverse[PRIVATE2].inverse = this;
        }
        return this[PRIVATE2].inverse;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRSpace.js
var XRSpace_exports = {};
__export(XRSpace_exports, {
  PRIVATE: () => PRIVATE3,
  XRSpaceSpecialTypes: () => XRSpaceSpecialTypes,
  default: () => XRSpace
});
var PRIVATE3, XRSpaceSpecialTypes, XRSpace;
var init_XRSpace = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRSpace.js"() {
    init_XRRigidTransform();
    init_mat4();
    PRIVATE3 = Symbol("@@webxr-polyfill/XRSpace");
    XRSpaceSpecialTypes = [
      "grip",
      "target-ray"
    ];
    XRSpace = class {
      /**
       * @param {string?} specialType
       * @param {XRInputSource?} inputSource 
       */
      constructor(specialType = null, inputSource = null) {
        this[PRIVATE3] = {
          specialType,
          inputSource,
          // The transform for the space in the base space, along with it's inverse
          baseMatrix: null,
          inverseBaseMatrix: null,
          lastFrameId: -1
        };
      }
      /**
       * @return {string?}
       */
      get _specialType() {
        return this[PRIVATE3].specialType;
      }
      /**
       * @return {XRInputSource?}
       */
      get _inputSource() {
        return this[PRIVATE3].inputSource;
      }
      /**
       * NON-STANDARD
       * Trigger an update for this space's base pose if necessary
       * @param {XRDevice} device
       * @param {Number} frameId
       */
      _ensurePoseUpdated(device, frameId) {
        if (frameId == this[PRIVATE3].lastFrameId)
          return;
        this[PRIVATE3].lastFrameId = frameId;
        this._onPoseUpdate(device);
      }
      /**
       * NON-STANDARD
       * Called when this space's base pose needs to be updated
       * @param {XRDevice} device
       */
      _onPoseUpdate(device) {
        if (this[PRIVATE3].specialType == "viewer") {
          this._baseMatrix = device.getBasePoseMatrix();
        }
      }
      /**
       * NON-STANDARD
       * @param {Float32Array(16)} matrix
       */
      set _baseMatrix(matrix) {
        this[PRIVATE3].baseMatrix = matrix;
        this[PRIVATE3].inverseBaseMatrix = null;
      }
      /**
       * NON-STANDARD
       * @return {Float32Array(16)}
       */
      get _baseMatrix() {
        if (!this[PRIVATE3].baseMatrix) {
          if (this[PRIVATE3].inverseBaseMatrix) {
            this[PRIVATE3].baseMatrix = new Float32Array(16);
            invert4(this[PRIVATE3].baseMatrix, this[PRIVATE3].inverseBaseMatrix);
          }
        }
        return this[PRIVATE3].baseMatrix;
      }
      /**
       * NON-STANDARD
       * @param {Float32Array(16)} matrix
       */
      set _inverseBaseMatrix(matrix) {
        this[PRIVATE3].inverseBaseMatrix = matrix;
        this[PRIVATE3].baseMatrix = null;
      }
      /**
       * NON-STANDARD
       * @return {Float32Array(16)}
       */
      get _inverseBaseMatrix() {
        if (!this[PRIVATE3].inverseBaseMatrix) {
          if (this[PRIVATE3].baseMatrix) {
            this[PRIVATE3].inverseBaseMatrix = new Float32Array(16);
            invert4(this[PRIVATE3].inverseBaseMatrix, this[PRIVATE3].baseMatrix);
          }
        }
        return this[PRIVATE3].inverseBaseMatrix;
      }
      /**
       * NON-STANDARD
       * Gets the transform of the given space in this space
       *
       * @param {XRSpace} space
       * @return {XRRigidTransform}
       */
      _getSpaceRelativeTransform(space) {
        if (!this._inverseBaseMatrix || !space._baseMatrix) {
          return null;
        }
        let out = new Float32Array(16);
        multiply5(out, this._inverseBaseMatrix, space._baseMatrix);
        return new XRRigidTransform2(out);
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpace.js
function isFloor(type) {
  return type === "bounded-floor" || type === "local-floor";
}
var DEFAULT_EMULATION_HEIGHT, PRIVATE4, XRReferenceSpaceTypes, XRReferenceSpace;
var init_XRReferenceSpace = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpace.js"() {
    init_XRSpace();
    init_mat4();
    DEFAULT_EMULATION_HEIGHT = 1.6;
    PRIVATE4 = Symbol("@@webxr-polyfill/XRReferenceSpace");
    XRReferenceSpaceTypes = [
      "viewer",
      "local",
      "local-floor",
      "bounded-floor",
      "unbounded"
      // TODO: 'unbounded' is not supported by the polyfill.
    ];
    XRReferenceSpace = class extends XRSpace {
      /**
       * Optionally takes a `transform` from a device's requestFrameOfReferenceMatrix
       * so device's can provide their own transforms for stage (or if they
       * wanted to override eye-level/head-model).
       *
       * @param {XRReferenceSpaceType} type
       * @param {Float32Array?} transform
       */
      constructor(type, transform = null) {
        if (!XRReferenceSpaceTypes.includes(type)) {
          throw new Error(`XRReferenceSpaceType must be one of ${XRReferenceSpaceTypes}`);
        }
        super(type);
        if (type === "bounded-floor" && !transform) {
          throw new Error(`XRReferenceSpace cannot use 'bounded-floor' type if the platform does not provide the floor level`);
        }
        if (isFloor(type) && !transform) {
          transform = identity4(new Float32Array(16));
          transform[13] = DEFAULT_EMULATION_HEIGHT;
        }
        this._inverseBaseMatrix = transform || identity4(new Float32Array(16));
        this[PRIVATE4] = {
          type,
          transform,
          originOffset: identity4(new Float32Array(16))
        };
      }
      /**
       * NON-STANDARD
       * Takes a base pose model matrix and transforms it by the
       * frame of reference.
       *
       * @param {Float32Array} out
       * @param {Float32Array} pose
       */
      _transformBasePoseMatrix(out, pose) {
        multiply5(out, this._inverseBaseMatrix, pose);
      }
      /**
       * NON-STANDARD
       * 
       * @return {Float32Array}
       */
      _originOffsetMatrix() {
        return this[PRIVATE4].originOffset;
      }
      /**
       * transformMatrix = Inv(OriginOffsetMatrix) * transformMatrix
       * @param {Float32Array} transformMatrix 
       */
      _adjustForOriginOffset(transformMatrix) {
        let inverseOriginOffsetMatrix = new Float32Array(16);
        invert4(inverseOriginOffsetMatrix, this[PRIVATE4].originOffset);
        multiply5(transformMatrix, inverseOriginOffsetMatrix, transformMatrix);
      }
      /**
       * Gets the transform of the given space in this space
       *
       * @param {XRSpace} space
       * @return {XRRigidTransform}
       */
      _getSpaceRelativeTransform(space) {
        let transform = super._getSpaceRelativeTransform(space);
        this._adjustForOriginOffset(transform.matrix);
        return new XRRigidTransform(transform.matrix);
      }
      /**
       * Doesn't update the bound geometry for bounded reference spaces.
       * @param {XRRigidTransform} additionalOffset
       * @return {XRReferenceSpace}
      */
      getOffsetReferenceSpace(additionalOffset) {
        let newSpace = new XRReferenceSpace(
          this[PRIVATE4].type,
          this[PRIVATE4].transform,
          this[PRIVATE4].bounds
        );
        multiply5(newSpace[PRIVATE4].originOffset, this[PRIVATE4].originOffset, additionalOffset.matrix);
        return newSpace;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRSystem.js
var XRSystem_exports = {};
__export(XRSystem_exports, {
  PRIVATE: () => PRIVATE5,
  XRSessionModes: () => XRSessionModes,
  default: () => XRSystem
});
var PRIVATE5, XRSessionModes, DEFAULT_SESSION_OPTIONS, POLYFILL_REQUEST_SESSION_ERROR, XRSystem;
var init_XRSystem = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRSystem.js"() {
    init_EventTarget();
    init_XRReferenceSpace();
    PRIVATE5 = Symbol("@@webxr-polyfill/XR");
    XRSessionModes = ["inline", "immersive-vr", "immersive-ar"];
    DEFAULT_SESSION_OPTIONS = {
      "inline": {
        requiredFeatures: ["viewer"],
        optionalFeatures: []
      },
      "immersive-vr": {
        requiredFeatures: ["viewer", "local"],
        optionalFeatures: []
      },
      "immersive-ar": {
        requiredFeatures: ["viewer", "local"],
        optionalFeatures: []
      }
    };
    POLYFILL_REQUEST_SESSION_ERROR = `Polyfill Error: Must call navigator.xr.isSessionSupported() with any XRSessionMode
or navigator.xr.requestSession('inline') prior to requesting an immersive
session. This is a limitation specific to the WebXR Polyfill and does not apply
to native implementations of the API.`;
    XRSystem = class extends EventTarget2 {
      /**
       * Receives a promise of an XRDevice, so that the polyfill
       * can pass in some initial checks to asynchronously provide XRDevices
       * if content immediately requests `requestDevice()`.
       *
       * @param {Promise<XRDevice>} devicePromise
       */
      constructor(devicePromise) {
        super();
        this[PRIVATE5] = {
          device: null,
          devicePromise,
          immersiveSession: null,
          inlineSessions: /* @__PURE__ */ new Set()
        };
        devicePromise.then((device) => {
          this[PRIVATE5].device = device;
        });
      }
      /**
       * @param {XRSessionMode} mode
       * @return {Promise<boolean>}
       */
      async isSessionSupported(mode) {
        if (!this[PRIVATE5].device) {
          await this[PRIVATE5].devicePromise;
        }
        if (mode != "inline") {
          return Promise.resolve(this[PRIVATE5].device.isSessionSupported(mode));
        }
        return Promise.resolve(true);
      }
      /**
       * @param {XRSessionMode} mode
       * @param {XRSessionInit} options
       * @return {Promise<XRSession>}
       */
      async requestSession(mode, options) {
        if (!this[PRIVATE5].device) {
          if (mode != "inline") {
            throw new Error(POLYFILL_REQUEST_SESSION_ERROR);
          } else {
            await this[PRIVATE5].devicePromise;
          }
        }
        if (!XRSessionModes.includes(mode)) {
          throw new TypeError(
            `The provided value '${mode}' is not a valid enum value of type XRSessionMode`
          );
        }
        const defaultOptions = DEFAULT_SESSION_OPTIONS[mode];
        const requiredFeatures = defaultOptions.requiredFeatures.concat(
          options && options.requiredFeatures ? options.requiredFeatures : []
        );
        const optionalFeatures = defaultOptions.optionalFeatures.concat(
          options && options.optionalFeatures ? options.optionalFeatures : []
        );
        const enabledFeatures = /* @__PURE__ */ new Set();
        let requirementsFailed = false;
        for (let feature of requiredFeatures) {
          if (!this[PRIVATE5].device.isFeatureSupported(feature)) {
            console.error(`The required feature '${feature}' is not supported`);
            requirementsFailed = true;
          } else {
            enabledFeatures.add(feature);
          }
        }
        if (requirementsFailed) {
          throw new DOMException("Session does not support some required features", "NotSupportedError");
        }
        for (let feature of optionalFeatures) {
          if (!this[PRIVATE5].device.isFeatureSupported(feature)) {
            console.log(`The optional feature '${feature}' is not supported`);
          } else {
            enabledFeatures.add(feature);
          }
        }
        const sessionId = await this[PRIVATE5].device.requestSession(mode, enabledFeatures);
        const session = new XRSession(this[PRIVATE5].device, mode, sessionId);
        if (mode == "inline") {
          this[PRIVATE5].inlineSessions.add(session);
        } else {
          this[PRIVATE5].immersiveSession = session;
        }
        const onSessionEnd = () => {
          if (mode == "inline") {
            this[PRIVATE5].inlineSessions.delete(session);
          } else {
            this[PRIVATE5].immersiveSession = null;
          }
          session.removeEventListener("end", onSessionEnd);
        };
        session.addEventListener("end", onSessionEnd);
        return session;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/lib/global.js
var _global, global_default;
var init_global = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/lib/global.js"() {
    _global = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    global_default = _global;
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/lib/now.js
var now, now_default;
var init_now = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/lib/now.js"() {
    init_global();
    if ("performance" in global_default === false) {
      let startTime = Date.now();
      now = () => Date.now() - startTime;
    } else {
      now = () => performance.now();
    }
    now_default = now;
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRPose.js
var PRIVATE6, XRPose2;
var init_XRPose = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRPose.js"() {
    PRIVATE6 = Symbol("@@webxr-polyfill/XRPose");
    XRPose2 = class {
      /**
       * @param {XRRigidTransform} transform 
       * @param {boolean} emulatedPosition 
       */
      constructor(transform, emulatedPosition) {
        this[PRIVATE6] = {
          transform,
          emulatedPosition
        };
      }
      /**
       * @return {XRRigidTransform}
       */
      get transform() {
        return this[PRIVATE6].transform;
      }
      /**
       * @return {bool}
       */
      get emulatedPosition() {
        return this[PRIVATE6].emulatedPosition;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRViewerPose.js
var PRIVATE7, XRViewerPose;
var init_XRViewerPose = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRViewerPose.js"() {
    init_XRPose();
    PRIVATE7 = Symbol("@@webxr-polyfill/XRViewerPose");
    XRViewerPose = class extends XRPose2 {
      /**
       * @param {XRDevice} device
       */
      constructor(transform, views, emulatedPosition = false) {
        super(transform, emulatedPosition);
        this[PRIVATE7] = {
          views
        };
      }
      /**
       * @return {Array<XRView>}
       */
      get views() {
        return this[PRIVATE7].views;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRViewport.js
var PRIVATE8, XRViewport;
var init_XRViewport = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRViewport.js"() {
    PRIVATE8 = Symbol("@@webxr-polyfill/XRViewport");
    XRViewport = class {
      /**
       * Takes a proxy object that this viewport's XRView
       * updates and we serve here to match API.
       *
       * @param {Object} target
       */
      constructor(target) {
        this[PRIVATE8] = { target };
      }
      /**
       * @return {number}
       */
      get x() {
        return this[PRIVATE8].target.x;
      }
      /**
       * @return {number}
       */
      get y() {
        return this[PRIVATE8].target.y;
      }
      /**
       * @return {number}
       */
      get width() {
        return this[PRIVATE8].target.width;
      }
      /**
       * @return {number}
       */
      get height() {
        return this[PRIVATE8].target.height;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRView.js
var XREyes, PRIVATE9, XRView;
var init_XRView = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRView.js"() {
    init_XRViewport();
    init_XRRigidTransform();
    XREyes = ["left", "right", "none"];
    PRIVATE9 = Symbol("@@webxr-polyfill/XRView");
    XRView = class {
      /**
       * @param {XRDevice} device
       * @param {XREye} eye
       * @param {number} sessionId
       * @param {number} viewIndex
       */
      constructor(device, transform, eye, sessionId, viewIndex) {
        if (!XREyes.includes(eye)) {
          throw new Error(`XREye must be one of: ${XREyes}`);
        }
        const temp = /* @__PURE__ */ Object.create(null);
        const viewport = new XRViewport(temp);
        this[PRIVATE9] = {
          device,
          eye,
          viewport,
          temp,
          sessionId,
          transform,
          viewIndex
        };
      }
      /**
       * @return {XREye}
       */
      get eye() {
        return this[PRIVATE9].eye;
      }
      /**
       * @return {Float32Array}
       */
      get projectionMatrix() {
        return this[PRIVATE9].device.getProjectionMatrix(this.eye, this[PRIVATE9].viewIndex);
      }
      /**
       * @return {XRRigidTransform}
       */
      get transform() {
        return this[PRIVATE9].transform;
      }
      /**
       * NON-STANDARD
       *
       * `getViewport` is now exposed via XRWebGLLayer instead of XRView.
       * XRWebGLLayer delegates all the actual work to this function.
       *
       * @param {XRWebGLLayer} layer
       * @return {XRViewport?}
       */
      _getViewport(layer) {
        if (this[PRIVATE9].device.getViewport(
          this[PRIVATE9].sessionId,
          this.eye,
          layer,
          this[PRIVATE9].temp,
          this[PRIVATE9].viewIndex
        )) {
          return this[PRIVATE9].viewport;
        }
        return void 0;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRFrame.js
var PRIVATE11, NON_ACTIVE_MSG, NON_ANIMFRAME_MSG, NEXT_FRAME_ID, XRFrame;
var init_XRFrame = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRFrame.js"() {
    init_XRSession();
    init_XRViewerPose();
    init_XRView();
    PRIVATE11 = Symbol("@@webxr-polyfill/XRFrame");
    NON_ACTIVE_MSG = "XRFrame access outside the callback that produced it is invalid.";
    NON_ANIMFRAME_MSG = "getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.";
    NEXT_FRAME_ID = 0;
    XRFrame = class {
      /**
       * @param {XRDevice} device
       * @param {XRSession} session
       * @param {number} sessionId
       */
      constructor(device, session, sessionId) {
        this[PRIVATE11] = {
          id: ++NEXT_FRAME_ID,
          active: false,
          animationFrame: false,
          device,
          session,
          sessionId
        };
      }
      /**
       * @return {XRSession} session
       */
      get session() {
        return this[PRIVATE11].session;
      }
      /**
       * @param {XRReferenceSpace} referenceSpace
       * @return {XRViewerPose?}
       */
      getViewerPose(referenceSpace) {
        if (!this[PRIVATE11].animationFrame) {
          throw new DOMException(NON_ANIMFRAME_MSG, "InvalidStateError");
        }
        if (!this[PRIVATE11].active) {
          throw new DOMException(NON_ACTIVE_MSG, "InvalidStateError");
        }
        const device = this[PRIVATE11].device;
        const session = this[PRIVATE11].session;
        session[PRIVATE10].viewerSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
        referenceSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
        let viewerTransform = referenceSpace._getSpaceRelativeTransform(session[PRIVATE10].viewerSpace);
        const views = [];
        for (const viewSpace of session[PRIVATE10].viewSpaces) {
          viewSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
          let viewTransform = referenceSpace._getSpaceRelativeTransform(viewSpace);
          let view = new XRView(device, viewTransform, viewSpace.eye, this[PRIVATE11].sessionId, viewSpace.viewIndex);
          views.push(view);
        }
        let viewerPose = new XRViewerPose(
          viewerTransform,
          views,
          false
          /* TODO: emulatedPosition */
        );
        return viewerPose;
      }
      /**
       * @param {XRSpace} space
       * @param {XRSpace} baseSpace
       * @return {XRPose?} pose
       */
      getPose(space, baseSpace) {
        if (!this[PRIVATE11].active) {
          throw new DOMException(NON_ACTIVE_MSG, "InvalidStateError");
        }
        const device = this[PRIVATE11].device;
        if (space._specialType === "target-ray" || space._specialType === "grip") {
          return device.getInputPose(
            space._inputSource,
            baseSpace,
            space._specialType
          );
        } else {
          space._ensurePoseUpdated(device, this[PRIVATE11].id);
          baseSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
          let transform = baseSpace._getSpaceRelativeTransform(space);
          if (!transform) {
            return null;
          }
          return new XRPose(
            transform,
            false
            /* TODO: emulatedPosition */
          );
        }
        return null;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRRenderState.js
var PRIVATE12, XRRenderStateInit, XRRenderState;
var init_XRRenderState = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRRenderState.js"() {
    PRIVATE12 = Symbol("@@webxr-polyfill/XRRenderState");
    XRRenderStateInit = Object.freeze({
      depthNear: 0.1,
      depthFar: 1e3,
      inlineVerticalFieldOfView: null,
      baseLayer: null
    });
    XRRenderState = class {
      /**
       * @param {Object?} stateInit
       */
      constructor(stateInit = {}) {
        const config = Object.assign({}, XRRenderStateInit, stateInit);
        this[PRIVATE12] = { config };
      }
      /**
       * @return {number}
       */
      get depthNear() {
        return this[PRIVATE12].config.depthNear;
      }
      /**
       * @return {number}
       */
      get depthFar() {
        return this[PRIVATE12].config.depthFar;
      }
      /**
       * @return {number?}
       */
      get inlineVerticalFieldOfView() {
        return this[PRIVATE12].config.inlineVerticalFieldOfView;
      }
      /**
       * @return {XRWebGLLayer}
       */
      get baseLayer() {
        return this[PRIVATE12].config.baseLayer;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourceEvent.js
var PRIVATE13, XRInputSourceEvent;
var init_XRInputSourceEvent = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourceEvent.js"() {
    PRIVATE13 = Symbol("@@webxr-polyfill/XRInputSourceEvent");
    XRInputSourceEvent = class extends Event {
      /**
       * @param {string} type
       * @param {Object} eventInitDict
       */
      constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this[PRIVATE13] = {
          frame: eventInitDict.frame,
          inputSource: eventInitDict.inputSource
        };
        Object.setPrototypeOf(this, XRInputSourceEvent.prototype);
      }
      /**
       * @return {XRFrame}
       */
      get frame() {
        return this[PRIVATE13].frame;
      }
      /**
       * @return {XRInputSource}
       */
      get inputSource() {
        return this[PRIVATE13].inputSource;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRSessionEvent.js
var PRIVATE14, XRSessionEvent;
var init_XRSessionEvent = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRSessionEvent.js"() {
    PRIVATE14 = Symbol("@@webxr-polyfill/XRSessionEvent");
    XRSessionEvent = class extends Event {
      /**
       * @param {string} type
       * @param {Object} eventInitDict
       */
      constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this[PRIVATE14] = {
          session: eventInitDict.session
        };
        Object.setPrototypeOf(this, XRSessionEvent.prototype);
      }
      /**
       * @return {XRSession}
       */
      get session() {
        return this[PRIVATE14].session;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourcesChangeEvent.js
var PRIVATE15, XRInputSourcesChangeEvent;
var init_XRInputSourcesChangeEvent = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSourcesChangeEvent.js"() {
    PRIVATE15 = Symbol("@@webxr-polyfill/XRInputSourcesChangeEvent");
    XRInputSourcesChangeEvent = class extends Event {
      /**
       * @param {string} type
       * @param {Object} eventInitDict
       */
      constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this[PRIVATE15] = {
          session: eventInitDict.session,
          added: eventInitDict.added,
          removed: eventInitDict.removed
        };
        Object.setPrototypeOf(this, XRInputSourcesChangeEvent.prototype);
      }
      /**
       * @return {XRSession}
       */
      get session() {
        return this[PRIVATE15].session;
      }
      /**
       * @return {Array<XRInputSource>}
       */
      get added() {
        return this[PRIVATE15].added;
      }
      /**
       * @return {Array<XRInputSource>}
       */
      get removed() {
        return this[PRIVATE15].removed;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRSession.js
var PRIVATE10, XRViewSpace, XRSession2;
var init_XRSession = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRSession.js"() {
    init_EventTarget();
    init_now();
    init_XRFrame();
    init_XRReferenceSpace();
    init_XRRenderState();
    init_XRInputSourceEvent();
    init_XRSessionEvent();
    init_XRSpace();
    init_XRInputSourcesChangeEvent();
    PRIVATE10 = Symbol("@@webxr-polyfill/XRSession");
    XRViewSpace = class extends XRSpace {
      constructor(eye) {
        super(eye);
      }
      get eye() {
        return this._specialType;
      }
      /**
       * Called when this space's base pose needs to be updated
       * @param {XRDevice} device
       */
      _onPoseUpdate(device) {
        this._inverseBaseMatrix = device.getBaseViewMatrix(this._specialType);
      }
    };
    XRSession2 = class extends EventTarget2 {
      /**
       * @param {XRDevice} device
       * @param {XRSessionMode} mode
       * @param {number} id
       */
      constructor(device, mode, id) {
        super();
        let immersive = mode != "inline";
        let initialRenderState = new XRRenderState({
          inlineVerticalFieldOfView: immersive ? null : Math.PI * 0.5
        });
        const defaultViewSpaces = immersive ? [new XRViewSpace("left"), new XRViewSpace("right")] : [new XRViewSpace("none")];
        Object.freeze(defaultViewSpaces);
        this[PRIVATE10] = {
          device,
          mode,
          immersive,
          ended: false,
          suspended: false,
          frameCallbacks: [],
          currentFrameCallbacks: null,
          frameHandle: 0,
          deviceFrameHandle: null,
          id,
          activeRenderState: initialRenderState,
          pendingRenderState: null,
          viewerSpace: new XRReferenceSpace("viewer"),
          get viewSpaces() {
            return device.getViewSpaces(mode) || defaultViewSpaces;
          },
          currentInputSources: []
        };
        this[PRIVATE10].onDeviceFrame = () => {
          if (this[PRIVATE10].ended || this[PRIVATE10].suspended) {
            return;
          }
          this[PRIVATE10].deviceFrameHandle = null;
          this[PRIVATE10].startDeviceFrameLoop();
          if (this[PRIVATE10].pendingRenderState !== null) {
            this[PRIVATE10].activeRenderState = new XRRenderState(this[PRIVATE10].pendingRenderState);
            this[PRIVATE10].pendingRenderState = null;
            if (this[PRIVATE10].activeRenderState.baseLayer) {
              this[PRIVATE10].device.onBaseLayerSet(
                this[PRIVATE10].id,
                this[PRIVATE10].activeRenderState.baseLayer
              );
            }
          }
          if (this[PRIVATE10].activeRenderState.baseLayer === null) {
            return;
          }
          const frame = new XRFrame(device, this, this[PRIVATE10].id);
          const callbacks = this[PRIVATE10].currentFrameCallbacks = this[PRIVATE10].frameCallbacks;
          this[PRIVATE10].frameCallbacks = [];
          frame[PRIVATE11].active = true;
          frame[PRIVATE11].animationFrame = true;
          this[PRIVATE10].device.onFrameStart(this[PRIVATE10].id, this[PRIVATE10].activeRenderState);
          this._checkInputSourcesChange();
          const rightNow = now_default();
          for (let i = 0; i < callbacks.length; i++) {
            try {
              if (!callbacks[i].cancelled && typeof callbacks[i].callback === "function") {
                callbacks[i].callback(rightNow, frame);
              }
            } catch (err) {
              console.error(err);
            }
          }
          this[PRIVATE10].currentFrameCallbacks = null;
          frame[PRIVATE11].active = false;
          this[PRIVATE10].device.onFrameEnd(this[PRIVATE10].id);
        };
        this[PRIVATE10].startDeviceFrameLoop = () => {
          if (this[PRIVATE10].deviceFrameHandle === null) {
            this[PRIVATE10].deviceFrameHandle = this[PRIVATE10].device.requestAnimationFrame(
              this[PRIVATE10].onDeviceFrame
            );
          }
        };
        this[PRIVATE10].stopDeviceFrameLoop = () => {
          const handle = this[PRIVATE10].deviceFrameHandle;
          if (handle !== null) {
            this[PRIVATE10].device.cancelAnimationFrame(handle);
            this[PRIVATE10].deviceFrameHandle = null;
          }
        };
        this[PRIVATE10].onPresentationEnd = (sessionId) => {
          if (sessionId !== this[PRIVATE10].id) {
            this[PRIVATE10].suspended = false;
            this[PRIVATE10].startDeviceFrameLoop();
            this.dispatchEvent("focus", { session: this });
            return;
          }
          this[PRIVATE10].ended = true;
          this[PRIVATE10].stopDeviceFrameLoop();
          device.removeEventListener("@@webxr-polyfill/vr-present-end", this[PRIVATE10].onPresentationEnd);
          device.removeEventListener("@@webxr-polyfill/vr-present-start", this[PRIVATE10].onPresentationStart);
          device.removeEventListener("@@webxr-polyfill/input-select-start", this[PRIVATE10].onSelectStart);
          device.removeEventListener("@@webxr-polyfill/input-select-end", this[PRIVATE10].onSelectEnd);
          this.dispatchEvent("end", new XRSessionEvent("end", { session: this }));
        };
        device.addEventListener("@@webxr-polyfill/vr-present-end", this[PRIVATE10].onPresentationEnd);
        this[PRIVATE10].onPresentationStart = (sessionId) => {
          if (sessionId === this[PRIVATE10].id) {
            return;
          }
          this[PRIVATE10].suspended = true;
          this[PRIVATE10].stopDeviceFrameLoop();
          this.dispatchEvent("blur", { session: this });
        };
        device.addEventListener("@@webxr-polyfill/vr-present-start", this[PRIVATE10].onPresentationStart);
        this[PRIVATE10].onSelectStart = (evt) => {
          if (evt.sessionId !== this[PRIVATE10].id) {
            return;
          }
          this[PRIVATE10].dispatchInputSourceEvent("selectstart", evt.inputSource);
        };
        device.addEventListener("@@webxr-polyfill/input-select-start", this[PRIVATE10].onSelectStart);
        this[PRIVATE10].onSelectEnd = (evt) => {
          if (evt.sessionId !== this[PRIVATE10].id) {
            return;
          }
          this[PRIVATE10].dispatchInputSourceEvent("selectend", evt.inputSource);
          this[PRIVATE10].dispatchInputSourceEvent("select", evt.inputSource);
        };
        device.addEventListener("@@webxr-polyfill/input-select-end", this[PRIVATE10].onSelectEnd);
        this[PRIVATE10].onSqueezeStart = (evt) => {
          if (evt.sessionId !== this[PRIVATE10].id) {
            return;
          }
          this[PRIVATE10].dispatchInputSourceEvent("squeezestart", evt.inputSource);
        };
        device.addEventListener("@@webxr-polyfill/input-squeeze-start", this[PRIVATE10].onSqueezeStart);
        this[PRIVATE10].onSqueezeEnd = (evt) => {
          if (evt.sessionId !== this[PRIVATE10].id) {
            return;
          }
          this[PRIVATE10].dispatchInputSourceEvent("squeezeend", evt.inputSource);
          this[PRIVATE10].dispatchInputSourceEvent("squeeze", evt.inputSource);
        };
        device.addEventListener("@@webxr-polyfill/input-squeeze-end", this[PRIVATE10].onSqueezeEnd);
        this[PRIVATE10].dispatchInputSourceEvent = (type, inputSource) => {
          const frame = new XRFrame(device, this, this[PRIVATE10].id);
          const event = new XRInputSourceEvent(type, { frame, inputSource });
          frame[PRIVATE11].active = true;
          this.dispatchEvent(type, event);
          frame[PRIVATE11].active = false;
        };
        this[PRIVATE10].startDeviceFrameLoop();
        this.onblur = void 0;
        this.onfocus = void 0;
        this.onresetpose = void 0;
        this.onend = void 0;
        this.onselect = void 0;
        this.onselectstart = void 0;
        this.onselectend = void 0;
      }
      /**
       * @return {XRRenderState}
       */
      get renderState() {
        return this[PRIVATE10].activeRenderState;
      }
      /**
       * @return {XREnvironmentBlendMode}
       */
      get environmentBlendMode() {
        return this[PRIVATE10].device.environmentBlendMode || "opaque";
      }
      /**
       * @param {string} type
       * @return {XRReferenceSpace}
       */
      async requestReferenceSpace(type) {
        if (this[PRIVATE10].ended) {
          return;
        }
        if (!XRReferenceSpaceTypes.includes(type)) {
          throw new TypeError(`XRReferenceSpaceType must be one of ${XRReferenceSpaceTypes}`);
        }
        if (!this[PRIVATE10].device.doesSessionSupportReferenceSpace(this[PRIVATE10].id, type)) {
          throw new DOMException(`The ${type} reference space is not supported by this session.`, "NotSupportedError");
        }
        if (type === "viewer") {
          return this[PRIVATE10].viewerSpace;
        }
        let transform = await this[PRIVATE10].device.requestFrameOfReferenceTransform(type);
        if (type === "bounded-floor") {
          if (!transform) {
            throw new DOMException(`${type} XRReferenceSpace not supported by this device.`, "NotSupportedError");
          }
          let bounds = this[PRIVATE10].device.requestStageBounds();
          if (!bounds) {
            throw new DOMException(`${type} XRReferenceSpace not supported by this device.`, "NotSupportedError");
          }
          throw new DOMException(`The WebXR polyfill does not support the ${type} reference space yet.`, "NotSupportedError");
        }
        return new XRReferenceSpace(type, transform);
      }
      /**
       * @param {Function} callback
       * @return {number}
       */
      requestAnimationFrame(callback) {
        if (this[PRIVATE10].ended) {
          return;
        }
        const handle = ++this[PRIVATE10].frameHandle;
        this[PRIVATE10].frameCallbacks.push({
          handle,
          callback,
          cancelled: false
        });
        return handle;
      }
      /**
       * @param {number} handle
       */
      cancelAnimationFrame(handle) {
        let callbacks = this[PRIVATE10].frameCallbacks;
        let index = callbacks.findIndex((d) => d && d.handle === handle);
        if (index > -1) {
          callbacks[index].cancelled = true;
          callbacks.splice(index, 1);
        }
        callbacks = this[PRIVATE10].currentFrameCallbacks;
        if (callbacks) {
          index = callbacks.findIndex((d) => d && d.handle === handle);
          if (index > -1) {
            callbacks[index].cancelled = true;
          }
        }
      }
      /**
       * @return {Array<XRInputSource>} input sources
       */
      get inputSources() {
        return this[PRIVATE10].device.getInputSources();
      }
      /**
       * @return {Promise<void>}
       */
      async end() {
        if (this[PRIVATE10].ended) {
          return;
        }
        if (this[PRIVATE10].immersive) {
          this[PRIVATE10].ended = true;
          this[PRIVATE10].device.removeEventListener(
            "@@webxr-polyfill/vr-present-start",
            this[PRIVATE10].onPresentationStart
          );
          this[PRIVATE10].device.removeEventListener(
            "@@webxr-polyfill/vr-present-end",
            this[PRIVATE10].onPresentationEnd
          );
          this[PRIVATE10].device.removeEventListener(
            "@@webxr-polyfill/input-select-start",
            this[PRIVATE10].onSelectStart
          );
          this[PRIVATE10].device.removeEventListener(
            "@@webxr-polyfill/input-select-end",
            this[PRIVATE10].onSelectEnd
          );
          this.dispatchEvent("end", new XRSessionEvent("end", { session: this }));
        }
        this[PRIVATE10].stopDeviceFrameLoop();
        return this[PRIVATE10].device.endSession(this[PRIVATE10].id);
      }
      /**
       * Queues an update to the active render state to be applied on the next
       * frame. Unset fields of newState will not be changed.
       * 
       * @param {XRRenderStateInit?} newState 
       */
      updateRenderState(newState) {
        if (this[PRIVATE10].ended) {
          const message = "Can't call updateRenderState on an XRSession that has already ended.";
          throw new Error(message);
        }
        if (newState.baseLayer && newState.baseLayer._session !== this) {
          const message = "Called updateRenderState with a base layer that was created by a different session.";
          throw new Error(message);
        }
        const fovSet = newState.inlineVerticalFieldOfView !== null && newState.inlineVerticalFieldOfView !== void 0;
        if (fovSet) {
          if (this[PRIVATE10].immersive) {
            const message = "inlineVerticalFieldOfView must not be set for an XRRenderState passed to updateRenderState for an immersive session.";
            throw new Error(message);
          } else {
            newState.inlineVerticalFieldOfView = Math.min(
              3.13,
              Math.max(0.01, newState.inlineVerticalFieldOfView)
            );
          }
        }
        if (this[PRIVATE10].pendingRenderState === null) {
          const activeRenderState = this[PRIVATE10].activeRenderState;
          this[PRIVATE10].pendingRenderState = {
            depthNear: activeRenderState.depthNear,
            depthFar: activeRenderState.depthFar,
            inlineVerticalFieldOfView: activeRenderState.inlineVerticalFieldOfView,
            baseLayer: activeRenderState.baseLayer
          };
        }
        Object.assign(this[PRIVATE10].pendingRenderState, newState);
      }
      /**
       * Compares the inputSources with the ones in the previous frame.
       * Fires imputsourceschange event if any added or removed
       * inputSource is found.
       */
      _checkInputSourcesChange() {
        const added = [];
        const removed = [];
        const newInputSources = this.inputSources;
        const oldInputSources = this[PRIVATE10].currentInputSources;
        for (const newInputSource of newInputSources) {
          if (!oldInputSources.includes(newInputSource)) {
            added.push(newInputSource);
          }
        }
        for (const oldInputSource of oldInputSources) {
          if (!newInputSources.includes(oldInputSource)) {
            removed.push(oldInputSource);
          }
        }
        if (added.length > 0 || removed.length > 0) {
          this.dispatchEvent("inputsourceschange", new XRInputSourcesChangeEvent("inputsourceschange", {
            session: this,
            added,
            removed
          }));
        }
        this[PRIVATE10].currentInputSources.length = 0;
        for (const newInputSource of newInputSources) {
          this[PRIVATE10].currentInputSources.push(newInputSource);
        }
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSource.js
var PRIVATE16, XRInputSource;
var init_XRInputSource = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRInputSource.js"() {
    init_XRSpace();
    PRIVATE16 = Symbol("@@webxr-polyfill/XRInputSource");
    XRInputSource = class {
      /**
       * @param {GamepadXRInputSource} impl 
       */
      constructor(impl) {
        this[PRIVATE16] = {
          impl,
          gripSpace: new XRSpace("grip", this),
          targetRaySpace: new XRSpace("target-ray", this)
        };
      }
      /**
       * @return {XRHandedness}
       */
      get handedness() {
        return this[PRIVATE16].impl.handedness;
      }
      /**
       * @return {XRTargetRayMode}
       */
      get targetRayMode() {
        return this[PRIVATE16].impl.targetRayMode;
      }
      /**
       * @return {XRSpace}
       */
      get gripSpace() {
        let mode = this[PRIVATE16].impl.targetRayMode;
        if (mode === "gaze" || mode === "screen") {
          return null;
        }
        return this[PRIVATE16].gripSpace;
      }
      /**
       * @return {XRSpace}
       */
      get targetRaySpace() {
        return this[PRIVATE16].targetRaySpace;
      }
      /**
       * @return {Array<String>}
       */
      get profiles() {
        return this[PRIVATE16].impl.profiles;
      }
      /**
       * @return {Gamepad}
       */
      get gamepad() {
        return this[PRIVATE16].impl.gamepad;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/constants.js
var POLYFILLED_XR_COMPATIBLE, XR_COMPATIBLE;
var init_constants = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/constants.js"() {
    POLYFILLED_XR_COMPATIBLE = Symbol("@@webxr-polyfill/polyfilled-xr-compatible");
    XR_COMPATIBLE = Symbol("@@webxr-polyfill/xr-compatible");
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRWebGLLayer.js
var XRWebGLLayer_exports = {};
__export(XRWebGLLayer_exports, {
  PRIVATE: () => PRIVATE17,
  XRWebGLLayerInit: () => XRWebGLLayerInit,
  default: () => XRWebGLLayer
});
var PRIVATE17, XRWebGLLayerInit, XRWebGLLayer;
var init_XRWebGLLayer = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRWebGLLayer.js"() {
    init_XRSession();
    init_constants();
    PRIVATE17 = Symbol("@@webxr-polyfill/XRWebGLLayer");
    XRWebGLLayerInit = Object.freeze({
      antialias: true,
      depth: true,
      stencil: false,
      alpha: true,
      multiview: false,
      ignoreDepthValues: false,
      framebufferScaleFactor: 1
    });
    XRWebGLLayer = class {
      /**
       * @param {XRSession} session 
       * @param {XRWebGLRenderingContext} context 
       * @param {Object?} layerInit 
       */
      constructor(session, context, layerInit = {}) {
        const config = Object.assign({}, XRWebGLLayerInit, layerInit);
        if (!(session instanceof XRSession2)) {
          throw new Error("session must be a XRSession");
        }
        if (session.ended) {
          throw new Error(`InvalidStateError`);
        }
        if (context[POLYFILLED_XR_COMPATIBLE]) {
          if (context[XR_COMPATIBLE] !== true) {
            throw new Error(`InvalidStateError`);
          }
        }
        this[PRIVATE17] = {
          context,
          config,
          session
        };
      }
      /**
       * @return {WebGLRenderingContext}
       */
      get context() {
        return this[PRIVATE17].context;
      }
      /**
       * @return {boolean}
       */
      get antialias() {
        return this[PRIVATE17].config.antialias;
      }
      /**
       * The polyfill will always ignore depth values.
       *
       * @return {boolean}
       */
      get ignoreDepthValues() {
        return true;
      }
      /**
       * @return {WebGLFramebuffer}
       */
      get framebuffer() {
        return null;
      }
      /**
       * @return {number}
       */
      get framebufferWidth() {
        return this[PRIVATE17].context.drawingBufferWidth;
      }
      /**
       * @return {number}
       */
      get framebufferHeight() {
        return this[PRIVATE17].context.drawingBufferHeight;
      }
      /**
       * @return {XRSession}
       */
      get _session() {
        return this[PRIVATE17].session;
      }
      /**
       * @TODO No mention in spec on not reusing the XRViewport on every frame.
       * 
       * @TODO In the future maybe all this logic should be handled here instead of
       * delegated to the XRView?
       *
       * @param {XRView} view
       * @return {XRViewport?}
       */
      getViewport(view) {
        return view._getViewport(this);
      }
      /**
       * Gets the scale factor to be requested if you want to match the device
       * resolution at the center of the user's vision. The polyfill will always
       * report 1.0.
       * 
       * @param {XRSession} session 
       * @return {number}
       */
      static getNativeFramebufferScaleFactor(session) {
        if (!session) {
          throw new TypeError("getNativeFramebufferScaleFactor must be passed a session.");
        }
        if (session[PRIVATE10].ended) {
          return 0;
        }
        return 1;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpaceEvent.js
var PRIVATE18, XRReferenceSpaceEvent;
var init_XRReferenceSpaceEvent = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/XRReferenceSpaceEvent.js"() {
    PRIVATE18 = Symbol("@@webxr-polyfill/XRReferenceSpaceEvent");
    XRReferenceSpaceEvent = class extends Event {
      /**
       * @param {string} type
       * @param {Object} eventInitDict
       */
      constructor(type, eventInitDict) {
        super(type, eventInitDict);
        this[PRIVATE18] = {
          referenceSpace: eventInitDict.referenceSpace,
          transform: eventInitDict.transform || null
        };
        Object.setPrototypeOf(this, XRReferenceSpaceEvent.prototype);
      }
      /**
       * @return {XRFrame}
       */
      get referenceSpace() {
        return this[PRIVATE18].referenceSpace;
      }
      /**
       * @return {XRInputSource}
       */
      get transform() {
        return this[PRIVATE18].transform;
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/api/index.js
var api_exports = {};
__export(api_exports, {
  default: () => api_default
});
var api_default;
var init_api = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/api/index.js"() {
    init_XRSystem();
    init_XRSession();
    init_XRSessionEvent();
    init_XRFrame();
    init_XRView();
    init_XRViewport();
    init_XRViewerPose();
    init_XRInputSource();
    init_XRInputSourceEvent();
    init_XRInputSourcesChangeEvent();
    init_XRWebGLLayer();
    init_XRSpace();
    init_XRReferenceSpace();
    init_XRReferenceSpaceEvent();
    init_XRRenderState();
    init_XRRigidTransform();
    init_XRPose();
    api_default = {
      XRSystem,
      XRSession: XRSession2,
      XRSessionEvent,
      XRFrame,
      XRView,
      XRViewport,
      XRViewerPose,
      XRWebGLLayer,
      XRSpace,
      XRReferenceSpace,
      XRReferenceSpaceEvent,
      XRInputSource,
      XRInputSourceEvent,
      XRInputSourcesChangeEvent,
      XRRenderState,
      XRRigidTransform: XRRigidTransform2,
      XRPose: XRPose2
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/polyfill-globals.js
var polyfillMakeXRCompatible, polyfillGetContext;
var init_polyfill_globals = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/polyfill-globals.js"() {
    init_constants();
    polyfillMakeXRCompatible = (Context) => {
      if (typeof Context.prototype.makeXRCompatible === "function") {
      }
      Context.prototype.makeXRCompatible = function() {
        this[XR_COMPATIBLE] = true;
        return Promise.resolve();
      };
      return true;
    };
    polyfillGetContext = (Canvas) => {
      const getContext = Canvas.prototype.getContext;
      Canvas.prototype.getContext = function(contextType, glAttribs) {
        const ctx = getContext.call(this, contextType, glAttribs);
        if (ctx) {
          ctx[POLYFILLED_XR_COMPATIBLE] = true;
          if (glAttribs && "xrCompatible" in glAttribs) {
            ctx[XR_COMPATIBLE] = glAttribs.xrCompatible;
          }
        }
        return ctx;
      };
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/utils.js
var isImageBitmapSupported, isMobile, applyCanvasStylesForMinimalRendering;
var init_utils = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/utils.js"() {
    isImageBitmapSupported = (global2) => !!(global2.ImageBitmapRenderingContext && global2.createImageBitmap);
    isMobile = (global2) => {
      var check = false;
      (function(a) {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
          check = true;
      })(global2.navigator.userAgent || global2.navigator.vendor || global2.opera);
      return check;
    };
    applyCanvasStylesForMinimalRendering = (canvas2) => {
      canvas2.style.display = "block";
      canvas2.style.position = "absolute";
      canvas2.style.width = canvas2.style.height = "1px";
      canvas2.style.top = canvas2.style.left = "0px";
    };
  }
});

// ../node_modules/cardboard-vr-display/dist/cardboard-vr-display.js
var require_cardboard_vr_display = __commonJS({
  "../node_modules/cardboard-vr-display/dist/cardboard-vr-display.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.CardboardVRDisplay = factory();
    })(exports, function() {
      "use strict";
      var asyncGenerator = function() {
        function AwaitValue(value) {
          this.value = value;
        }
        function AsyncGenerator(gen) {
          var front, back;
          function send(key, arg) {
            return new Promise(function(resolve, reject) {
              var request = {
                key,
                arg,
                resolve,
                reject,
                next: null
              };
              if (back) {
                back = back.next = request;
              } else {
                front = back = request;
                resume(key, arg);
              }
            });
          }
          function resume(key, arg) {
            try {
              var result = gen[key](arg);
              var value = result.value;
              if (value instanceof AwaitValue) {
                Promise.resolve(value.value).then(function(arg2) {
                  resume("next", arg2);
                }, function(arg2) {
                  resume("throw", arg2);
                });
              } else {
                settle(result.done ? "return" : "normal", result.value);
              }
            } catch (err) {
              settle("throw", err);
            }
          }
          function settle(type, value) {
            switch (type) {
              case "return":
                front.resolve({
                  value,
                  done: true
                });
                break;
              case "throw":
                front.reject(value);
                break;
              default:
                front.resolve({
                  value,
                  done: false
                });
                break;
            }
            front = front.next;
            if (front) {
              resume(front.key, front.arg);
            } else {
              back = null;
            }
          }
          this._invoke = send;
          if (typeof gen.return !== "function") {
            this.return = void 0;
          }
        }
        if (typeof Symbol === "function" && Symbol.asyncIterator) {
          AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
            return this;
          };
        }
        AsyncGenerator.prototype.next = function(arg) {
          return this._invoke("next", arg);
        };
        AsyncGenerator.prototype.throw = function(arg) {
          return this._invoke("throw", arg);
        };
        AsyncGenerator.prototype.return = function(arg) {
          return this._invoke("return", arg);
        };
        return {
          wrap: function(fn) {
            return function() {
              return new AsyncGenerator(fn.apply(this, arguments));
            };
          },
          await: function(value) {
            return new AwaitValue(value);
          }
        };
      }();
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var MIN_TIMESTEP = 1e-3;
      var MAX_TIMESTEP = 1;
      var dataUri = function dataUri2(mimeType, svg) {
        return "data:" + mimeType + "," + encodeURIComponent(svg);
      };
      var lerp6 = function lerp7(a, b, t) {
        return a + (b - a) * t;
      };
      var isIOS = function() {
        var isIOS2 = /iPad|iPhone|iPod/.test(navigator.platform);
        return function() {
          return isIOS2;
        };
      }();
      var isWebViewAndroid = function() {
        var isWebViewAndroid2 = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
        return function() {
          return isWebViewAndroid2;
        };
      }();
      var isSafari = function() {
        var isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        return function() {
          return isSafari2;
        };
      }();
      var isFirefoxAndroid = function() {
        var isFirefoxAndroid2 = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
        return function() {
          return isFirefoxAndroid2;
        };
      }();
      var getChromeVersion = function() {
        var match = navigator.userAgent.match(/.*Chrome\/([0-9]+)/);
        var value = match ? parseInt(match[1], 10) : null;
        return function() {
          return value;
        };
      }();
      var isSafariWithoutDeviceMotion = function() {
        var value = false;
        value = isIOS() && isSafari() && navigator.userAgent.indexOf("13_4") !== -1;
        return function() {
          return value;
        };
      }();
      var isChromeWithoutDeviceMotion = function() {
        var value = false;
        if (getChromeVersion() === 65) {
          var match = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
          if (match) {
            var _match$1$split = match[1].split("."), _match$1$split2 = slicedToArray(_match$1$split, 4), major = _match$1$split2[0], minor = _match$1$split2[1], branch = _match$1$split2[2], build = _match$1$split2[3];
            value = parseInt(branch, 10) === 3325 && parseInt(build, 10) < 148;
          }
        }
        return function() {
          return value;
        };
      }();
      var isR7 = function() {
        var isR72 = navigator.userAgent.indexOf("R7 Build") !== -1;
        return function() {
          return isR72;
        };
      }();
      var isLandscapeMode = function isLandscapeMode2() {
        var rtn = window.orientation == 90 || window.orientation == -90;
        return isR7() ? !rtn : rtn;
      };
      var isTimestampDeltaValid = function isTimestampDeltaValid2(timestampDeltaS) {
        if (isNaN(timestampDeltaS)) {
          return false;
        }
        if (timestampDeltaS <= MIN_TIMESTEP) {
          return false;
        }
        if (timestampDeltaS > MAX_TIMESTEP) {
          return false;
        }
        return true;
      };
      var getScreenWidth = function getScreenWidth2() {
        return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
      };
      var getScreenHeight = function getScreenHeight2() {
        return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
      };
      var requestFullscreen = function requestFullscreen2(element) {
        if (isWebViewAndroid()) {
          return false;
        }
        if (element.requestFullscreen) {
          element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
          element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
          element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
          element.msRequestFullscreen();
        } else {
          return false;
        }
        return true;
      };
      var exitFullscreen = function exitFullscreen2() {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        } else {
          return false;
        }
        return true;
      };
      var getFullscreenElement = function getFullscreenElement2() {
        return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
      };
      var linkProgram = function linkProgram2(gl, vertexSource, fragmentSource, attribLocationMap) {
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexSource);
        gl.compileShader(vertexShader);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentSource);
        gl.compileShader(fragmentShader);
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        for (var attribName in attribLocationMap) {
          gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
        }
        gl.linkProgram(program);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        return program;
      };
      var getProgramUniforms = function getProgramUniforms2(gl, program) {
        var uniforms = {};
        var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        var uniformName = "";
        for (var i = 0; i < uniformCount; i++) {
          var uniformInfo = gl.getActiveUniform(program, i);
          uniformName = uniformInfo.name.replace("[0]", "");
          uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
        }
        return uniforms;
      };
      var orthoMatrix = function orthoMatrix2(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
      };
      var isMobile2 = function isMobile3() {
        var check = false;
        (function(a) {
          if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
            check = true;
        })(navigator.userAgent || navigator.vendor || window.opera);
        return check;
      };
      var extend = function extend2(dest, src) {
        for (var key in src) {
          if (src.hasOwnProperty(key)) {
            dest[key] = src[key];
          }
        }
        return dest;
      };
      var safariCssSizeWorkaround = function safariCssSizeWorkaround2(canvas2) {
        if (isIOS()) {
          var width = canvas2.style.width;
          var height = canvas2.style.height;
          canvas2.style.width = parseInt(width) + 1 + "px";
          canvas2.style.height = parseInt(height) + "px";
          setTimeout(function() {
            canvas2.style.width = width;
            canvas2.style.height = height;
          }, 100);
        }
        window.canvas = canvas2;
      };
      var frameDataFromPose = function() {
        var piOver180 = Math.PI / 180;
        var rad45 = Math.PI * 0.25;
        function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
          var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45), downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45), leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45), rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
          out[0] = xScale;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = yScale;
          out[6] = 0;
          out[7] = 0;
          out[8] = -((leftTan - rightTan) * xScale * 0.5);
          out[9] = (upTan - downTan) * yScale * 0.5;
          out[10] = far / (near - far);
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = far * near / (near - far);
          out[15] = 0;
          return out;
        }
        function mat4_fromRotationTranslation(out, q, v) {
          var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
          out[0] = 1 - (yy + zz);
          out[1] = xy + wz;
          out[2] = xz - wy;
          out[3] = 0;
          out[4] = xy - wz;
          out[5] = 1 - (xx + zz);
          out[6] = yz + wx;
          out[7] = 0;
          out[8] = xz + wy;
          out[9] = yz - wx;
          out[10] = 1 - (xx + yy);
          out[11] = 0;
          out[12] = v[0];
          out[13] = v[1];
          out[14] = v[2];
          out[15] = 1;
          return out;
        }
        function mat4_translate(out, a, v) {
          var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
          if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          } else {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            out[0] = a00;
            out[1] = a01;
            out[2] = a02;
            out[3] = a03;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a20;
            out[9] = a21;
            out[10] = a22;
            out[11] = a23;
            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
          }
          return out;
        }
        function mat4_invert(out, a) {
          var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1 / det;
          out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        }
        var defaultOrientation = new Float32Array([0, 0, 0, 1]);
        var defaultPosition = new Float32Array([0, 0, 0]);
        function updateEyeMatrices(projection, view, pose, fov, offset2, vrDisplay) {
          mat4_perspectiveFromFieldOfView(projection, fov || null, vrDisplay.depthNear, vrDisplay.depthFar);
          var orientation = pose.orientation || defaultOrientation;
          var position = pose.position || defaultPosition;
          mat4_fromRotationTranslation(view, orientation, position);
          if (offset2)
            mat4_translate(view, view, offset2);
          mat4_invert(view, view);
        }
        return function(frameData, pose, vrDisplay) {
          if (!frameData || !pose)
            return false;
          frameData.pose = pose;
          frameData.timestamp = pose.timestamp;
          updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay._getFieldOfView("left"), vrDisplay._getEyeOffset("left"), vrDisplay);
          updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay._getFieldOfView("right"), vrDisplay._getEyeOffset("right"), vrDisplay);
          return true;
        };
      }();
      var isInsideCrossOriginIFrame = function isInsideCrossOriginIFrame2() {
        var isFramed = window.self !== window.top;
        var refOrigin = getOriginFromUrl(document.referrer);
        var thisOrigin = getOriginFromUrl(window.location.href);
        return isFramed && refOrigin !== thisOrigin;
      };
      var getOriginFromUrl = function getOriginFromUrl2(url) {
        var domainIdx;
        var protoSepIdx = url.indexOf("://");
        if (protoSepIdx !== -1) {
          domainIdx = protoSepIdx + 3;
        } else {
          domainIdx = 0;
        }
        var domainEndIdx = url.indexOf("/", domainIdx);
        if (domainEndIdx === -1) {
          domainEndIdx = url.length;
        }
        return url.substring(0, domainEndIdx);
      };
      var getQuaternionAngle = function getQuaternionAngle2(quat) {
        if (quat.w > 1) {
          console.warn("getQuaternionAngle: w > 1");
          return 0;
        }
        var angle3 = 2 * Math.acos(quat.w);
        return angle3;
      };
      var warnOnce = function() {
        var observedWarnings = {};
        return function(key, message) {
          if (observedWarnings[key] === void 0) {
            console.warn("webvr-polyfill: " + message);
            observedWarnings[key] = true;
          }
        };
      }();
      var deprecateWarning = function deprecateWarning2(deprecated, suggested) {
        var alternative = suggested ? "Please use " + suggested + " instead." : "";
        warnOnce(deprecated, deprecated + " has been deprecated. This may not work on native WebVR displays. " + alternative);
      };
      function WGLUPreserveGLState(gl, bindings, callback) {
        if (!bindings) {
          callback(gl);
          return;
        }
        var boundValues = [];
        var activeTexture = null;
        for (var i = 0; i < bindings.length; ++i) {
          var binding = bindings[i];
          switch (binding) {
            case gl.TEXTURE_BINDING_2D:
            case gl.TEXTURE_BINDING_CUBE_MAP:
              var textureUnit = bindings[++i];
              if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
                console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
                boundValues.push(null, null);
                break;
              }
              if (!activeTexture) {
                activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
              }
              gl.activeTexture(textureUnit);
              boundValues.push(gl.getParameter(binding), null);
              break;
            case gl.ACTIVE_TEXTURE:
              activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
              boundValues.push(null);
              break;
            default:
              boundValues.push(gl.getParameter(binding));
              break;
          }
        }
        callback(gl);
        for (var i = 0; i < bindings.length; ++i) {
          var binding = bindings[i];
          var boundValue = boundValues[i];
          switch (binding) {
            case gl.ACTIVE_TEXTURE:
              break;
            case gl.ARRAY_BUFFER_BINDING:
              gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
              break;
            case gl.COLOR_CLEAR_VALUE:
              gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
              break;
            case gl.COLOR_WRITEMASK:
              gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
              break;
            case gl.CURRENT_PROGRAM:
              gl.useProgram(boundValue);
              break;
            case gl.ELEMENT_ARRAY_BUFFER_BINDING:
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
              break;
            case gl.FRAMEBUFFER_BINDING:
              gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
              break;
            case gl.RENDERBUFFER_BINDING:
              gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
              break;
            case gl.TEXTURE_BINDING_2D:
              var textureUnit = bindings[++i];
              if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                break;
              gl.activeTexture(textureUnit);
              gl.bindTexture(gl.TEXTURE_2D, boundValue);
              break;
            case gl.TEXTURE_BINDING_CUBE_MAP:
              var textureUnit = bindings[++i];
              if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                break;
              gl.activeTexture(textureUnit);
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
              break;
            case gl.VIEWPORT:
              gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
              break;
            case gl.BLEND:
            case gl.CULL_FACE:
            case gl.DEPTH_TEST:
            case gl.SCISSOR_TEST:
            case gl.STENCIL_TEST:
              if (boundValue) {
                gl.enable(binding);
              } else {
                gl.disable(binding);
              }
              break;
            default:
              console.log("No GL restore behavior for 0x" + binding.toString(16));
              break;
          }
          if (activeTexture) {
            gl.activeTexture(activeTexture);
          }
        }
      }
      var glPreserveState = WGLUPreserveGLState;
      var distortionVS = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join("\n");
      var distortionFS = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join("\n");
      function CardboardDistorter(gl, cardboardUI, bufferScale, dirtySubmitFrameBindings) {
        this.gl = gl;
        this.cardboardUI = cardboardUI;
        this.bufferScale = bufferScale;
        this.dirtySubmitFrameBindings = dirtySubmitFrameBindings;
        this.ctxAttribs = gl.getContextAttributes();
        this.instanceExt = gl.getExtension("ANGLE_instanced_arrays");
        this.meshWidth = 20;
        this.meshHeight = 20;
        this.bufferWidth = gl.drawingBufferWidth;
        this.bufferHeight = gl.drawingBufferHeight;
        this.realBindFramebuffer = gl.bindFramebuffer;
        this.realEnable = gl.enable;
        this.realDisable = gl.disable;
        this.realColorMask = gl.colorMask;
        this.realClearColor = gl.clearColor;
        this.realViewport = gl.viewport;
        if (!isIOS()) {
          this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "width");
          this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "height");
        }
        this.isPatched = false;
        this.lastBoundFramebuffer = null;
        this.cullFace = false;
        this.depthTest = false;
        this.blend = false;
        this.scissorTest = false;
        this.stencilTest = false;
        this.viewport = [0, 0, 0, 0];
        this.colorMask = [true, true, true, true];
        this.clearColor = [0, 0, 0, 0];
        this.attribs = {
          position: 0,
          texCoord: 1
        };
        this.program = linkProgram(gl, distortionVS, distortionFS, this.attribs);
        this.uniforms = getProgramUniforms(gl, this.program);
        this.viewportOffsetScale = new Float32Array(8);
        this.setTextureBounds();
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.indexCount = 0;
        this.renderTarget = gl.createTexture();
        this.framebuffer = gl.createFramebuffer();
        this.depthStencilBuffer = null;
        this.depthBuffer = null;
        this.stencilBuffer = null;
        if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
          this.depthStencilBuffer = gl.createRenderbuffer();
        } else if (this.ctxAttribs.depth) {
          this.depthBuffer = gl.createRenderbuffer();
        } else if (this.ctxAttribs.stencil) {
          this.stencilBuffer = gl.createRenderbuffer();
        }
        this.patch();
        this.onResize();
      }
      CardboardDistorter.prototype.destroy = function() {
        var gl = this.gl;
        this.unpatch();
        gl.deleteProgram(this.program);
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);
        gl.deleteTexture(this.renderTarget);
        gl.deleteFramebuffer(this.framebuffer);
        if (this.depthStencilBuffer) {
          gl.deleteRenderbuffer(this.depthStencilBuffer);
        }
        if (this.depthBuffer) {
          gl.deleteRenderbuffer(this.depthBuffer);
        }
        if (this.stencilBuffer) {
          gl.deleteRenderbuffer(this.stencilBuffer);
        }
        if (this.cardboardUI) {
          this.cardboardUI.destroy();
        }
      };
      CardboardDistorter.prototype.onResize = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.RENDERBUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0];
        glPreserveState(gl, glState, function(gl2) {
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
          if (self2.scissorTest) {
            self2.realDisable.call(gl2, gl2.SCISSOR_TEST);
          }
          self2.realColorMask.call(gl2, true, true, true, true);
          self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
          self2.realClearColor.call(gl2, 0, 0, 0, 1);
          gl2.clear(gl2.COLOR_BUFFER_BIT);
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.framebuffer);
          gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget);
          gl2.texImage2D(gl2.TEXTURE_2D, 0, self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB, self2.bufferWidth, self2.bufferHeight, 0, self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB, gl2.UNSIGNED_BYTE, null);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
          gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, self2.renderTarget, 0);
          if (self2.ctxAttribs.depth && self2.ctxAttribs.stencil) {
            gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthStencilBuffer);
            gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_STENCIL, self2.bufferWidth, self2.bufferHeight);
            gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_STENCIL_ATTACHMENT, gl2.RENDERBUFFER, self2.depthStencilBuffer);
          } else if (self2.ctxAttribs.depth) {
            gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthBuffer);
            gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_COMPONENT16, self2.bufferWidth, self2.bufferHeight);
            gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_ATTACHMENT, gl2.RENDERBUFFER, self2.depthBuffer);
          } else if (self2.ctxAttribs.stencil) {
            gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.stencilBuffer);
            gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.STENCIL_INDEX8, self2.bufferWidth, self2.bufferHeight);
            gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.STENCIL_ATTACHMENT, gl2.RENDERBUFFER, self2.stencilBuffer);
          }
          if (!gl2.checkFramebufferStatus(gl2.FRAMEBUFFER) === gl2.FRAMEBUFFER_COMPLETE) {
            console.error("Framebuffer incomplete!");
          }
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer);
          if (self2.scissorTest) {
            self2.realEnable.call(gl2, gl2.SCISSOR_TEST);
          }
          self2.realColorMask.apply(gl2, self2.colorMask);
          self2.realViewport.apply(gl2, self2.viewport);
          self2.realClearColor.apply(gl2, self2.clearColor);
        });
        if (this.cardboardUI) {
          this.cardboardUI.onResize();
        }
      };
      CardboardDistorter.prototype.patch = function() {
        if (this.isPatched) {
          return;
        }
        var self2 = this;
        var canvas2 = this.gl.canvas;
        var gl = this.gl;
        if (!isIOS()) {
          canvas2.width = getScreenWidth() * this.bufferScale;
          canvas2.height = getScreenHeight() * this.bufferScale;
          Object.defineProperty(canvas2, "width", {
            configurable: true,
            enumerable: true,
            get: function get() {
              return self2.bufferWidth;
            },
            set: function set7(value) {
              self2.bufferWidth = value;
              self2.realCanvasWidth.set.call(canvas2, value);
              self2.onResize();
            }
          });
          Object.defineProperty(canvas2, "height", {
            configurable: true,
            enumerable: true,
            get: function get() {
              return self2.bufferHeight;
            },
            set: function set7(value) {
              self2.bufferHeight = value;
              self2.realCanvasHeight.set.call(canvas2, value);
              self2.onResize();
            }
          });
        }
        this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        if (this.lastBoundFramebuffer == null) {
          this.lastBoundFramebuffer = this.framebuffer;
          this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        }
        this.gl.bindFramebuffer = function(target, framebuffer) {
          self2.lastBoundFramebuffer = framebuffer ? framebuffer : self2.framebuffer;
          self2.realBindFramebuffer.call(gl, target, self2.lastBoundFramebuffer);
        };
        this.cullFace = gl.getParameter(gl.CULL_FACE);
        this.depthTest = gl.getParameter(gl.DEPTH_TEST);
        this.blend = gl.getParameter(gl.BLEND);
        this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
        this.stencilTest = gl.getParameter(gl.STENCIL_TEST);
        gl.enable = function(pname) {
          switch (pname) {
            case gl.CULL_FACE:
              self2.cullFace = true;
              break;
            case gl.DEPTH_TEST:
              self2.depthTest = true;
              break;
            case gl.BLEND:
              self2.blend = true;
              break;
            case gl.SCISSOR_TEST:
              self2.scissorTest = true;
              break;
            case gl.STENCIL_TEST:
              self2.stencilTest = true;
              break;
          }
          self2.realEnable.call(gl, pname);
        };
        gl.disable = function(pname) {
          switch (pname) {
            case gl.CULL_FACE:
              self2.cullFace = false;
              break;
            case gl.DEPTH_TEST:
              self2.depthTest = false;
              break;
            case gl.BLEND:
              self2.blend = false;
              break;
            case gl.SCISSOR_TEST:
              self2.scissorTest = false;
              break;
            case gl.STENCIL_TEST:
              self2.stencilTest = false;
              break;
          }
          self2.realDisable.call(gl, pname);
        };
        this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
        gl.colorMask = function(r, g, b, a) {
          self2.colorMask[0] = r;
          self2.colorMask[1] = g;
          self2.colorMask[2] = b;
          self2.colorMask[3] = a;
          self2.realColorMask.call(gl, r, g, b, a);
        };
        this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
        gl.clearColor = function(r, g, b, a) {
          self2.clearColor[0] = r;
          self2.clearColor[1] = g;
          self2.clearColor[2] = b;
          self2.clearColor[3] = a;
          self2.realClearColor.call(gl, r, g, b, a);
        };
        this.viewport = gl.getParameter(gl.VIEWPORT);
        gl.viewport = function(x, y, w, h) {
          self2.viewport[0] = x;
          self2.viewport[1] = y;
          self2.viewport[2] = w;
          self2.viewport[3] = h;
          self2.realViewport.call(gl, x, y, w, h);
        };
        this.isPatched = true;
        safariCssSizeWorkaround(canvas2);
      };
      CardboardDistorter.prototype.unpatch = function() {
        if (!this.isPatched) {
          return;
        }
        var gl = this.gl;
        var canvas2 = this.gl.canvas;
        if (!isIOS()) {
          Object.defineProperty(canvas2, "width", this.realCanvasWidth);
          Object.defineProperty(canvas2, "height", this.realCanvasHeight);
        }
        canvas2.width = this.bufferWidth;
        canvas2.height = this.bufferHeight;
        gl.bindFramebuffer = this.realBindFramebuffer;
        gl.enable = this.realEnable;
        gl.disable = this.realDisable;
        gl.colorMask = this.realColorMask;
        gl.clearColor = this.realClearColor;
        gl.viewport = this.realViewport;
        if (this.lastBoundFramebuffer == this.framebuffer) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        this.isPatched = false;
        setTimeout(function() {
          safariCssSizeWorkaround(canvas2);
        }, 1);
      };
      CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
        if (!leftBounds) {
          leftBounds = [0, 0, 0.5, 1];
        }
        if (!rightBounds) {
          rightBounds = [0.5, 0, 0.5, 1];
        }
        this.viewportOffsetScale[0] = leftBounds[0];
        this.viewportOffsetScale[1] = leftBounds[1];
        this.viewportOffsetScale[2] = leftBounds[2];
        this.viewportOffsetScale[3] = leftBounds[3];
        this.viewportOffsetScale[4] = rightBounds[0];
        this.viewportOffsetScale[5] = rightBounds[1];
        this.viewportOffsetScale[6] = rightBounds[2];
        this.viewportOffsetScale[7] = rightBounds[3];
      };
      CardboardDistorter.prototype.submitFrame = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [];
        if (!this.dirtySubmitFrameBindings) {
          glState.push(gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0);
        }
        glPreserveState(gl, glState, function(gl2) {
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
          var positionDivisor = 0;
          var texCoordDivisor = 0;
          if (self2.instanceExt) {
            positionDivisor = gl2.getVertexAttrib(self2.attribs.position, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
            texCoordDivisor = gl2.getVertexAttrib(self2.attribs.texCoord, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
          }
          if (self2.cullFace) {
            self2.realDisable.call(gl2, gl2.CULL_FACE);
          }
          if (self2.depthTest) {
            self2.realDisable.call(gl2, gl2.DEPTH_TEST);
          }
          if (self2.blend) {
            self2.realDisable.call(gl2, gl2.BLEND);
          }
          if (self2.scissorTest) {
            self2.realDisable.call(gl2, gl2.SCISSOR_TEST);
          }
          if (self2.stencilTest) {
            self2.realDisable.call(gl2, gl2.STENCIL_TEST);
          }
          self2.realColorMask.call(gl2, true, true, true, true);
          self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
          if (self2.ctxAttribs.alpha || isIOS()) {
            self2.realClearColor.call(gl2, 0, 0, 0, 1);
            gl2.clear(gl2.COLOR_BUFFER_BIT);
          }
          gl2.useProgram(self2.program);
          gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
          gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
          gl2.enableVertexAttribArray(self2.attribs.position);
          gl2.enableVertexAttribArray(self2.attribs.texCoord);
          gl2.vertexAttribPointer(self2.attribs.position, 2, gl2.FLOAT, false, 20, 0);
          gl2.vertexAttribPointer(self2.attribs.texCoord, 3, gl2.FLOAT, false, 20, 8);
          if (self2.instanceExt) {
            if (positionDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, 0);
            }
            if (texCoordDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, 0);
            }
          }
          gl2.activeTexture(gl2.TEXTURE0);
          gl2.uniform1i(self2.uniforms.diffuse, 0);
          gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget);
          gl2.uniform4fv(self2.uniforms.viewportOffsetScale, self2.viewportOffsetScale);
          gl2.drawElements(gl2.TRIANGLES, self2.indexCount, gl2.UNSIGNED_SHORT, 0);
          if (self2.cardboardUI) {
            self2.cardboardUI.renderNoState();
          }
          self2.realBindFramebuffer.call(self2.gl, gl2.FRAMEBUFFER, self2.framebuffer);
          if (!self2.ctxAttribs.preserveDrawingBuffer) {
            self2.realClearColor.call(gl2, 0, 0, 0, 0);
            gl2.clear(gl2.COLOR_BUFFER_BIT);
          }
          if (!self2.dirtySubmitFrameBindings) {
            self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer);
          }
          if (self2.cullFace) {
            self2.realEnable.call(gl2, gl2.CULL_FACE);
          }
          if (self2.depthTest) {
            self2.realEnable.call(gl2, gl2.DEPTH_TEST);
          }
          if (self2.blend) {
            self2.realEnable.call(gl2, gl2.BLEND);
          }
          if (self2.scissorTest) {
            self2.realEnable.call(gl2, gl2.SCISSOR_TEST);
          }
          if (self2.stencilTest) {
            self2.realEnable.call(gl2, gl2.STENCIL_TEST);
          }
          self2.realColorMask.apply(gl2, self2.colorMask);
          self2.realViewport.apply(gl2, self2.viewport);
          if (self2.ctxAttribs.alpha || !self2.ctxAttribs.preserveDrawingBuffer) {
            self2.realClearColor.apply(gl2, self2.clearColor);
          }
          if (self2.instanceExt) {
            if (positionDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, positionDivisor);
            }
            if (texCoordDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, texCoordDivisor);
            }
          }
        });
        if (isIOS()) {
          var canvas2 = gl.canvas;
          if (canvas2.width != self2.bufferWidth || canvas2.height != self2.bufferHeight) {
            self2.bufferWidth = canvas2.width;
            self2.bufferHeight = canvas2.height;
            self2.onResize();
          }
        }
      };
      CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
        glPreserveState(gl, glState, function(gl2) {
          var vertices = self2.computeMeshVertices_(self2.meshWidth, self2.meshHeight, deviceInfo);
          gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
          gl2.bufferData(gl2.ARRAY_BUFFER, vertices, gl2.STATIC_DRAW);
          if (!self2.indexCount) {
            var indices = self2.computeMeshIndices_(self2.meshWidth, self2.meshHeight);
            gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
            gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, indices, gl2.STATIC_DRAW);
            self2.indexCount = indices.length;
          }
        });
      };
      CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
        var vertices = new Float32Array(2 * width * height * 5);
        var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
        var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
        var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
        var vidx = 0;
        for (var e = 0; e < 2; e++) {
          for (var j = 0; j < height; j++) {
            for (var i = 0; i < width; i++, vidx++) {
              var u = i / (width - 1);
              var v = j / (height - 1);
              var s = u;
              var t = v;
              var x = lerp6(lensFrustum[0], lensFrustum[2], u);
              var y = lerp6(lensFrustum[3], lensFrustum[1], v);
              var d = Math.sqrt(x * x + y * y);
              var r = deviceInfo.distortion.distortInverse(d);
              var p = x * r / d;
              var q = y * r / d;
              u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
              v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
              u = (viewport.x + u * viewport.width - 0.5) * 2;
              v = (viewport.y + v * viewport.height - 0.5) * 2;
              vertices[vidx * 5 + 0] = u;
              vertices[vidx * 5 + 1] = v;
              vertices[vidx * 5 + 2] = s;
              vertices[vidx * 5 + 3] = t;
              vertices[vidx * 5 + 4] = e;
            }
          }
          var w = lensFrustum[2] - lensFrustum[0];
          lensFrustum[0] = -(w + lensFrustum[0]);
          lensFrustum[2] = w - lensFrustum[2];
          w = noLensFrustum[2] - noLensFrustum[0];
          noLensFrustum[0] = -(w + noLensFrustum[0]);
          noLensFrustum[2] = w - noLensFrustum[2];
          viewport.x = 1 - (viewport.x + viewport.width);
        }
        return vertices;
      };
      CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
        var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
        var halfwidth = width / 2;
        var halfheight = height / 2;
        var vidx = 0;
        var iidx = 0;
        for (var e = 0; e < 2; e++) {
          for (var j = 0; j < height; j++) {
            for (var i = 0; i < width; i++, vidx++) {
              if (i == 0 || j == 0)
                continue;
              if (i <= halfwidth == j <= halfheight) {
                indices[iidx++] = vidx;
                indices[iidx++] = vidx - width - 1;
                indices[iidx++] = vidx - width;
                indices[iidx++] = vidx - width - 1;
                indices[iidx++] = vidx;
                indices[iidx++] = vidx - 1;
              } else {
                indices[iidx++] = vidx - 1;
                indices[iidx++] = vidx - width;
                indices[iidx++] = vidx;
                indices[iidx++] = vidx - width;
                indices[iidx++] = vidx - 1;
                indices[iidx++] = vidx - width - 1;
              }
            }
          }
        }
        return indices;
      };
      CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
        var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
        if (descriptor.get === void 0 || descriptor.set === void 0) {
          descriptor.configurable = true;
          descriptor.enumerable = true;
          descriptor.get = function() {
            return this.getAttribute(attrName);
          };
          descriptor.set = function(val) {
            this.setAttribute(attrName, val);
          };
        }
        return descriptor;
      };
      var uiVS = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join("\n");
      var uiFS = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join("\n");
      var DEG2RAD = Math.PI / 180;
      var kAnglePerGearSection = 60;
      var kOuterRimEndAngle = 12;
      var kInnerRimBeginAngle = 20;
      var kOuterRadius = 1;
      var kMiddleRadius = 0.75;
      var kInnerRadius = 0.3125;
      var kCenterLineThicknessDp = 4;
      var kButtonWidthDp = 28;
      var kTouchSlopFactor = 1.5;
      function CardboardUI(gl) {
        this.gl = gl;
        this.attribs = {
          position: 0
        };
        this.program = linkProgram(gl, uiVS, uiFS, this.attribs);
        this.uniforms = getProgramUniforms(gl, this.program);
        this.vertexBuffer = gl.createBuffer();
        this.gearOffset = 0;
        this.gearVertexCount = 0;
        this.arrowOffset = 0;
        this.arrowVertexCount = 0;
        this.projMat = new Float32Array(16);
        this.listener = null;
        this.onResize();
      }
      CardboardUI.prototype.destroy = function() {
        var gl = this.gl;
        if (this.listener) {
          gl.canvas.removeEventListener("click", this.listener, false);
        }
        gl.deleteProgram(this.program);
        gl.deleteBuffer(this.vertexBuffer);
      };
      CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
        var canvas2 = this.gl.canvas;
        this.listener = function(event) {
          var midline = canvas2.clientWidth / 2;
          var buttonSize = kButtonWidthDp * kTouchSlopFactor;
          if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas2.clientHeight - buttonSize) {
            optionsCallback(event);
          } else if (event.clientX < buttonSize && event.clientY < buttonSize) {
            backCallback(event);
          }
        };
        canvas2.addEventListener("click", this.listener, false);
      };
      CardboardUI.prototype.onResize = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.ARRAY_BUFFER_BINDING];
        glPreserveState(gl, glState, function(gl2) {
          var vertices = [];
          var midline = gl2.drawingBufferWidth / 2;
          var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
          var scalingRatio = gl2.drawingBufferWidth / physicalPixels;
          var dps = scalingRatio * window.devicePixelRatio;
          var lineWidth = kCenterLineThicknessDp * dps / 2;
          var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
          var buttonScale = kButtonWidthDp * dps / 2;
          var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
          vertices.push(midline - lineWidth, buttonSize);
          vertices.push(midline - lineWidth, gl2.drawingBufferHeight);
          vertices.push(midline + lineWidth, buttonSize);
          vertices.push(midline + lineWidth, gl2.drawingBufferHeight);
          self2.gearOffset = vertices.length / 2;
          function addGearSegment(theta, r) {
            var angle3 = (90 - theta) * DEG2RAD;
            var x = Math.cos(angle3);
            var y = Math.sin(angle3);
            vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
            vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
          }
          for (var i = 0; i <= 6; i++) {
            var segmentTheta = i * kAnglePerGearSection;
            addGearSegment(segmentTheta, kOuterRadius);
            addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
            addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
            addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
            addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
          }
          self2.gearVertexCount = vertices.length / 2 - self2.gearOffset;
          self2.arrowOffset = vertices.length / 2;
          function addArrowVertex(x, y) {
            vertices.push(buttonBorder + x, gl2.drawingBufferHeight - buttonBorder - y);
          }
          var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
          addArrowVertex(0, buttonScale);
          addArrowVertex(buttonScale, 0);
          addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
          addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
          addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
          addArrowVertex(0, buttonScale);
          addArrowVertex(buttonScale, buttonScale * 2);
          addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);
          addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
          addArrowVertex(0, buttonScale);
          addArrowVertex(angledLineWidth, buttonScale - lineWidth);
          addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
          addArrowVertex(angledLineWidth, buttonScale + lineWidth);
          addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
          self2.arrowVertexCount = vertices.length / 2 - self2.arrowOffset;
          gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
          gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(vertices), gl2.STATIC_DRAW);
        });
      };
      CardboardUI.prototype.render = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.CULL_FACE, gl.DEPTH_TEST, gl.BLEND, gl.SCISSOR_TEST, gl.STENCIL_TEST, gl.COLOR_WRITEMASK, gl.VIEWPORT, gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING];
        glPreserveState(gl, glState, function(gl2) {
          gl2.disable(gl2.CULL_FACE);
          gl2.disable(gl2.DEPTH_TEST);
          gl2.disable(gl2.BLEND);
          gl2.disable(gl2.SCISSOR_TEST);
          gl2.disable(gl2.STENCIL_TEST);
          gl2.colorMask(true, true, true, true);
          gl2.viewport(0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
          self2.renderNoState();
        });
      };
      CardboardUI.prototype.renderNoState = function() {
        var gl = this.gl;
        gl.useProgram(this.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.enableVertexAttribArray(this.attribs.position);
        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);
        gl.uniform4f(this.uniforms.color, 1, 1, 1, 1);
        orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024);
        gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
        gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
      };
      function Distortion(coefficients) {
        this.coefficients = coefficients;
      }
      Distortion.prototype.distortInverse = function(radius) {
        var r0 = 0;
        var r1 = 1;
        var dr0 = radius - this.distort(r0);
        while (Math.abs(r1 - r0) > 1e-4) {
          var dr1 = radius - this.distort(r1);
          var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
          r0 = r1;
          r1 = r2;
          dr0 = dr1;
        }
        return r1;
      };
      Distortion.prototype.distort = function(radius) {
        var r2 = radius * radius;
        var ret = 0;
        for (var i = 0; i < this.coefficients.length; i++) {
          ret = r2 * (ret + this.coefficients[i]);
        }
        return (ret + 1) * radius;
      };
      var degToRad = Math.PI / 180;
      var radToDeg = 180 / Math.PI;
      var Vector3 = function Vector32(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      };
      Vector3.prototype = {
        constructor: Vector3,
        set: function set7(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        },
        copy: function copy10(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        },
        length: function length7() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        normalize: function normalize8() {
          var scalar = this.length();
          if (scalar !== 0) {
            var invScalar = 1 / scalar;
            this.multiplyScalar(invScalar);
          } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
          }
          return this;
        },
        multiplyScalar: function multiplyScalar2(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
        },
        applyQuaternion: function applyQuaternion(q) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var qx = q.x;
          var qy = q.y;
          var qz = q.z;
          var qw = q.w;
          var ix = qw * x + qy * z - qz * y;
          var iy = qw * y + qz * x - qx * z;
          var iz = qw * z + qx * y - qy * x;
          var iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        },
        dot: function dot7(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        crossVectors: function crossVectors(a, b) {
          var ax = a.x, ay = a.y, az = a.z;
          var bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
      };
      var Quaternion = function Quaternion2(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w !== void 0 ? w : 1;
      };
      Quaternion.prototype = {
        constructor: Quaternion,
        set: function set7(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        },
        copy: function copy10(quaternion) {
          this.x = quaternion.x;
          this.y = quaternion.y;
          this.z = quaternion.z;
          this.w = quaternion.w;
          return this;
        },
        setFromEulerXYZ: function setFromEulerXYZ(x, y, z) {
          var c1 = Math.cos(x / 2);
          var c2 = Math.cos(y / 2);
          var c3 = Math.cos(z / 2);
          var s1 = Math.sin(x / 2);
          var s2 = Math.sin(y / 2);
          var s3 = Math.sin(z / 2);
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
          return this;
        },
        setFromEulerYXZ: function setFromEulerYXZ(x, y, z) {
          var c1 = Math.cos(x / 2);
          var c2 = Math.cos(y / 2);
          var c3 = Math.cos(z / 2);
          var s1 = Math.sin(x / 2);
          var s2 = Math.sin(y / 2);
          var s3 = Math.sin(z / 2);
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
          return this;
        },
        setFromAxisAngle: function setFromAxisAngle(axis, angle3) {
          var halfAngle = angle3 / 2, s = Math.sin(halfAngle);
          this.x = axis.x * s;
          this.y = axis.y * s;
          this.z = axis.z * s;
          this.w = Math.cos(halfAngle);
          return this;
        },
        multiply: function multiply7(q) {
          return this.multiplyQuaternions(this, q);
        },
        multiplyQuaternions: function multiplyQuaternions(a, b) {
          var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
          var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
          this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          return this;
        },
        inverse: function inverse2() {
          this.x *= -1;
          this.y *= -1;
          this.z *= -1;
          this.normalize();
          return this;
        },
        normalize: function normalize8() {
          var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
          if (l === 0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
          } else {
            l = 1 / l;
            this.x = this.x * l;
            this.y = this.y * l;
            this.z = this.z * l;
            this.w = this.w * l;
          }
          return this;
        },
        slerp: function slerp3(qb, t) {
          if (t === 0)
            return this;
          if (t === 1)
            return this.copy(qb);
          var x = this.x, y = this.y, z = this.z, w = this.w;
          var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
          if (cosHalfTheta < 0) {
            this.w = -qb.w;
            this.x = -qb.x;
            this.y = -qb.y;
            this.z = -qb.z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this.w = w;
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
          }
          var halfTheta = Math.acos(cosHalfTheta);
          var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
          if (Math.abs(sinHalfTheta) < 1e-3) {
            this.w = 0.5 * (w + this.w);
            this.x = 0.5 * (x + this.x);
            this.y = 0.5 * (y + this.y);
            this.z = 0.5 * (z + this.z);
            return this;
          }
          var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
          this.w = w * ratioA + this.w * ratioB;
          this.x = x * ratioA + this.x * ratioB;
          this.y = y * ratioA + this.y * ratioB;
          this.z = z * ratioA + this.z * ratioB;
          return this;
        },
        setFromUnitVectors: function() {
          var v1, r;
          var EPS = 1e-6;
          return function(vFrom, vTo) {
            if (v1 === void 0)
              v1 = new Vector3();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
              r = 0;
              if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                v1.set(-vFrom.y, vFrom.x, 0);
              } else {
                v1.set(0, -vFrom.z, vFrom.y);
              }
            } else {
              v1.crossVectors(vFrom, vTo);
            }
            this.x = v1.x;
            this.y = v1.y;
            this.z = v1.z;
            this.w = r;
            this.normalize();
            return this;
          };
        }()
      };
      function Device(params) {
        this.width = params.width || getScreenWidth();
        this.height = params.height || getScreenHeight();
        this.widthMeters = params.widthMeters;
        this.heightMeters = params.heightMeters;
        this.bevelMeters = params.bevelMeters;
      }
      var DEFAULT_ANDROID = new Device({
        widthMeters: 0.11,
        heightMeters: 0.062,
        bevelMeters: 4e-3
      });
      var DEFAULT_IOS = new Device({
        widthMeters: 0.1038,
        heightMeters: 0.0584,
        bevelMeters: 4e-3
      });
      var Viewers = {
        CardboardV1: new CardboardViewer({
          id: "CardboardV1",
          label: "Cardboard I/O 2014",
          fov: 40,
          interLensDistance: 0.06,
          baselineLensDistance: 0.035,
          screenLensDistance: 0.042,
          distortionCoefficients: [0.441, 0.156],
          inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
        }),
        CardboardV2: new CardboardViewer({
          id: "CardboardV2",
          label: "Cardboard I/O 2015",
          fov: 60,
          interLensDistance: 0.064,
          baselineLensDistance: 0.035,
          screenLensDistance: 0.039,
          distortionCoefficients: [0.34, 0.55],
          inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
        })
      };
      function DeviceInfo(deviceParams, additionalViewers) {
        this.viewer = Viewers.CardboardV2;
        this.updateDeviceParams(deviceParams);
        this.distortion = new Distortion(this.viewer.distortionCoefficients);
        for (var i = 0; i < additionalViewers.length; i++) {
          var viewer = additionalViewers[i];
          Viewers[viewer.id] = new CardboardViewer(viewer);
        }
      }
      DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
        this.device = this.determineDevice_(deviceParams) || this.device;
      };
      DeviceInfo.prototype.getDevice = function() {
        return this.device;
      };
      DeviceInfo.prototype.setViewer = function(viewer) {
        this.viewer = viewer;
        this.distortion = new Distortion(this.viewer.distortionCoefficients);
      };
      DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
        if (!deviceParams) {
          if (isIOS()) {
            console.warn("Using fallback iOS device measurements.");
            return DEFAULT_IOS;
          } else {
            console.warn("Using fallback Android device measurements.");
            return DEFAULT_ANDROID;
          }
        }
        var METERS_PER_INCH = 0.0254;
        var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
        var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
        var width = getScreenWidth();
        var height = getScreenHeight();
        return new Device({
          widthMeters: metersPerPixelX * width,
          heightMeters: metersPerPixelY * height,
          bevelMeters: deviceParams.bevelMm * 1e-3
        });
      };
      DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var eyeToScreenDistance = viewer.screenLensDistance;
        var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
        var innerDist = viewer.interLensDistance / 2;
        var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
        var topDist = device.heightMeters - bottomDist;
        var outerAngle = radToDeg * Math.atan(distortion.distort(outerDist / eyeToScreenDistance));
        var innerAngle = radToDeg * Math.atan(distortion.distort(innerDist / eyeToScreenDistance));
        var bottomAngle = radToDeg * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance));
        var topAngle = radToDeg * Math.atan(distortion.distort(topDist / eyeToScreenDistance));
        return {
          leftDegrees: Math.min(outerAngle, viewer.fov),
          rightDegrees: Math.min(innerAngle, viewer.fov),
          downDegrees: Math.min(bottomAngle, viewer.fov),
          upDegrees: Math.min(topAngle, viewer.fov)
        };
      };
      DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var fovLeft = Math.tan(-degToRad * viewer.fov);
        var fovTop = Math.tan(degToRad * viewer.fov);
        var fovRight = Math.tan(degToRad * viewer.fov);
        var fovBottom = Math.tan(-degToRad * viewer.fov);
        var halfWidth = device.widthMeters / 4;
        var halfHeight = device.heightMeters / 2;
        var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
        var centerX = viewer.interLensDistance / 2 - halfWidth;
        var centerY = -verticalLensOffset;
        var centerZ = viewer.screenLensDistance;
        var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
        var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
        var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
        var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
        var result = new Float32Array(4);
        result[0] = Math.max(fovLeft, screenLeft);
        result[1] = Math.min(fovTop, screenTop);
        result[2] = Math.min(fovRight, screenRight);
        result[3] = Math.max(fovBottom, screenBottom);
        return result;
      };
      DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var result = new Float32Array(4);
        var fovLeft = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
        var fovTop = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
        var fovRight = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
        var fovBottom = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
        var halfWidth = device.widthMeters / 4;
        var halfHeight = device.heightMeters / 2;
        var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
        var centerX = viewer.interLensDistance / 2 - halfWidth;
        var centerY = -verticalLensOffset;
        var centerZ = viewer.screenLensDistance;
        var screenLeft = (centerX - halfWidth) / centerZ;
        var screenTop = (centerY + halfHeight) / centerZ;
        var screenRight = (centerX + halfWidth) / centerZ;
        var screenBottom = (centerY - halfHeight) / centerZ;
        result[0] = Math.max(fovLeft, screenLeft);
        result[1] = Math.min(fovTop, screenTop);
        result[2] = Math.min(fovRight, screenRight);
        result[3] = Math.max(fovBottom, screenBottom);
        return result;
      };
      DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
        var viewer = this.viewer;
        var device = this.device;
        var dist2 = viewer.screenLensDistance;
        var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
        var eyeY = viewer.baselineLensDistance - device.bevelMeters;
        var left = (undistortedFrustum[0] * dist2 + eyeX) / device.widthMeters;
        var top = (undistortedFrustum[1] * dist2 + eyeY) / device.heightMeters;
        var right = (undistortedFrustum[2] * dist2 + eyeX) / device.widthMeters;
        var bottom = (undistortedFrustum[3] * dist2 + eyeY) / device.heightMeters;
        return {
          x: left,
          y: bottom,
          width: right - left,
          height: top - bottom
        };
      };
      DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
        return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
      };
      DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
        var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
        return {
          leftDegrees: fov.rightDegrees,
          rightDegrees: fov.leftDegrees,
          upDegrees: fov.upDegrees,
          downDegrees: fov.downDegrees
        };
      };
      DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
        var p = this.getUndistortedParams_();
        return {
          leftDegrees: radToDeg * Math.atan(p.outerDist),
          rightDegrees: radToDeg * Math.atan(p.innerDist),
          downDegrees: radToDeg * Math.atan(p.bottomDist),
          upDegrees: radToDeg * Math.atan(p.topDist)
        };
      };
      DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
        var p = this.getUndistortedParams_();
        var viewer = this.viewer;
        var device = this.device;
        var eyeToScreenDistance = viewer.screenLensDistance;
        var screenWidth = device.widthMeters / eyeToScreenDistance;
        var screenHeight = device.heightMeters / eyeToScreenDistance;
        var xPxPerTanAngle = device.width / screenWidth;
        var yPxPerTanAngle = device.height / screenHeight;
        var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
        var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
        return {
          x,
          y,
          width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
          height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
        };
      };
      DeviceInfo.prototype.getUndistortedParams_ = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var eyeToScreenDistance = viewer.screenLensDistance;
        var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
        var screenWidth = device.widthMeters / eyeToScreenDistance;
        var screenHeight = device.heightMeters / eyeToScreenDistance;
        var eyePosX = screenWidth / 2 - halfLensDistance;
        var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
        var maxFov = viewer.fov;
        var viewerMax = distortion.distortInverse(Math.tan(degToRad * maxFov));
        var outerDist = Math.min(eyePosX, viewerMax);
        var innerDist = Math.min(halfLensDistance, viewerMax);
        var bottomDist = Math.min(eyePosY, viewerMax);
        var topDist = Math.min(screenHeight - eyePosY, viewerMax);
        return {
          outerDist,
          innerDist,
          topDist,
          bottomDist,
          eyePosX,
          eyePosY
        };
      };
      function CardboardViewer(params) {
        this.id = params.id;
        this.label = params.label;
        this.fov = params.fov;
        this.interLensDistance = params.interLensDistance;
        this.baselineLensDistance = params.baselineLensDistance;
        this.screenLensDistance = params.screenLensDistance;
        this.distortionCoefficients = params.distortionCoefficients;
        this.inverseCoefficients = params.inverseCoefficients;
      }
      DeviceInfo.Viewers = Viewers;
      var format = 1;
      var last_updated = "2019-11-09T17:36:14Z";
      var devices = [{ "type": "android", "rules": [{ "mdmh": "asus/*/Nexus 7/*" }, { "ua": "Nexus 7" }], "dpi": [320.8, 323], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_X00PD/*" }, { "ua": "ASUS_X00PD" }], "dpi": 245, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_X008D/*" }, { "ua": "ASUS_X008D" }], "dpi": 282, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_Z00AD/*" }, { "ua": "ASUS_Z00AD" }], "dpi": [403, 404.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 2 XL/*" }, { "ua": "Pixel 2 XL" }], "dpi": 537.9, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 3 XL/*" }, { "ua": "Pixel 3 XL" }], "dpi": [558.5, 553.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel XL/*" }, { "ua": "Pixel XL" }], "dpi": [537.9, 533], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 3/*" }, { "ua": "Pixel 3" }], "dpi": 442.4, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 2/*" }, { "ua": "Pixel 2" }], "dpi": 441, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel/*" }, { "ua": "Pixel" }], "dpi": [432.6, 436.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC6435LVW/*" }, { "ua": "HTC6435LVW" }], "dpi": [449.7, 443.3], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One XL/*" }, { "ua": "HTC One XL" }], "dpi": [315.3, 314.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "htc/*/Nexus 9/*" }, { "ua": "Nexus 9" }], "dpi": 289, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One M9/*" }, { "ua": "HTC One M9" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One_M8/*" }, { "ua": "HTC One_M8" }], "dpi": [449.7, 447.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One/*" }, { "ua": "HTC One" }], "dpi": 472.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/Nexus 6P/*" }, { "ua": "Nexus 6P" }], "dpi": [515.1, 518], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/BLN-L24/*" }, { "ua": "HONORBLN-L24" }], "dpi": 480, "bw": 4, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/BKL-L09/*" }, { "ua": "BKL-L09" }], "dpi": 403, "bw": 3.47, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LENOVO/*/Lenovo PB2-690Y/*" }, { "ua": "Lenovo PB2-690Y" }], "dpi": [457.2, 454.713], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5X/*" }, { "ua": "Nexus 5X" }], "dpi": [422, 419.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS345/*" }, { "ua": "LGMS345" }], "dpi": [221.7, 219.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D800/*" }, { "ua": "LG-D800" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D850/*" }, { "ua": "LG-D850" }], "dpi": [537.9, 541.9], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/VS985 4G/*" }, { "ua": "VS985 4G" }], "dpi": [537.9, 535.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5/*" }, { "ua": "Nexus 5 B" }], "dpi": [442.4, 444.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 4/*" }, { "ua": "Nexus 4" }], "dpi": [319.8, 318.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-P769/*" }, { "ua": "LG-P769" }], "dpi": [240.6, 247.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS323/*" }, { "ua": "LGMS323" }], "dpi": [206.6, 204.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGLS996/*" }, { "ua": "LGLS996" }], "dpi": [403.4, 401.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/4560MMX/*" }, { "ua": "4560MMX" }], "dpi": [240, 219.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/A250/*" }, { "ua": "Micromax A250" }], "dpi": [480, 446.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/Micromax AQ4501/*" }, { "ua": "Micromax AQ4501" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G5/*" }, { "ua": "Moto G (5) Plus" }], "dpi": [403.4, 403], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/DROID RAZR/*" }, { "ua": "DROID RAZR" }], "dpi": [368.1, 256.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT830C/*" }, { "ua": "XT830C" }], "dpi": [254, 255.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1021/*" }, { "ua": "XT1021" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1023/*" }, { "ua": "XT1023" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1028/*" }, { "ua": "XT1028" }], "dpi": [326.6, 327.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1034/*" }, { "ua": "XT1034" }], "dpi": [326.6, 328.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1053/*" }, { "ua": "XT1053" }], "dpi": [315.3, 316.1], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1562/*" }, { "ua": "XT1562" }], "dpi": [403.4, 402.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/Nexus 6/*" }, { "ua": "Nexus 6 B" }], "dpi": [494.3, 489.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1063/*" }, { "ua": "XT1063" }], "dpi": [295, 296.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1064/*" }, { "ua": "XT1064" }], "dpi": [295, 295.6], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1092/*" }, { "ua": "XT1092" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1095/*" }, { "ua": "XT1095" }], "dpi": [422, 423.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G4/*" }, { "ua": "Moto G (4)" }], "dpi": 401, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/A0001/*" }, { "ua": "A0001" }], "dpi": [403.4, 401], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1001/*" }, { "ua": "ONE E1001" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1003/*" }, { "ua": "ONE E1003" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1005/*" }, { "ua": "ONE E1005" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2001/*" }, { "ua": "ONE A2001" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2003/*" }, { "ua": "ONE A2003" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2005/*" }, { "ua": "ONE A2005" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3000/*" }, { "ua": "ONEPLUS A3000" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3003/*" }, { "ua": "ONEPLUS A3003" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3010/*" }, { "ua": "ONEPLUS A3010" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A5000/*" }, { "ua": "ONEPLUS A5000 " }], "dpi": [403.411, 399.737], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A5010/*" }, { "ua": "ONEPLUS A5010" }], "dpi": [403, 400], "bw": 2, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6000/*" }, { "ua": "ONEPLUS A6000" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6003/*" }, { "ua": "ONEPLUS A6003" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6010/*" }, { "ua": "ONEPLUS A6010" }], "dpi": 401, "bw": 2, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6013/*" }, { "ua": "ONEPLUS A6013" }], "dpi": 401, "bw": 2, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OPPO/*/X909/*" }, { "ua": "X909" }], "dpi": [442.4, 444.1], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9082/*" }, { "ua": "GT-I9082" }], "dpi": [184.7, 185.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G360P/*" }, { "ua": "SM-G360P" }], "dpi": [196.7, 205.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Nexus S/*" }, { "ua": "Nexus S" }], "dpi": [234.5, 229.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [304.8, 303.9], "bw": 5, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T230NU/*" }, { "ua": "SM-T230NU" }], "dpi": 216, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-T399/*" }, { "ua": "SGH-T399" }], "dpi": [217.7, 231.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-M919/*" }, { "ua": "SGH-M919" }], "dpi": [440.8, 437.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N9005/*" }, { "ua": "SM-N9005" }], "dpi": [386.4, 387], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" }, { "ua": "SAMSUNG-SM-N900A" }], "dpi": [386.4, 387.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9500/*" }, { "ua": "GT-I9500" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9505/*" }, { "ua": "GT-I9505" }], "dpi": 439.4, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900F/*" }, { "ua": "SM-G900F" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900M/*" }, { "ua": "SM-G900M" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G800F/*" }, { "ua": "SM-G800F" }], "dpi": 326.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G906S/*" }, { "ua": "SM-G906S" }], "dpi": [562.7, 572.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [306.7, 304.8], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T535/*" }, { "ua": "SM-T535" }], "dpi": [142.6, 136.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920C/*" }, { "ua": "SM-N920C" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920P/*" }, { "ua": "SM-N920P" }], "dpi": [386.3655, 390.144], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920W8/*" }, { "ua": "SM-N920W8" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300I/*" }, { "ua": "GT-I9300I" }], "dpi": [304.8, 305.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9195/*" }, { "ua": "GT-I9195" }], "dpi": [249.4, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-L520/*" }, { "ua": "SPH-L520" }], "dpi": [249.4, 255.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" }, { "ua": "SAMSUNG-SGH-I717" }], "dpi": 285.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-D710/*" }, { "ua": "SPH-D710" }], "dpi": [217.7, 204.2], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-N7100/*" }, { "ua": "GT-N7100" }], "dpi": 265.1, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SCH-I605/*" }, { "ua": "SCH-I605" }], "dpi": 265.1, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Galaxy Nexus/*" }, { "ua": "Galaxy Nexus" }], "dpi": [315.3, 314.2], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910H/*" }, { "ua": "SM-N910H" }], "dpi": [515.1, 518], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910C/*" }, { "ua": "SM-N910C" }], "dpi": [515.2, 520.2], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G130M/*" }, { "ua": "SM-G130M" }], "dpi": [165.9, 164.8], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G928I/*" }, { "ua": "SM-G928I" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920F/*" }, { "ua": "SM-G920F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920P/*" }, { "ua": "SM-G920P" }], "dpi": [522.5, 577], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925F/*" }, { "ua": "SM-G925F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925V/*" }, { "ua": "SM-G925V" }], "dpi": [522.5, 576.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G930F/*" }, { "ua": "SM-G930F" }], "dpi": 576.6, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G935F/*" }, { "ua": "SM-G935F" }], "dpi": 533, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G950F/*" }, { "ua": "SM-G950F" }], "dpi": [562.707, 565.293], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955U/*" }, { "ua": "SM-G955U" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955F/*" }, { "ua": "SM-G955F" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960F/*" }, { "ua": "SM-G960F" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G9600/*" }, { "ua": "SM-G9600" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960T/*" }, { "ua": "SM-G960T" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960N/*" }, { "ua": "SM-G960N" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960U/*" }, { "ua": "SM-G960U" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G9608/*" }, { "ua": "SM-G9608" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960FD/*" }, { "ua": "SM-G960FD" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960W/*" }, { "ua": "SM-G960W" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G965F/*" }, { "ua": "SM-G965F" }], "dpi": 529, "bw": 2, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/C6903/*" }, { "ua": "C6903" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/D6653/*" }, { "ua": "D6653" }], "dpi": [428.6, 427.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6653/*" }, { "ua": "E6653" }], "dpi": [428.6, 425.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6853/*" }, { "ua": "E6853" }], "dpi": [403.4, 401.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/SGP321/*" }, { "ua": "SGP321" }], "dpi": [224.7, 224.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { "ua": "ALCATEL ONE TOUCH Fierce" }], "dpi": [240, 247.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "THL/*/thl 5000/*" }, { "ua": "thl 5000" }], "dpi": [480, 443.3], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Fly/*/IQ4412/*" }, { "ua": "IQ4412" }], "dpi": 307.9, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "ZTE/*/ZTE Blade L2/*" }, { "ua": "ZTE Blade L2" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "BENEVE/*/VR518/*" }, { "ua": "VR518" }], "dpi": 480, "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [640, 960] }], "dpi": [325.1, 328.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [640, 1136] }], "dpi": [317.1, 320.2], "bw": 3, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [750, 1334] }], "dpi": 326.4, "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1242, 2208] }], "dpi": [453.6, 458.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1125, 2001] }], "dpi": [410.9, 415.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1125, 2436] }], "dpi": 458, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/EML-L29/*" }, { "ua": "EML-L29" }], "dpi": 428, "bw": 3.45, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Nokia/*/Nokia 7.1/*" }, { "ua": "Nokia 7.1" }], "dpi": [432, 431.9], "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [1242, 2688] }], "dpi": 458, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G570M/*" }, { "ua": "SM-G570M" }], "dpi": 320, "bw": 3.684, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G970F/*" }, { "ua": "SM-G970F" }], "dpi": 438, "bw": 2.281, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G973F/*" }, { "ua": "SM-G973F" }], "dpi": 550, "bw": 2.002, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G975F/*" }, { "ua": "SM-G975F" }], "dpi": 522, "bw": 2.054, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G977F/*" }, { "ua": "SM-G977F" }], "dpi": 505, "bw": 2.334, "ac": 500 }, { "type": "ios", "rules": [{ "res": [828, 1792] }], "dpi": 326, "bw": 5, "ac": 500 }];
      var DPDB_CACHE = {
        format,
        last_updated,
        devices
      };
      function Dpdb(url, onDeviceParamsUpdated) {
        this.dpdb = DPDB_CACHE;
        this.recalculateDeviceParams_();
        if (url) {
          this.onDeviceParamsUpdated = onDeviceParamsUpdated;
          var xhr = new XMLHttpRequest();
          var obj = this;
          xhr.open("GET", url, true);
          xhr.addEventListener("load", function() {
            obj.loading = false;
            if (xhr.status >= 200 && xhr.status <= 299) {
              obj.dpdb = JSON.parse(xhr.response);
              obj.recalculateDeviceParams_();
            } else {
              console.error("Error loading online DPDB!");
            }
          });
          xhr.send();
        }
      }
      Dpdb.prototype.getDeviceParams = function() {
        return this.deviceParams;
      };
      Dpdb.prototype.recalculateDeviceParams_ = function() {
        var newDeviceParams = this.calcDeviceParams_();
        if (newDeviceParams) {
          this.deviceParams = newDeviceParams;
          if (this.onDeviceParamsUpdated) {
            this.onDeviceParamsUpdated(this.deviceParams);
          }
        } else {
          console.error("Failed to recalculate device parameters.");
        }
      };
      Dpdb.prototype.calcDeviceParams_ = function() {
        var db = this.dpdb;
        if (!db) {
          console.error("DPDB not available.");
          return null;
        }
        if (db.format != 1) {
          console.error("DPDB has unexpected format version.");
          return null;
        }
        if (!db.devices || !db.devices.length) {
          console.error("DPDB does not have a devices section.");
          return null;
        }
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        var width = getScreenWidth();
        var height = getScreenHeight();
        if (!db.devices) {
          console.error("DPDB has no devices section.");
          return null;
        }
        for (var i = 0; i < db.devices.length; i++) {
          var device = db.devices[i];
          if (!device.rules) {
            console.warn("Device[" + i + "] has no rules section.");
            continue;
          }
          if (device.type != "ios" && device.type != "android") {
            console.warn("Device[" + i + "] has invalid type.");
            continue;
          }
          if (isIOS() != (device.type == "ios"))
            continue;
          var matched = false;
          for (var j = 0; j < device.rules.length; j++) {
            var rule = device.rules[j];
            if (this.ruleMatches_(rule, userAgent, width, height)) {
              matched = true;
              break;
            }
          }
          if (!matched)
            continue;
          var xdpi = device.dpi[0] || device.dpi;
          var ydpi = device.dpi[1] || device.dpi;
          return new DeviceParams({ xdpi, ydpi, bevelMm: device.bw });
        }
        console.warn("No DPDB device match.");
        return null;
      };
      Dpdb.prototype.ruleMatches_ = function(rule, ua, screenWidth, screenHeight) {
        if (!rule.ua && !rule.res)
          return false;
        if (rule.ua && rule.ua.substring(0, 2) === "SM")
          rule.ua = rule.ua.substring(0, 7);
        if (rule.ua && ua.indexOf(rule.ua) < 0)
          return false;
        if (rule.res) {
          if (!rule.res[0] || !rule.res[1])
            return false;
          var resX = rule.res[0];
          var resY = rule.res[1];
          if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
            return false;
          }
        }
        return true;
      };
      function DeviceParams(params) {
        this.xdpi = params.xdpi;
        this.ydpi = params.ydpi;
        this.bevelMm = params.bevelMm;
      }
      function SensorSample(sample, timestampS) {
        this.set(sample, timestampS);
      }
      SensorSample.prototype.set = function(sample, timestampS) {
        this.sample = sample;
        this.timestampS = timestampS;
      };
      SensorSample.prototype.copy = function(sensorSample) {
        this.set(sensorSample.sample, sensorSample.timestampS);
      };
      function ComplementaryFilter(kFilter, isDebug) {
        this.kFilter = kFilter;
        this.isDebug = isDebug;
        this.currentAccelMeasurement = new SensorSample();
        this.currentGyroMeasurement = new SensorSample();
        this.previousGyroMeasurement = new SensorSample();
        if (isIOS()) {
          this.filterQ = new Quaternion(-1, 0, 0, 1);
        } else {
          this.filterQ = new Quaternion(1, 0, 0, 1);
        }
        this.previousFilterQ = new Quaternion();
        this.previousFilterQ.copy(this.filterQ);
        this.accelQ = new Quaternion();
        this.isOrientationInitialized = false;
        this.estimatedGravity = new Vector3();
        this.measuredGravity = new Vector3();
        this.gyroIntegralQ = new Quaternion();
      }
      ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
        this.currentAccelMeasurement.set(vector, timestampS);
      };
      ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
        this.currentGyroMeasurement.set(vector, timestampS);
        var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
        if (isTimestampDeltaValid(deltaT)) {
          this.run_();
        }
        this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
      };
      ComplementaryFilter.prototype.run_ = function() {
        if (!this.isOrientationInitialized) {
          this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
          this.previousFilterQ.copy(this.accelQ);
          this.isOrientationInitialized = true;
          return;
        }
        var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;
        var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
        this.gyroIntegralQ.multiply(gyroDeltaQ);
        this.filterQ.copy(this.previousFilterQ);
        this.filterQ.multiply(gyroDeltaQ);
        var invFilterQ = new Quaternion();
        invFilterQ.copy(this.filterQ);
        invFilterQ.inverse();
        this.estimatedGravity.set(0, 0, -1);
        this.estimatedGravity.applyQuaternion(invFilterQ);
        this.estimatedGravity.normalize();
        this.measuredGravity.copy(this.currentAccelMeasurement.sample);
        this.measuredGravity.normalize();
        var deltaQ = new Quaternion();
        deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
        deltaQ.inverse();
        if (this.isDebug) {
          console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", radToDeg * getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
        }
        var targetQ = new Quaternion();
        targetQ.copy(this.filterQ);
        targetQ.multiply(deltaQ);
        this.filterQ.slerp(targetQ, 1 - this.kFilter);
        this.previousFilterQ.copy(this.filterQ);
      };
      ComplementaryFilter.prototype.getOrientation = function() {
        return this.filterQ;
      };
      ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
        var normAccel = new Vector3();
        normAccel.copy(accel);
        normAccel.normalize();
        var quat = new Quaternion();
        quat.setFromUnitVectors(new Vector3(0, 0, -1), normAccel);
        quat.inverse();
        return quat;
      };
      ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
        var quat = new Quaternion();
        var axis = new Vector3();
        axis.copy(gyro);
        axis.normalize();
        quat.setFromAxisAngle(axis, gyro.length() * dt);
        return quat;
      };
      function PosePredictor(predictionTimeS, isDebug) {
        this.predictionTimeS = predictionTimeS;
        this.isDebug = isDebug;
        this.previousQ = new Quaternion();
        this.previousTimestampS = null;
        this.deltaQ = new Quaternion();
        this.outQ = new Quaternion();
      }
      PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
        if (!this.previousTimestampS) {
          this.previousQ.copy(currentQ);
          this.previousTimestampS = timestampS;
          return currentQ;
        }
        var axis = new Vector3();
        axis.copy(gyro);
        axis.normalize();
        var angularSpeed = gyro.length();
        if (angularSpeed < degToRad * 20) {
          if (this.isDebug) {
            console.log("Moving slowly, at %s deg/s: no prediction", (radToDeg * angularSpeed).toFixed(1));
          }
          this.outQ.copy(currentQ);
          this.previousQ.copy(currentQ);
          return this.outQ;
        }
        var predictAngle = angularSpeed * this.predictionTimeS;
        this.deltaQ.setFromAxisAngle(axis, predictAngle);
        this.outQ.copy(this.previousQ);
        this.outQ.multiply(this.deltaQ);
        this.previousQ.copy(currentQ);
        this.previousTimestampS = timestampS;
        return this.outQ;
      };
      function FusionPoseSensor(kFilter, predictionTime, yawOnly, isDebug) {
        this.yawOnly = yawOnly;
        this.accelerometer = new Vector3();
        this.gyroscope = new Vector3();
        this.filter = new ComplementaryFilter(kFilter, isDebug);
        this.posePredictor = new PosePredictor(predictionTime, isDebug);
        this.isFirefoxAndroid = isFirefoxAndroid();
        this.isIOS = isIOS();
        var chromeVersion = getChromeVersion();
        this.isDeviceMotionInRadians = !this.isIOS && chromeVersion && chromeVersion < 66;
        this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion() || isSafariWithoutDeviceMotion();
        this.filterToWorldQ = new Quaternion();
        if (isIOS()) {
          this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2);
        } else {
          this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
        }
        this.inverseWorldToScreenQ = new Quaternion();
        this.worldToScreenQ = new Quaternion();
        this.originalPoseAdjustQ = new Quaternion();
        this.originalPoseAdjustQ.setFromAxisAngle(new Vector3(0, 0, 1), -window.orientation * Math.PI / 180);
        this.setScreenTransform_();
        if (isLandscapeMode()) {
          this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
        }
        this.resetQ = new Quaternion();
        this.orientationOut_ = new Float32Array(4);
        this.start();
      }
      FusionPoseSensor.prototype.getPosition = function() {
        return null;
      };
      FusionPoseSensor.prototype.getOrientation = function() {
        var orientation = void 0;
        if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
          this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
            var z = new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), 0);
            var y = new Quaternion();
            if (window.orientation === -90) {
              y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / -2);
            } else {
              y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
            }
            return z.multiply(y);
          }();
          this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
            var q = new Quaternion();
            q.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
            return q;
          }();
          orientation = this._deviceOrientationQ;
          var out = new Quaternion();
          out.copy(orientation);
          out.multiply(this.deviceOrientationFilterToWorldQ);
          out.multiply(this.resetQ);
          out.multiply(this.worldToScreenQ);
          out.multiplyQuaternions(this.deviceOrientationFixQ, out);
          if (this.yawOnly) {
            out.x = 0;
            out.z = 0;
            out.normalize();
          }
          this.orientationOut_[0] = out.x;
          this.orientationOut_[1] = out.y;
          this.orientationOut_[2] = out.z;
          this.orientationOut_[3] = out.w;
          return this.orientationOut_;
        } else {
          var filterOrientation = this.filter.getOrientation();
          orientation = this.posePredictor.getPrediction(filterOrientation, this.gyroscope, this.previousTimestampS);
        }
        var out = new Quaternion();
        out.copy(this.filterToWorldQ);
        out.multiply(this.resetQ);
        out.multiply(orientation);
        out.multiply(this.worldToScreenQ);
        if (this.yawOnly) {
          out.x = 0;
          out.z = 0;
          out.normalize();
        }
        this.orientationOut_[0] = out.x;
        this.orientationOut_[1] = out.y;
        this.orientationOut_[2] = out.z;
        this.orientationOut_[3] = out.w;
        return this.orientationOut_;
      };
      FusionPoseSensor.prototype.resetPose = function() {
        this.resetQ.copy(this.filter.getOrientation());
        this.resetQ.x = 0;
        this.resetQ.y = 0;
        this.resetQ.z *= -1;
        this.resetQ.normalize();
        if (isLandscapeMode()) {
          this.resetQ.multiply(this.inverseWorldToScreenQ);
        }
        this.resetQ.multiply(this.originalPoseAdjustQ);
      };
      FusionPoseSensor.prototype.onDeviceOrientation_ = function(e) {
        this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion();
        var alpha = e.alpha, beta = e.beta, gamma = e.gamma;
        alpha = (alpha || 0) * Math.PI / 180;
        beta = (beta || 0) * Math.PI / 180;
        gamma = (gamma || 0) * Math.PI / 180;
        this._deviceOrientationQ.setFromEulerYXZ(beta, alpha, -gamma);
      };
      FusionPoseSensor.prototype.onDeviceMotion_ = function(deviceMotion) {
        this.updateDeviceMotion_(deviceMotion);
      };
      FusionPoseSensor.prototype.updateDeviceMotion_ = function(deviceMotion) {
        var accGravity = deviceMotion.accelerationIncludingGravity;
        var rotRate = deviceMotion.rotationRate;
        var timestampS = deviceMotion.timeStamp / 1e3;
        var deltaS = timestampS - this.previousTimestampS;
        if (deltaS < 0) {
          warnOnce("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion");
          this.previousTimestampS = timestampS;
          return;
        } else if (deltaS <= MIN_TIMESTEP || deltaS > MAX_TIMESTEP) {
          warnOnce("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range.");
          this.previousTimestampS = timestampS;
          return;
        }
        this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
        if (rotRate) {
          if (isR7()) {
            this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma);
          } else {
            this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
          }
          if (!this.isDeviceMotionInRadians) {
            this.gyroscope.multiplyScalar(Math.PI / 180);
          }
          this.filter.addGyroMeasurement(this.gyroscope, timestampS);
        }
        this.filter.addAccelMeasurement(this.accelerometer, timestampS);
        this.previousTimestampS = timestampS;
      };
      FusionPoseSensor.prototype.onOrientationChange_ = function(screenOrientation) {
        this.setScreenTransform_();
      };
      FusionPoseSensor.prototype.onMessage_ = function(event) {
        var message = event.data;
        if (!message || !message.type) {
          return;
        }
        var type = message.type.toLowerCase();
        if (type !== "devicemotion") {
          return;
        }
        this.updateDeviceMotion_(message.deviceMotionEvent);
      };
      FusionPoseSensor.prototype.setScreenTransform_ = function() {
        this.worldToScreenQ.set(0, 0, 0, 1);
        switch (window.orientation) {
          case 0:
            break;
          case 90:
            this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), -Math.PI / 2);
            break;
          case -90:
            this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
            break;
          case 180:
            break;
        }
        this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
        this.inverseWorldToScreenQ.inverse();
      };
      FusionPoseSensor.prototype.start = function() {
        this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
        this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
        this.onMessageCallback_ = this.onMessage_.bind(this);
        this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this);
        if (isIOS() && isInsideCrossOriginIFrame()) {
          window.addEventListener("message", this.onMessageCallback_);
        }
        window.addEventListener("orientationchange", this.onOrientationChangeCallback_);
        if (this.isWithoutDeviceMotion) {
          window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_);
        } else {
          window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
        }
      };
      FusionPoseSensor.prototype.stop = function() {
        window.removeEventListener("devicemotion", this.onDeviceMotionCallback_);
        window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_);
        window.removeEventListener("orientationchange", this.onOrientationChangeCallback_);
        window.removeEventListener("message", this.onMessageCallback_);
      };
      var SENSOR_FREQUENCY = 60;
      var X_AXIS = new Vector3(1, 0, 0);
      var Z_AXIS = new Vector3(0, 0, 1);
      var SENSOR_TO_VR = new Quaternion();
      SENSOR_TO_VR.setFromAxisAngle(X_AXIS, -Math.PI / 2);
      SENSOR_TO_VR.multiply(new Quaternion().setFromAxisAngle(Z_AXIS, Math.PI / 2));
      var PoseSensor = function() {
        function PoseSensor2(config2) {
          classCallCheck(this, PoseSensor2);
          this.config = config2;
          this.sensor = null;
          this.fusionSensor = null;
          this._out = new Float32Array(4);
          this.api = null;
          this.errors = [];
          this._sensorQ = new Quaternion();
          this._outQ = new Quaternion();
          this._onSensorRead = this._onSensorRead.bind(this);
          this._onSensorError = this._onSensorError.bind(this);
          this.init();
        }
        createClass(PoseSensor2, [{
          key: "init",
          value: function init() {
            var sensor = null;
            try {
              sensor = new RelativeOrientationSensor({
                frequency: SENSOR_FREQUENCY,
                referenceFrame: "screen"
              });
              sensor.addEventListener("error", this._onSensorError);
            } catch (error) {
              this.errors.push(error);
              if (error.name === "SecurityError") {
                console.error("Cannot construct sensors due to the Feature Policy");
                console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.');
                this.useDeviceMotion();
              } else if (error.name === "ReferenceError") {
                this.useDeviceMotion();
              } else {
                console.error(error);
              }
            }
            if (sensor) {
              this.api = "sensor";
              this.sensor = sensor;
              this.sensor.addEventListener("reading", this._onSensorRead);
              this.sensor.start();
            }
          }
        }, {
          key: "useDeviceMotion",
          value: function useDeviceMotion() {
            this.api = "devicemotion";
            this.fusionSensor = new FusionPoseSensor(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG);
            if (this.sensor) {
              this.sensor.removeEventListener("reading", this._onSensorRead);
              this.sensor.removeEventListener("error", this._onSensorError);
              this.sensor = null;
            }
          }
        }, {
          key: "getOrientation",
          value: function getOrientation() {
            if (this.fusionSensor) {
              return this.fusionSensor.getOrientation();
            }
            if (!this.sensor || !this.sensor.quaternion) {
              this._out[0] = this._out[1] = this._out[2] = 0;
              this._out[3] = 1;
              return this._out;
            }
            var q = this.sensor.quaternion;
            this._sensorQ.set(q[0], q[1], q[2], q[3]);
            var out = this._outQ;
            out.copy(SENSOR_TO_VR);
            out.multiply(this._sensorQ);
            if (this.config.YAW_ONLY) {
              out.x = out.z = 0;
              out.normalize();
            }
            this._out[0] = out.x;
            this._out[1] = out.y;
            this._out[2] = out.z;
            this._out[3] = out.w;
            return this._out;
          }
        }, {
          key: "_onSensorError",
          value: function _onSensorError(event) {
            this.errors.push(event.error);
            if (event.error.name === "NotAllowedError") {
              console.error("Permission to access sensor was denied");
            } else if (event.error.name === "NotReadableError") {
              console.error("Sensor could not be read");
            } else {
              console.error(event.error);
            }
            this.useDeviceMotion();
          }
        }, {
          key: "_onSensorRead",
          value: function _onSensorRead() {
          }
        }]);
        return PoseSensor2;
      }();
      var rotateInstructionsAsset = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
      function RotateInstructions() {
        this.loadIcon_();
        var overlay = document.createElement("div");
        var s = overlay.style;
        s.position = "fixed";
        s.top = 0;
        s.right = 0;
        s.bottom = 0;
        s.left = 0;
        s.backgroundColor = "gray";
        s.fontFamily = "sans-serif";
        s.zIndex = 1e6;
        var img = document.createElement("img");
        img.src = this.icon;
        var s = img.style;
        s.marginLeft = "25%";
        s.marginTop = "25%";
        s.width = "50%";
        overlay.appendChild(img);
        var text = document.createElement("div");
        var s = text.style;
        s.textAlign = "center";
        s.fontSize = "16px";
        s.lineHeight = "24px";
        s.margin = "24px 25%";
        s.width = "50%";
        text.innerHTML = "Place your phone into your Cardboard viewer.";
        overlay.appendChild(text);
        var snackbar = document.createElement("div");
        var s = snackbar.style;
        s.backgroundColor = "#CFD8DC";
        s.position = "fixed";
        s.bottom = 0;
        s.width = "100%";
        s.height = "48px";
        s.padding = "14px 24px";
        s.boxSizing = "border-box";
        s.color = "#656A6B";
        overlay.appendChild(snackbar);
        var snackbarText = document.createElement("div");
        snackbarText.style.float = "left";
        snackbarText.innerHTML = "No Cardboard viewer?";
        var snackbarButton = document.createElement("a");
        snackbarButton.href = "https://www.google.com/get/cardboard/get-cardboard/";
        snackbarButton.innerHTML = "get one";
        snackbarButton.target = "_blank";
        var s = snackbarButton.style;
        s.float = "right";
        s.fontWeight = 600;
        s.textTransform = "uppercase";
        s.borderLeft = "1px solid gray";
        s.paddingLeft = "24px";
        s.textDecoration = "none";
        s.color = "#656A6B";
        snackbar.appendChild(snackbarText);
        snackbar.appendChild(snackbarButton);
        this.overlay = overlay;
        this.text = text;
        this.hide();
      }
      RotateInstructions.prototype.show = function(parent) {
        if (!parent && !this.overlay.parentElement) {
          document.body.appendChild(this.overlay);
        } else if (parent) {
          if (this.overlay.parentElement && this.overlay.parentElement != parent)
            this.overlay.parentElement.removeChild(this.overlay);
          parent.appendChild(this.overlay);
        }
        this.overlay.style.display = "block";
        var img = this.overlay.querySelector("img");
        var s = img.style;
        if (isLandscapeMode()) {
          s.width = "20%";
          s.marginLeft = "40%";
          s.marginTop = "3%";
        } else {
          s.width = "50%";
          s.marginLeft = "25%";
          s.marginTop = "25%";
        }
      };
      RotateInstructions.prototype.hide = function() {
        this.overlay.style.display = "none";
      };
      RotateInstructions.prototype.showTemporarily = function(ms, parent) {
        this.show(parent);
        this.timer = setTimeout(this.hide.bind(this), ms);
      };
      RotateInstructions.prototype.disableShowTemporarily = function() {
        clearTimeout(this.timer);
      };
      RotateInstructions.prototype.update = function() {
        this.disableShowTemporarily();
        if (!isLandscapeMode() && isMobile2()) {
          this.show();
        } else {
          this.hide();
        }
      };
      RotateInstructions.prototype.loadIcon_ = function() {
        this.icon = dataUri("image/svg+xml", rotateInstructionsAsset);
      };
      var DEFAULT_VIEWER = "CardboardV1";
      var VIEWER_KEY = "WEBVR_CARDBOARD_VIEWER";
      var CLASS_NAME = "webvr-polyfill-viewer-selector";
      function ViewerSelector(defaultViewer) {
        try {
          this.selectedKey = localStorage.getItem(VIEWER_KEY);
        } catch (error) {
          console.error("Failed to load viewer profile: %s", error);
        }
        if (!this.selectedKey) {
          this.selectedKey = defaultViewer || DEFAULT_VIEWER;
        }
        this.dialog = this.createDialog_(DeviceInfo.Viewers);
        this.root = null;
        this.onChangeCallbacks_ = [];
      }
      ViewerSelector.prototype.show = function(root) {
        this.root = root;
        root.appendChild(this.dialog);
        var selected = this.dialog.querySelector("#" + this.selectedKey);
        selected.checked = true;
        this.dialog.style.display = "block";
      };
      ViewerSelector.prototype.hide = function() {
        if (this.root && this.root.contains(this.dialog)) {
          this.root.removeChild(this.dialog);
        }
        this.dialog.style.display = "none";
      };
      ViewerSelector.prototype.getCurrentViewer = function() {
        return DeviceInfo.Viewers[this.selectedKey];
      };
      ViewerSelector.prototype.getSelectedKey_ = function() {
        var input = this.dialog.querySelector("input[name=field]:checked");
        if (input) {
          return input.id;
        }
        return null;
      };
      ViewerSelector.prototype.onChange = function(cb) {
        this.onChangeCallbacks_.push(cb);
      };
      ViewerSelector.prototype.fireOnChange_ = function(viewer) {
        for (var i = 0; i < this.onChangeCallbacks_.length; i++) {
          this.onChangeCallbacks_[i](viewer);
        }
      };
      ViewerSelector.prototype.onSave_ = function() {
        this.selectedKey = this.getSelectedKey_();
        if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
          console.error("ViewerSelector.onSave_: this should never happen!");
          return;
        }
        this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);
        try {
          localStorage.setItem(VIEWER_KEY, this.selectedKey);
        } catch (error) {
          console.error("Failed to save viewer profile: %s", error);
        }
        this.hide();
      };
      ViewerSelector.prototype.createDialog_ = function(options) {
        var container = document.createElement("div");
        container.classList.add(CLASS_NAME);
        container.style.display = "none";
        var overlay = document.createElement("div");
        var s = overlay.style;
        s.position = "fixed";
        s.left = 0;
        s.top = 0;
        s.width = "100%";
        s.height = "100%";
        s.background = "rgba(0, 0, 0, 0.3)";
        overlay.addEventListener("click", this.hide.bind(this));
        var width = 280;
        var dialog = document.createElement("div");
        var s = dialog.style;
        s.boxSizing = "border-box";
        s.position = "fixed";
        s.top = "24px";
        s.left = "50%";
        s.marginLeft = -width / 2 + "px";
        s.width = width + "px";
        s.padding = "24px";
        s.overflow = "hidden";
        s.background = "#fafafa";
        s.fontFamily = "'Roboto', sans-serif";
        s.boxShadow = "0px 5px 20px #666";
        dialog.appendChild(this.createH1_("Select your viewer"));
        for (var id in options) {
          dialog.appendChild(this.createChoice_(id, options[id].label));
        }
        dialog.appendChild(this.createButton_("Save", this.onSave_.bind(this)));
        container.appendChild(overlay);
        container.appendChild(dialog);
        return container;
      };
      ViewerSelector.prototype.createH1_ = function(name) {
        var h1 = document.createElement("h1");
        var s = h1.style;
        s.color = "black";
        s.fontSize = "20px";
        s.fontWeight = "bold";
        s.marginTop = 0;
        s.marginBottom = "24px";
        h1.innerHTML = name;
        return h1;
      };
      ViewerSelector.prototype.createChoice_ = function(id, name) {
        var div2 = document.createElement("div");
        div2.style.marginTop = "8px";
        div2.style.color = "black";
        var input = document.createElement("input");
        input.style.fontSize = "30px";
        input.setAttribute("id", id);
        input.setAttribute("type", "radio");
        input.setAttribute("value", id);
        input.setAttribute("name", "field");
        var label = document.createElement("label");
        label.style.marginLeft = "4px";
        label.setAttribute("for", id);
        label.innerHTML = name;
        div2.appendChild(input);
        div2.appendChild(label);
        return div2;
      };
      ViewerSelector.prototype.createButton_ = function(label, onclick) {
        var button = document.createElement("button");
        button.innerHTML = label;
        var s = button.style;
        s.float = "right";
        s.textTransform = "uppercase";
        s.color = "#1094f7";
        s.fontSize = "14px";
        s.letterSpacing = 0;
        s.border = 0;
        s.background = "none";
        s.marginTop = "16px";
        button.addEventListener("click", onclick);
        return button;
      };
      var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function unwrapExports(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      function createCommonjsModule(fn, module2) {
        return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
      }
      var NoSleep = createCommonjsModule(function(module2, exports2) {
        (function webpackUniversalModuleDefinition(root, factory) {
          module2.exports = factory();
        })(commonjsGlobal, function() {
          return function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId]) {
                return installedModules[moduleId].exports;
              }
              var module3 = installedModules[moduleId] = {
                i: moduleId,
                l: false,
                exports: {}
              };
              modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
              module3.l = true;
              return module3.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports3, name, getter) {
              if (!__webpack_require__.o(exports3, name)) {
                Object.defineProperty(exports3, name, {
                  configurable: false,
                  enumerable: true,
                  get: getter
                });
              }
            };
            __webpack_require__.n = function(module3) {
              var getter = module3 && module3.__esModule ? function getDefault() {
                return module3["default"];
              } : function getModuleExports() {
                return module3;
              };
              __webpack_require__.d(getter, "a", getter);
              return getter;
            };
            __webpack_require__.o = function(object, property3) {
              return Object.prototype.hasOwnProperty.call(object, property3);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 0);
          }([
            function(module3, exports3, __webpack_require__) {
              "use strict";
              var _createClass = function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var mediaFile = __webpack_require__(1);
              var oldIOS = typeof navigator !== "undefined" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream;
              var NoSleep2 = function() {
                function NoSleep3() {
                  _classCallCheck(this, NoSleep3);
                  if (oldIOS) {
                    this.noSleepTimer = null;
                  } else {
                    this.noSleepVideo = document.createElement("video");
                    this.noSleepVideo.setAttribute("playsinline", "");
                    this.noSleepVideo.setAttribute("src", mediaFile);
                    this.noSleepVideo.addEventListener("timeupdate", function(e) {
                      if (this.noSleepVideo.currentTime > 0.5) {
                        this.noSleepVideo.currentTime = Math.random();
                      }
                    }.bind(this));
                  }
                }
                _createClass(NoSleep3, [{
                  key: "enable",
                  value: function enable() {
                    if (oldIOS) {
                      this.disable();
                      this.noSleepTimer = window.setInterval(function() {
                        window.location.href = "/";
                        window.setTimeout(window.stop, 0);
                      }, 15e3);
                    } else {
                      this.noSleepVideo.play();
                    }
                  }
                }, {
                  key: "disable",
                  value: function disable() {
                    if (oldIOS) {
                      if (this.noSleepTimer) {
                        window.clearInterval(this.noSleepTimer);
                        this.noSleepTimer = null;
                      }
                    } else {
                      this.noSleepVideo.pause();
                    }
                  }
                }]);
                return NoSleep3;
              }();
              module3.exports = NoSleep2;
            },
            function(module3, exports3, __webpack_require__) {
              "use strict";
              module3.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
            }
          ]);
        });
      });
      var NoSleep$1 = unwrapExports(NoSleep);
      var nextDisplayId = 1e3;
      var defaultLeftBounds = [0, 0, 0.5, 1];
      var defaultRightBounds = [0.5, 0, 0.5, 1];
      var raf = window.requestAnimationFrame;
      var caf = window.cancelAnimationFrame;
      function VRFrameData() {
        this.leftProjectionMatrix = new Float32Array(16);
        this.leftViewMatrix = new Float32Array(16);
        this.rightProjectionMatrix = new Float32Array(16);
        this.rightViewMatrix = new Float32Array(16);
        this.pose = null;
      }
      function VRDisplayCapabilities(config2) {
        Object.defineProperties(this, {
          hasPosition: {
            writable: false,
            enumerable: true,
            value: config2.hasPosition
          },
          hasExternalDisplay: {
            writable: false,
            enumerable: true,
            value: config2.hasExternalDisplay
          },
          canPresent: {
            writable: false,
            enumerable: true,
            value: config2.canPresent
          },
          maxLayers: {
            writable: false,
            enumerable: true,
            value: config2.maxLayers
          },
          hasOrientation: {
            enumerable: true,
            get: function get() {
              deprecateWarning("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData");
              return config2.hasOrientation;
            }
          }
        });
      }
      function VRDisplay(config2) {
        config2 = config2 || {};
        var USE_WAKELOCK = "wakelock" in config2 ? config2.wakelock : true;
        this.isPolyfilled = true;
        this.displayId = nextDisplayId++;
        this.displayName = "";
        this.depthNear = 0.01;
        this.depthFar = 1e4;
        this.isPresenting = false;
        Object.defineProperty(this, "isConnected", {
          get: function get() {
            deprecateWarning("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay");
            return false;
          }
        });
        this.capabilities = new VRDisplayCapabilities({
          hasPosition: false,
          hasOrientation: false,
          hasExternalDisplay: false,
          canPresent: false,
          maxLayers: 1
        });
        this.stageParameters = null;
        this.waitingForPresent_ = false;
        this.layer_ = null;
        this.originalParent_ = null;
        this.fullscreenElement_ = null;
        this.fullscreenWrapper_ = null;
        this.fullscreenElementCachedStyle_ = null;
        this.fullscreenEventTarget_ = null;
        this.fullscreenChangeHandler_ = null;
        this.fullscreenErrorHandler_ = null;
        if (USE_WAKELOCK && isMobile2()) {
          this.wakelock_ = new NoSleep$1();
        }
      }
      VRDisplay.prototype.getFrameData = function(frameData) {
        return frameDataFromPose(frameData, this._getPose(), this);
      };
      VRDisplay.prototype.getPose = function() {
        deprecateWarning("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData");
        return this._getPose();
      };
      VRDisplay.prototype.resetPose = function() {
        deprecateWarning("VRDisplay.prototype.resetPose");
        return this._resetPose();
      };
      VRDisplay.prototype.getImmediatePose = function() {
        deprecateWarning("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData");
        return this._getPose();
      };
      VRDisplay.prototype.requestAnimationFrame = function(callback) {
        return raf(callback);
      };
      VRDisplay.prototype.cancelAnimationFrame = function(id) {
        return caf(id);
      };
      VRDisplay.prototype.wrapForFullscreen = function(element) {
        if (isIOS()) {
          return element;
        }
        if (!this.fullscreenWrapper_) {
          this.fullscreenWrapper_ = document.createElement("div");
          var cssProperties = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
          this.fullscreenWrapper_.setAttribute("style", cssProperties.join("; ") + ";");
          this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
        }
        if (this.fullscreenElement_ == element) {
          return this.fullscreenWrapper_;
        }
        if (this.fullscreenElement_) {
          if (this.originalParent_) {
            this.originalParent_.appendChild(this.fullscreenElement_);
          } else {
            this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_);
          }
        }
        this.fullscreenElement_ = element;
        this.originalParent_ = element.parentElement;
        if (!this.originalParent_) {
          document.body.appendChild(element);
        }
        if (!this.fullscreenWrapper_.parentElement) {
          var parent = this.fullscreenElement_.parentElement;
          parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
          parent.removeChild(this.fullscreenElement_);
        }
        this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
        this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
        var self2 = this;
        function applyFullscreenElementStyle() {
          if (!self2.fullscreenElement_) {
            return;
          }
          var cssProperties2 = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
          self2.fullscreenElement_.setAttribute("style", cssProperties2.join("; ") + ";");
        }
        applyFullscreenElementStyle();
        return this.fullscreenWrapper_;
      };
      VRDisplay.prototype.removeFullscreenWrapper = function() {
        if (!this.fullscreenElement_) {
          return;
        }
        var element = this.fullscreenElement_;
        if (this.fullscreenElementCachedStyle_) {
          element.setAttribute("style", this.fullscreenElementCachedStyle_);
        } else {
          element.removeAttribute("style");
        }
        this.fullscreenElement_ = null;
        this.fullscreenElementCachedStyle_ = null;
        var parent = this.fullscreenWrapper_.parentElement;
        this.fullscreenWrapper_.removeChild(element);
        if (this.originalParent_ === parent) {
          parent.insertBefore(element, this.fullscreenWrapper_);
        } else if (this.originalParent_) {
          this.originalParent_.appendChild(element);
        }
        parent.removeChild(this.fullscreenWrapper_);
        return element;
      };
      VRDisplay.prototype.requestPresent = function(layers) {
        var wasPresenting = this.isPresenting;
        var self2 = this;
        if (!(layers instanceof Array)) {
          deprecateWarning("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument");
          layers = [layers];
        }
        return new Promise(function(resolve, reject) {
          if (!self2.capabilities.canPresent) {
            reject(new Error("VRDisplay is not capable of presenting."));
            return;
          }
          if (layers.length == 0 || layers.length > self2.capabilities.maxLayers) {
            reject(new Error("Invalid number of layers."));
            return;
          }
          var incomingLayer = layers[0];
          if (!incomingLayer.source) {
            resolve();
            return;
          }
          var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
          var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
          if (wasPresenting) {
            var layer = self2.layer_;
            if (layer.source !== incomingLayer.source) {
              layer.source = incomingLayer.source;
            }
            for (var i = 0; i < 4; i++) {
              layer.leftBounds[i] = leftBounds[i];
              layer.rightBounds[i] = rightBounds[i];
            }
            self2.wrapForFullscreen(self2.layer_.source);
            self2.updatePresent_();
            resolve();
            return;
          }
          self2.layer_ = {
            predistorted: incomingLayer.predistorted,
            source: incomingLayer.source,
            leftBounds: leftBounds.slice(0),
            rightBounds: rightBounds.slice(0)
          };
          self2.waitingForPresent_ = false;
          if (self2.layer_ && self2.layer_.source) {
            var fullscreenElement = self2.wrapForFullscreen(self2.layer_.source);
            var onFullscreenChange = function onFullscreenChange2() {
              var actualFullscreenElement = getFullscreenElement();
              self2.isPresenting = fullscreenElement === actualFullscreenElement;
              if (self2.isPresenting) {
                if (screen.orientation && screen.orientation.lock) {
                  screen.orientation.lock("landscape-primary").catch(function(error) {
                    console.error("screen.orientation.lock() failed due to", error.message);
                  });
                }
                self2.waitingForPresent_ = false;
                self2.beginPresent_();
                resolve();
              } else {
                if (screen.orientation && screen.orientation.unlock) {
                  screen.orientation.unlock();
                }
                self2.removeFullscreenWrapper();
                self2.disableWakeLock();
                self2.endPresent_();
                self2.removeFullscreenListeners_();
              }
              self2.fireVRDisplayPresentChange_();
            };
            var onFullscreenError = function onFullscreenError2() {
              if (!self2.waitingForPresent_) {
                return;
              }
              self2.removeFullscreenWrapper();
              self2.removeFullscreenListeners_();
              self2.disableWakeLock();
              self2.waitingForPresent_ = false;
              self2.isPresenting = false;
              reject(new Error("Unable to present."));
            };
            self2.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError);
            if (requestFullscreen(fullscreenElement)) {
              self2.enableWakeLock();
              self2.waitingForPresent_ = true;
            } else if (isIOS() || isWebViewAndroid()) {
              self2.enableWakeLock();
              self2.isPresenting = true;
              self2.beginPresent_();
              self2.fireVRDisplayPresentChange_();
              resolve();
            }
          }
          if (!self2.waitingForPresent_ && !isIOS()) {
            exitFullscreen();
            reject(new Error("Unable to present."));
          }
        });
      };
      VRDisplay.prototype.exitPresent = function() {
        var wasPresenting = this.isPresenting;
        var self2 = this;
        this.isPresenting = false;
        this.layer_ = null;
        this.disableWakeLock();
        return new Promise(function(resolve, reject) {
          if (wasPresenting) {
            if (!exitFullscreen() && isIOS()) {
              self2.endPresent_();
              self2.fireVRDisplayPresentChange_();
            }
            if (isWebViewAndroid()) {
              self2.removeFullscreenWrapper();
              self2.removeFullscreenListeners_();
              self2.endPresent_();
              self2.fireVRDisplayPresentChange_();
            }
            resolve();
          } else {
            reject(new Error("Was not presenting to VRDisplay."));
          }
        });
      };
      VRDisplay.prototype.getLayers = function() {
        if (this.layer_) {
          return [this.layer_];
        }
        return [];
      };
      VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
        var event = new CustomEvent("vrdisplaypresentchange", { detail: { display: this } });
        window.dispatchEvent(event);
      };
      VRDisplay.prototype.fireVRDisplayConnect_ = function() {
        var event = new CustomEvent("vrdisplayconnect", { detail: { display: this } });
        window.dispatchEvent(event);
      };
      VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
        this.removeFullscreenListeners_();
        this.fullscreenEventTarget_ = element;
        this.fullscreenChangeHandler_ = changeHandler;
        this.fullscreenErrorHandler_ = errorHandler;
        if (changeHandler) {
          if (document.fullscreenEnabled) {
            element.addEventListener("fullscreenchange", changeHandler, false);
          } else if (document.webkitFullscreenEnabled) {
            element.addEventListener("webkitfullscreenchange", changeHandler, false);
          } else if (document.mozFullScreenEnabled) {
            document.addEventListener("mozfullscreenchange", changeHandler, false);
          } else if (document.msFullscreenEnabled) {
            element.addEventListener("msfullscreenchange", changeHandler, false);
          }
        }
        if (errorHandler) {
          if (document.fullscreenEnabled) {
            element.addEventListener("fullscreenerror", errorHandler, false);
          } else if (document.webkitFullscreenEnabled) {
            element.addEventListener("webkitfullscreenerror", errorHandler, false);
          } else if (document.mozFullScreenEnabled) {
            document.addEventListener("mozfullscreenerror", errorHandler, false);
          } else if (document.msFullscreenEnabled) {
            element.addEventListener("msfullscreenerror", errorHandler, false);
          }
        }
      };
      VRDisplay.prototype.removeFullscreenListeners_ = function() {
        if (!this.fullscreenEventTarget_)
          return;
        var element = this.fullscreenEventTarget_;
        if (this.fullscreenChangeHandler_) {
          var changeHandler = this.fullscreenChangeHandler_;
          element.removeEventListener("fullscreenchange", changeHandler, false);
          element.removeEventListener("webkitfullscreenchange", changeHandler, false);
          document.removeEventListener("mozfullscreenchange", changeHandler, false);
          element.removeEventListener("msfullscreenchange", changeHandler, false);
        }
        if (this.fullscreenErrorHandler_) {
          var errorHandler = this.fullscreenErrorHandler_;
          element.removeEventListener("fullscreenerror", errorHandler, false);
          element.removeEventListener("webkitfullscreenerror", errorHandler, false);
          document.removeEventListener("mozfullscreenerror", errorHandler, false);
          element.removeEventListener("msfullscreenerror", errorHandler, false);
        }
        this.fullscreenEventTarget_ = null;
        this.fullscreenChangeHandler_ = null;
        this.fullscreenErrorHandler_ = null;
      };
      VRDisplay.prototype.enableWakeLock = function() {
        if (this.wakelock_) {
          this.wakelock_.enable();
        }
      };
      VRDisplay.prototype.disableWakeLock = function() {
        if (this.wakelock_) {
          this.wakelock_.disable();
        }
      };
      VRDisplay.prototype.beginPresent_ = function() {
      };
      VRDisplay.prototype.endPresent_ = function() {
      };
      VRDisplay.prototype.submitFrame = function(pose) {
      };
      VRDisplay.prototype.getEyeParameters = function(whichEye) {
        return null;
      };
      var config = {
        ADDITIONAL_VIEWERS: [],
        DEFAULT_VIEWER: "",
        MOBILE_WAKE_LOCK: true,
        DEBUG: false,
        DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
        K_FILTER: 0.98,
        PREDICTION_TIME_S: 0.04,
        CARDBOARD_UI_DISABLED: false,
        ROTATE_INSTRUCTIONS_DISABLED: false,
        YAW_ONLY: false,
        BUFFER_SCALE: 0.5,
        DIRTY_SUBMIT_FRAME_BINDINGS: false
      };
      var Eye = {
        LEFT: "left",
        RIGHT: "right"
      };
      function CardboardVRDisplay2(config$$1) {
        var defaults = extend({}, config);
        config$$1 = extend(defaults, config$$1 || {});
        VRDisplay.call(this, {
          wakelock: config$$1.MOBILE_WAKE_LOCK
        });
        this.config = config$$1;
        this.displayName = "Cardboard VRDisplay";
        this.capabilities = new VRDisplayCapabilities({
          hasPosition: false,
          hasOrientation: true,
          hasExternalDisplay: false,
          canPresent: true,
          maxLayers: 1
        });
        this.stageParameters = null;
        this.bufferScale_ = this.config.BUFFER_SCALE;
        this.poseSensor_ = new PoseSensor(this.config);
        this.distorter_ = null;
        this.cardboardUI_ = null;
        this.dpdb_ = new Dpdb(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this));
        this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams(), config$$1.ADDITIONAL_VIEWERS);
        this.viewerSelector_ = new ViewerSelector(config$$1.DEFAULT_VIEWER);
        this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));
        this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
        if (!this.config.ROTATE_INSTRUCTIONS_DISABLED) {
          this.rotateInstructions_ = new RotateInstructions();
        }
        if (isIOS()) {
          window.addEventListener("resize", this.onResize_.bind(this));
        }
      }
      CardboardVRDisplay2.prototype = Object.create(VRDisplay.prototype);
      CardboardVRDisplay2.prototype._getPose = function() {
        return {
          position: null,
          orientation: this.poseSensor_.getOrientation(),
          linearVelocity: null,
          linearAcceleration: null,
          angularVelocity: null,
          angularAcceleration: null
        };
      };
      CardboardVRDisplay2.prototype._resetPose = function() {
        if (this.poseSensor_.resetPose) {
          this.poseSensor_.resetPose();
        }
      };
      CardboardVRDisplay2.prototype._getFieldOfView = function(whichEye) {
        var fieldOfView;
        if (whichEye == Eye.LEFT) {
          fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
        } else if (whichEye == Eye.RIGHT) {
          fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
        } else {
          console.error("Invalid eye provided: %s", whichEye);
          return null;
        }
        return fieldOfView;
      };
      CardboardVRDisplay2.prototype._getEyeOffset = function(whichEye) {
        var offset2;
        if (whichEye == Eye.LEFT) {
          offset2 = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
        } else if (whichEye == Eye.RIGHT) {
          offset2 = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
        } else {
          console.error("Invalid eye provided: %s", whichEye);
          return null;
        }
        return offset2;
      };
      CardboardVRDisplay2.prototype.getEyeParameters = function(whichEye) {
        var offset2 = this._getEyeOffset(whichEye);
        var fieldOfView = this._getFieldOfView(whichEye);
        var eyeParams = {
          offset: offset2,
          renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
          renderHeight: this.deviceInfo_.device.height * this.bufferScale_
        };
        Object.defineProperty(eyeParams, "fieldOfView", {
          enumerable: true,
          get: function get() {
            deprecateWarning("VRFieldOfView", "VRFrameData's projection matrices");
            return fieldOfView;
          }
        });
        return eyeParams;
      };
      CardboardVRDisplay2.prototype.onDeviceParamsUpdated_ = function(newParams) {
        if (this.config.DEBUG) {
          console.log("DPDB reported that device params were updated.");
        }
        this.deviceInfo_.updateDeviceParams(newParams);
        if (this.distorter_) {
          this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }
      };
      CardboardVRDisplay2.prototype.updateBounds_ = function() {
        if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
          this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
        }
      };
      CardboardVRDisplay2.prototype.beginPresent_ = function() {
        var gl = this.layer_.source.getContext("webgl");
        if (!gl)
          gl = this.layer_.source.getContext("experimental-webgl");
        if (!gl)
          gl = this.layer_.source.getContext("webgl2");
        if (!gl)
          return;
        if (this.layer_.predistorted) {
          if (!this.config.CARDBOARD_UI_DISABLED) {
            gl.canvas.width = getScreenWidth() * this.bufferScale_;
            gl.canvas.height = getScreenHeight() * this.bufferScale_;
            this.cardboardUI_ = new CardboardUI(gl);
          }
        } else {
          if (!this.config.CARDBOARD_UI_DISABLED) {
            this.cardboardUI_ = new CardboardUI(gl);
          }
          this.distorter_ = new CardboardDistorter(gl, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS);
          this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }
        if (this.cardboardUI_) {
          this.cardboardUI_.listen(function(e) {
            this.viewerSelector_.show(this.layer_.source.parentElement);
            e.stopPropagation();
            e.preventDefault();
          }.bind(this), function(e) {
            this.exitPresent();
            e.stopPropagation();
            e.preventDefault();
          }.bind(this));
        }
        if (this.rotateInstructions_) {
          if (isLandscapeMode() && isMobile2()) {
            this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement);
          } else {
            this.rotateInstructions_.update();
          }
        }
        this.orientationHandler = this.onOrientationChange_.bind(this);
        window.addEventListener("orientationchange", this.orientationHandler);
        this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
        window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
        this.fireVRDisplayDeviceParamsChange_();
      };
      CardboardVRDisplay2.prototype.endPresent_ = function() {
        if (this.distorter_) {
          this.distorter_.destroy();
          this.distorter_ = null;
        }
        if (this.cardboardUI_) {
          this.cardboardUI_.destroy();
          this.cardboardUI_ = null;
        }
        if (this.rotateInstructions_) {
          this.rotateInstructions_.hide();
        }
        this.viewerSelector_.hide();
        window.removeEventListener("orientationchange", this.orientationHandler);
        window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
      };
      CardboardVRDisplay2.prototype.updatePresent_ = function() {
        this.endPresent_();
        this.beginPresent_();
      };
      CardboardVRDisplay2.prototype.submitFrame = function(pose) {
        if (this.distorter_) {
          this.updateBounds_();
          this.distorter_.submitFrame();
        } else if (this.cardboardUI_ && this.layer_) {
          var gl = this.layer_.source.getContext("webgl");
          if (!gl)
            gl = this.layer_.source.getContext("experimental-webgl");
          if (!gl)
            gl = this.layer_.source.getContext("webgl2");
          var canvas2 = gl.canvas;
          if (canvas2.width != this.lastWidth || canvas2.height != this.lastHeight) {
            this.cardboardUI_.onResize();
          }
          this.lastWidth = canvas2.width;
          this.lastHeight = canvas2.height;
          this.cardboardUI_.render();
        }
      };
      CardboardVRDisplay2.prototype.onOrientationChange_ = function(e) {
        this.viewerSelector_.hide();
        if (this.rotateInstructions_) {
          this.rotateInstructions_.update();
        }
        this.onResize_();
      };
      CardboardVRDisplay2.prototype.onResize_ = function(e) {
        if (this.layer_) {
          var gl = this.layer_.source.getContext("webgl");
          if (!gl)
            gl = this.layer_.source.getContext("experimental-webgl");
          if (!gl)
            gl = this.layer_.source.getContext("webgl2");
          var cssProperties = [
            "position: absolute",
            "top: 0",
            "left: 0",
            "width: 100vw",
            "height: 100vh",
            "border: 0",
            "margin: 0",
            "padding: 0px",
            "box-sizing: content-box"
          ];
          gl.canvas.setAttribute("style", cssProperties.join("; ") + ";");
          safariCssSizeWorkaround(gl.canvas);
        }
      };
      CardboardVRDisplay2.prototype.onViewerChanged_ = function(viewer) {
        this.deviceInfo_.setViewer(viewer);
        if (this.distorter_) {
          this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }
        this.fireVRDisplayDeviceParamsChange_();
      };
      CardboardVRDisplay2.prototype.fireVRDisplayDeviceParamsChange_ = function() {
        var event = new CustomEvent("vrdisplaydeviceparamschange", {
          detail: {
            vrdisplay: this,
            deviceInfo: this.deviceInfo_
          }
        });
        window.dispatchEvent(event);
      };
      CardboardVRDisplay2.VRFrameData = VRFrameData;
      CardboardVRDisplay2.VRDisplay = VRDisplay;
      return CardboardVRDisplay2;
    });
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices/XRDevice.js
var XRDevice_exports = {};
__export(XRDevice_exports, {
  default: () => XRDevice
});
var XRDevice;
var init_XRDevice = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices/XRDevice.js"() {
    init_EventTarget();
    init_XRReferenceSpace();
    XRDevice = class extends EventTarget2 {
      /**
       * Takes a VRDisplay object from the WebVR 1.1 spec.
       *
       * @param {Object} global
       */
      constructor(global2) {
        super();
        this.global = global2;
        this.onWindowResize = this.onWindowResize.bind(this);
        this.global.window.addEventListener("resize", this.onWindowResize);
        this.environmentBlendMode = "opaque";
      }
      /**
       * Called when a XRSession has a `baseLayer` property set.
       *
       * @param {number} sessionId
       * @param {XRWebGLLayer} layer
       */
      onBaseLayerSet(sessionId, layer) {
        throw new Error("Not implemented");
      }
      /**
       * @param {XRSessionMode} mode
       * @return {boolean}
       */
      isSessionSupported(mode) {
        throw new Error("Not implemented");
      }
      /**
       * @param {string} featureDescriptor
       * @return {boolean}
       */
      isFeatureSupported(featureDescriptor) {
        throw new Error("Not implemented");
      }
      /**
       * Returns a promise if creating a session is successful.
       * Usually used to set up presentation in the device.
       *
       * @param {XRSessionMode} mode
       * @param {Set<string>} enabledFeatures
       * @return {Promise<number>}
       */
      async requestSession(mode, enabledFeatures) {
        throw new Error("Not implemented");
      }
      /**
       * @return {Function}
       */
      requestAnimationFrame(callback) {
        throw new Error("Not implemented");
      }
      /**
       * @param {number} sessionId
       */
      onFrameStart(sessionId) {
        throw new Error("Not implemented");
      }
      /**
       * @param {number} sessionId
       */
      onFrameEnd(sessionId) {
        throw new Error("Not implemented");
      }
      /**
       * @param {number} sessionId
       * @param {XRReferenceSpaceType} type
       * @return {boolean}
       */
      doesSessionSupportReferenceSpace(sessionId, type) {
        throw new Error("Not implemented");
      }
      /**
       * @return {Object?}
       */
      requestStageBounds() {
        throw new Error("Not implemented");
      }
      /**
       * Returns a promise resolving to a transform if XRDevice
       * can support frame of reference and provides its own values.
       * Can resolve to `undefined` if the polyfilled API can provide
       * a default. Rejects if this XRDevice cannot
       * support the frame of reference.
       *
       * @param {XRFrameOfReferenceType} type
       * @param {XRFrameOfReferenceOptions} options
       * @return {Promise<XRFrameOfReference>}
       */
      async requestFrameOfReferenceTransform(type, options) {
        return void 0;
      }
      /**
       * @param {number} handle
       */
      cancelAnimationFrame(handle) {
        throw new Error("Not implemented");
      }
      /**
       * @param {number} sessionId
       */
      endSession(sessionId) {
        throw new Error("Not implemented");
      }
      /**
       * Allows the XRDevice to override the XRSession's view spaces.
       *
       * @param {XRSessionMode} mode
       * @return {Array<XRSpace> | undefined}
       */
      getViewSpaces(mode) {
        return void 0;
      }
      /**
       * Takes a XREye and a target to apply properties of
       * `x`, `y`, `width` and `height` on. Returns a boolean
       * indicating if it successfully was able to populate
       * target's values.
       *
       * @param {number} sessionId
       * @param {XREye} eye
       * @param {XRWebGLLayer} layer
       * @param {Object?} target
       * @param {number} viewIndex
       * @return {boolean}
       */
      getViewport(sessionId, eye, layer, target, viewIndex) {
        throw new Error("Not implemented");
      }
      /**
       * @param {XREye} eye
       * @param {number} viewIndex
       * @return {Float32Array}
       */
      getProjectionMatrix(eye, viewIndex) {
        throw new Error("Not implemented");
      }
      /**
       * Get model matrix unaffected by frame of reference.
       *
       * @return {Float32Array}
       */
      getBasePoseMatrix() {
        throw new Error("Not implemented");
      }
      /**
       * Get view matrix unaffected by frame of reference.
       *
       * @param {XREye} eye
       * @return {Float32Array}
       */
      getBaseViewMatrix(eye) {
        throw new Error("Not implemented");
      }
      /**
       * Get a list of input sources.
       *
       * @return {Array<XRInputSource>}
       */
      getInputSources() {
        throw new Error("Not implemented");
      }
      /**
       * Get the current pose of an input source.
       *
       * @param {XRInputSource} inputSource
       * @param {XRCoordinateSystem} coordinateSystem
       * @param {String} poseType
       * @return {XRPose}
       */
      getInputPose(inputSource, coordinateSystem, poseType) {
        throw new Error("Not implemented");
      }
      /**
       * Called on window resize.
       */
      onWindowResize() {
        this.onWindowResize();
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadMappings.js
var daydream, viveFocus, oculusGo, oculusTouch, openVr, samsungGearVR, samsungOdyssey, windowsMixedReality, GamepadMappings, GamepadMappings_default;
var init_GamepadMappings = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadMappings.js"() {
    daydream = {
      mapping: "",
      profiles: ["google-daydream", "generic-trigger-touchpad"],
      buttons: {
        length: 3,
        0: null,
        1: null,
        2: 0
      }
    };
    viveFocus = {
      mapping: "xr-standard",
      profiles: ["htc-vive-focus", "generic-trigger-touchpad"],
      buttons: {
        length: 3,
        0: 1,
        1: null,
        2: 0
      }
    };
    oculusGo = {
      mapping: "xr-standard",
      profiles: ["oculus-go", "generic-trigger-touchpad"],
      buttons: {
        length: 3,
        0: 1,
        1: null,
        2: 0
      },
      // Grip adjustments determined experimentally.
      gripTransform: {
        orientation: [Math.PI * 0.11, 0, 0, 1]
      }
    };
    oculusTouch = {
      mapping: "xr-standard",
      displayProfiles: {
        "Oculus Quest": ["oculus-touch-v2", "oculus-touch", "generic-trigger-squeeze-thumbstick"]
      },
      profiles: ["oculus-touch", "generic-trigger-squeeze-thumbstick"],
      axes: {
        length: 4,
        0: null,
        1: null,
        2: 0,
        3: 1
      },
      buttons: {
        length: 7,
        0: 1,
        1: 2,
        2: null,
        3: 0,
        4: 3,
        5: 4,
        6: null
      },
      // Grip adjustments determined experimentally.
      gripTransform: {
        position: [0, -0.02, 0.04, 1],
        orientation: [Math.PI * 0.11, 0, 0, 1]
      }
    };
    openVr = {
      mapping: "xr-standard",
      profiles: ["htc-vive", "generic-trigger-squeeze-touchpad"],
      displayProfiles: {
        "HTC Vive": ["htc-vive", "generic-trigger-squeeze-touchpad"],
        "HTC Vive DVT": ["htc-vive", "generic-trigger-squeeze-touchpad"],
        "Valve Index": ["valve-index", "generic-trigger-squeeze-touchpad-thumbstick"]
      },
      buttons: {
        length: 3,
        0: 1,
        1: 2,
        2: 0
      },
      // Transform adjustments determined experimentally.
      gripTransform: {
        position: [0, 0, 0.05, 1]
      },
      targetRayTransform: {
        orientation: [Math.PI * -0.08, 0, 0, 1]
      },
      userAgentOverrides: {
        "Firefox": {
          axes: {
            invert: [1, 3]
          }
        }
      }
    };
    samsungGearVR = {
      mapping: "xr-standard",
      profiles: ["samsung-gearvr", "generic-trigger-touchpad"],
      buttons: {
        length: 3,
        0: 1,
        1: null,
        2: 0
      },
      gripTransform: {
        orientation: [Math.PI * 0.11, 0, 0, 1]
      }
    };
    samsungOdyssey = {
      mapping: "xr-standard",
      profiles: ["samsung-odyssey", "microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
      buttons: {
        length: 4,
        0: 1,
        // index finger trigger
        1: 0,
        // pressable joystick
        2: 2,
        // grip trigger
        3: 4
        // pressable touchpad
      },
      // Grip adjustments determined experimentally.
      gripTransform: {
        position: [0, -0.02, 0.04, 1],
        orientation: [Math.PI * 0.11, 0, 0, 1]
      }
    };
    windowsMixedReality = {
      mapping: "xr-standard",
      profiles: ["microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
      buttons: {
        length: 4,
        0: 1,
        // index finger trigger
        1: 0,
        // pressable joystick
        2: 2,
        // grip trigger
        3: 4
        // pressable touchpad
      },
      // Grip adjustments determined experimentally.
      gripTransform: {
        position: [0, -0.02, 0.04, 1],
        orientation: [Math.PI * 0.11, 0, 0, 1]
      }
    };
    GamepadMappings = {
      "Daydream Controller": daydream,
      "Gear VR Controller": samsungGearVR,
      "HTC Vive Focus Controller": viveFocus,
      "Oculus Go Controller": oculusGo,
      "Oculus Touch (Right)": oculusTouch,
      "Oculus Touch (Left)": oculusTouch,
      "OpenVR Gamepad": openVr,
      "Spatial Controller (Spatial Interaction Source) 045E-065A": windowsMixedReality,
      "Spatial Controller (Spatial Interaction Source) 045E-065D": samsungOdyssey,
      "Windows Mixed Reality (Right)": windowsMixedReality,
      "Windows Mixed Reality (Left)": windowsMixedReality
    };
    GamepadMappings_default = GamepadMappings;
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/lib/OrientationArmModel.js
function eulerFromQuaternion(out, q, order) {
  function clamp(value, min2, max2) {
    return value < min2 ? min2 : value > max2 ? max2 : value;
  }
  var sqx = q[0] * q[0];
  var sqy = q[1] * q[1];
  var sqz = q[2] * q[2];
  var sqw = q[3] * q[3];
  if (order === "XYZ") {
    out[0] = Math.atan2(2 * (q[0] * q[3] - q[1] * q[2]), sqw - sqx - sqy + sqz);
    out[1] = Math.asin(clamp(2 * (q[0] * q[2] + q[1] * q[3]), -1, 1));
    out[2] = Math.atan2(2 * (q[2] * q[3] - q[0] * q[1]), sqw + sqx - sqy - sqz);
  } else if (order === "YXZ") {
    out[0] = Math.asin(clamp(2 * (q[0] * q[3] - q[1] * q[2]), -1, 1));
    out[1] = Math.atan2(2 * (q[0] * q[2] + q[1] * q[3]), sqw - sqx - sqy + sqz);
    out[2] = Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), sqw - sqx + sqy - sqz);
  } else if (order === "ZXY") {
    out[0] = Math.asin(clamp(2 * (q[0] * q[3] + q[1] * q[2]), -1, 1));
    out[1] = Math.atan2(2 * (q[1] * q[3] - q[2] * q[0]), sqw - sqx - sqy + sqz);
    out[2] = Math.atan2(2 * (q[2] * q[3] - q[0] * q[1]), sqw - sqx + sqy - sqz);
  } else if (order === "ZYX") {
    out[0] = Math.atan2(2 * (q[0] * q[3] + q[2] * q[1]), sqw - sqx - sqy + sqz);
    out[1] = Math.asin(clamp(2 * (q[1] * q[3] - q[0] * q[2]), -1, 1));
    out[2] = Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), sqw + sqx - sqy - sqz);
  } else if (order === "YZX") {
    out[0] = Math.atan2(2 * (q[0] * q[3] - q[2] * q[1]), sqw - sqx + sqy - sqz);
    out[1] = Math.atan2(2 * (q[1] * q[3] - q[0] * q[2]), sqw + sqx - sqy - sqz);
    out[2] = Math.asin(clamp(2 * (q[0] * q[1] + q[2] * q[3]), -1, 1));
  } else if (order === "XZY") {
    out[0] = Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), sqw - sqx + sqy - sqz);
    out[1] = Math.atan2(2 * (q[0] * q[2] + q[1] * q[3]), sqw + sqx - sqy - sqz);
    out[2] = Math.asin(clamp(2 * (q[2] * q[3] - q[0] * q[1]), -1, 1));
  } else {
    console.log("No order given for quaternion to euler conversion.");
    return;
  }
}
var HEAD_ELBOW_OFFSET_RIGHTHANDED, HEAD_ELBOW_OFFSET_LEFTHANDED, ELBOW_WRIST_OFFSET, WRIST_CONTROLLER_OFFSET, ARM_EXTENSION_OFFSET, ELBOW_BEND_RATIO, EXTENSION_RATIO_WEIGHT, MIN_ANGULAR_SPEED, MIN_ANGLE_DELTA, MIN_EXTENSION_COS, MAX_EXTENSION_COS, RAD_TO_DEG, OrientationArmModel;
var init_OrientationArmModel = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/lib/OrientationArmModel.js"() {
    init_now();
    init_mat4();
    init_vec3();
    init_quat();
    HEAD_ELBOW_OFFSET_RIGHTHANDED = fromValues6(0.155, -0.465, -0.15);
    HEAD_ELBOW_OFFSET_LEFTHANDED = fromValues6(-0.155, -0.465, -0.15);
    ELBOW_WRIST_OFFSET = fromValues6(0, 0, -0.25);
    WRIST_CONTROLLER_OFFSET = fromValues6(0, 0, 0.05);
    ARM_EXTENSION_OFFSET = fromValues6(-0.08, 0.14, 0.08);
    ELBOW_BEND_RATIO = 0.4;
    EXTENSION_RATIO_WEIGHT = 0.4;
    MIN_ANGULAR_SPEED = 0.61;
    MIN_ANGLE_DELTA = 0.175;
    MIN_EXTENSION_COS = 0.12;
    MAX_EXTENSION_COS = 0.87;
    RAD_TO_DEG = 180 / Math.PI;
    OrientationArmModel = class {
      constructor() {
        this.hand = "right";
        this.headElbowOffset = HEAD_ELBOW_OFFSET_RIGHTHANDED;
        this.controllerQ = create11();
        this.lastControllerQ = create11();
        this.headQ = create11();
        this.headPos = create8();
        this.elbowPos = create8();
        this.wristPos = create8();
        this.time = null;
        this.lastTime = null;
        this.rootQ = create11();
        this.position = create8();
      }
      setHandedness(hand) {
        if (this.hand != hand) {
          this.hand = hand;
          if (this.hand == "left") {
            this.headElbowOffset = HEAD_ELBOW_OFFSET_LEFTHANDED;
          } else {
            this.headElbowOffset = HEAD_ELBOW_OFFSET_RIGHTHANDED;
          }
        }
      }
      /**
       * Called on a RAF.
       */
      update(controllerOrientation, headPoseMatrix) {
        this.time = now_default();
        if (controllerOrientation) {
          copy9(this.lastControllerQ, this.controllerQ);
          copy9(this.controllerQ, controllerOrientation);
        }
        if (headPoseMatrix) {
          getTranslation3(this.headPos, headPoseMatrix);
          getRotation2(this.headQ, headPoseMatrix);
        }
        let headYawQ = this.getHeadYawOrientation_();
        let angleDelta = this.quatAngle_(this.lastControllerQ, this.controllerQ);
        let timeDelta = (this.time - this.lastTime) / 1e3;
        let controllerAngularSpeed = angleDelta / timeDelta;
        if (controllerAngularSpeed > MIN_ANGULAR_SPEED) {
          slerp2(
            this.rootQ,
            this.rootQ,
            headYawQ,
            Math.min(angleDelta / MIN_ANGLE_DELTA, 1)
          );
        } else {
          copy9(this.rootQ, headYawQ);
        }
        let controllerForward = fromValues6(0, 0, -1);
        transformQuat2(controllerForward, controllerForward, this.controllerQ);
        let controllerDotY = dot5(controllerForward, [0, 1, 0]);
        let extensionRatio = this.clamp_(
          (controllerDotY - MIN_EXTENSION_COS) / MAX_EXTENSION_COS,
          0,
          1
        );
        let controllerCameraQ = clone8(this.rootQ);
        invert5(controllerCameraQ, controllerCameraQ);
        multiply6(controllerCameraQ, controllerCameraQ, this.controllerQ);
        let elbowPos = this.elbowPos;
        copy7(elbowPos, this.headPos);
        add6(elbowPos, elbowPos, this.headElbowOffset);
        let elbowOffset = clone6(ARM_EXTENSION_OFFSET);
        scale6(elbowOffset, elbowOffset, extensionRatio);
        add6(elbowPos, elbowPos, elbowOffset);
        let totalAngle = this.quatAngle_(controllerCameraQ, create11());
        let totalAngleDeg = totalAngle * RAD_TO_DEG;
        let lerpSuppression = 1 - Math.pow(totalAngleDeg / 180, 4);
        sssss;
        let elbowRatio = ELBOW_BEND_RATIO;
        let wristRatio = 1 - ELBOW_BEND_RATIO;
        let lerpValue = lerpSuppression * (elbowRatio + wristRatio * extensionRatio * EXTENSION_RATIO_WEIGHT);
        let wristQ = create11();
        slerp2(wristQ, wristQ, controllerCameraQ, lerpValue);
        let invWristQ = invert5(create11(), wristQ);
        let elbowQ = clone8(controllerCameraQ);
        multiply6(elbowQ, elbowQ, invWristQ);
        let wristPos = this.wristPos;
        copy7(wristPos, WRIST_CONTROLLER_OFFSET);
        transformQuat2(wristPos, wristPos, wristQ);
        add6(wristPos, wristPos, ELBOW_WRIST_OFFSET);
        transformQuat2(wristPos, wristPos, elbowQ);
        add6(wristPos, wristPos, elbowPos);
        let offset2 = clone6(ARM_EXTENSION_OFFSET);
        scale6(offset2, offset2, extensionRatio);
        add6(this.position, this.wristPos, offset2);
        transformQuat2(this.position, this.position, this.rootQ);
        this.lastTime = this.time;
      }
      /**
       * Returns the position calculated by the model.
       */
      getPosition() {
        return this.position;
      }
      getHeadYawOrientation_() {
        let headEuler = create8();
        eulerFromQuaternion(headEuler, this.headQ, "YXZ");
        let destinationQ = fromEuler2(create11(), 0, headEuler[1] * RAD_TO_DEG, 0);
        return destinationQ;
      }
      clamp_(value, min2, max2) {
        return Math.min(Math.max(value, min2), max2);
      }
      quatAngle_(q1, q2) {
        let vec1 = [0, 0, -1];
        let vec2 = [0, 0, -1];
        transformQuat2(vec1, vec1, q1);
        transformQuat2(vec2, vec2, q2);
        return angle2(vec1, vec2);
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadXRInputSource.js
var PRIVATE19, PLACEHOLDER_BUTTON, XRRemappedGamepad, GamepadXRInputSource;
var init_GamepadXRInputSource = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices/GamepadXRInputSource.js"() {
    init_GamepadMappings();
    init_XRInputSource();
    init_OrientationArmModel();
    init_mat4();
    init_vec3();
    init_quat();
    PRIVATE19 = Symbol("@@webxr-polyfill/XRRemappedGamepad");
    PLACEHOLDER_BUTTON = { pressed: false, touched: false, value: 0 };
    Object.freeze(PLACEHOLDER_BUTTON);
    XRRemappedGamepad = class {
      constructor(gamepad, display, map) {
        if (!map) {
          map = {};
        }
        if (map.userAgentOverrides) {
          for (let agent in map.userAgentOverrides) {
            if (navigator.userAgent.includes(agent)) {
              let override = map.userAgentOverrides[agent];
              for (let key in override) {
                if (key in map) {
                  Object.assign(map[key], override[key]);
                } else {
                  map[key] = override[key];
                }
              }
              break;
            }
          }
        }
        let axes = new Array(map.axes && map.axes.length ? map.axes.length : gamepad.axes.length);
        let buttons = new Array(map.buttons && map.buttons.length ? map.buttons.length : gamepad.buttons.length);
        let gripTransform = null;
        if (map.gripTransform) {
          let orientation = map.gripTransform.orientation || [0, 0, 0, 1];
          gripTransform = create7();
          fromRotationTranslation3(
            gripTransform,
            normalize7(orientation, orientation),
            map.gripTransform.position || [0, 0, 0]
          );
        }
        let targetRayTransform = null;
        if (map.targetRayTransform) {
          let orientation = map.targetRayTransform.orientation || [0, 0, 0, 1];
          targetRayTransform = create7();
          fromRotationTranslation3(
            targetRayTransform,
            normalize7(orientation, orientation),
            map.targetRayTransform.position || [0, 0, 0]
          );
        }
        let profiles = map.profiles;
        if (map.displayProfiles) {
          if (display.displayName in map.displayProfiles) {
            profiles = map.displayProfiles[display.displayName];
          }
        }
        this[PRIVATE19] = {
          gamepad,
          map,
          profiles: profiles || [gamepad.id],
          mapping: map.mapping || gamepad.mapping,
          axes,
          buttons,
          gripTransform,
          targetRayTransform
        };
        this._update();
      }
      _update() {
        let gamepad = this[PRIVATE19].gamepad;
        let map = this[PRIVATE19].map;
        let axes = this[PRIVATE19].axes;
        for (let i = 0; i < axes.length; ++i) {
          if (map.axes && i in map.axes) {
            if (map.axes[i] === null) {
              axes[i] = 0;
            } else {
              axes[i] = gamepad.axes[map.axes[i]];
            }
          } else {
            axes[i] = gamepad.axes[i];
          }
        }
        if (map.axes && map.axes.invert) {
          for (let axis of map.axes.invert) {
            if (axis < axes.length) {
              axes[axis] *= -1;
            }
          }
        }
        let buttons = this[PRIVATE19].buttons;
        for (let i = 0; i < buttons.length; ++i) {
          if (map.buttons && i in map.buttons) {
            if (map.buttons[i] === null) {
              buttons[i] = PLACEHOLDER_BUTTON;
            } else {
              buttons[i] = gamepad.buttons[map.buttons[i]];
            }
          } else {
            buttons[i] = gamepad.buttons[i];
          }
        }
      }
      get id() {
        return "";
      }
      get _profiles() {
        return this[PRIVATE19].profiles;
      }
      get index() {
        return -1;
      }
      get connected() {
        return this[PRIVATE19].gamepad.connected;
      }
      get timestamp() {
        return this[PRIVATE19].gamepad.timestamp;
      }
      get mapping() {
        return this[PRIVATE19].mapping;
      }
      get axes() {
        return this[PRIVATE19].axes;
      }
      get buttons() {
        return this[PRIVATE19].buttons;
      }
      // Non-standard extension
      get hapticActuators() {
        return this[PRIVATE19].gamepad.hapticActuators;
      }
    };
    GamepadXRInputSource = class {
      constructor(polyfill, display, primaryButtonIndex = 0, primarySqueezeButtonIndex = -1) {
        this.polyfill = polyfill;
        this.display = display;
        this.nativeGamepad = null;
        this.gamepad = null;
        this.inputSource = new XRInputSource(this);
        this.lastPosition = create8();
        this.emulatedPosition = false;
        this.basePoseMatrix = create7();
        this.outputMatrix = create7();
        this.primaryButtonIndex = primaryButtonIndex;
        this.primaryActionPressed = false;
        this.primarySqueezeButtonIndex = primarySqueezeButtonIndex;
        this.primarySqueezeActionPressed = false;
        this.handedness = "";
        this.targetRayMode = "gaze";
        this.armModel = null;
      }
      get profiles() {
        return this.gamepad ? this.gamepad._profiles : [];
      }
      updateFromGamepad(gamepad) {
        if (this.nativeGamepad !== gamepad) {
          this.nativeGamepad = gamepad;
          if (gamepad) {
            this.gamepad = new XRRemappedGamepad(gamepad, this.display, GamepadMappings_default[gamepad.id]);
          } else {
            this.gamepad = null;
          }
        }
        this.handedness = gamepad.hand === "" ? "none" : gamepad.hand;
        if (this.gamepad) {
          this.gamepad._update();
        }
        if (gamepad.pose) {
          this.targetRayMode = "tracked-pointer";
          this.emulatedPosition = !gamepad.pose.hasPosition;
        } else if (gamepad.hand === "") {
          this.targetRayMode = "gaze";
          this.emulatedPosition = false;
        }
      }
      updateBasePoseMatrix() {
        if (this.nativeGamepad && this.nativeGamepad.pose) {
          let pose = this.nativeGamepad.pose;
          let position = pose.position;
          let orientation = pose.orientation;
          if (!position && !orientation) {
            return;
          }
          if (!position) {
            if (!pose.hasPosition) {
              if (!this.armModel) {
                this.armModel = new OrientationArmModel();
              }
              this.armModel.setHandedness(this.nativeGamepad.hand);
              this.armModel.update(orientation, this.polyfill.getBasePoseMatrix());
              position = this.armModel.getPosition();
            } else {
              position = this.lastPosition;
            }
          } else {
            this.lastPosition[0] = position[0];
            this.lastPosition[1] = position[1];
            this.lastPosition[2] = position[2];
          }
          fromRotationTranslation3(this.basePoseMatrix, orientation, position);
        } else {
          copy6(this.basePoseMatrix, this.polyfill.getBasePoseMatrix());
        }
        return this.basePoseMatrix;
      }
      /**
       * @param {XRReferenceSpace} coordinateSystem
       * @param {string} poseType
       * @return {XRPose?}
       */
      getXRPose(coordinateSystem, poseType) {
        this.updateBasePoseMatrix();
        switch (poseType) {
          case "target-ray":
            coordinateSystem._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
            if (this.gamepad && this.gamepad[PRIVATE19].targetRayTransform) {
              multiply5(this.outputMatrix, this.outputMatrix, this.gamepad[PRIVATE19].targetRayTransform);
            }
            break;
          case "grip":
            if (!this.nativeGamepad || !this.nativeGamepad.pose) {
              return null;
            }
            coordinateSystem._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
            if (this.gamepad && this.gamepad[PRIVATE19].gripTransform) {
              multiply5(this.outputMatrix, this.outputMatrix, this.gamepad[PRIVATE19].gripTransform);
            }
            break;
          default:
            return null;
        }
        coordinateSystem._adjustForOriginOffset(this.outputMatrix);
        return new XRPose(new XRRigidTransform(this.outputMatrix), this.emulatedPosition);
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices/WebVRDevice.js
var PRIVATE20, TEST_ENV, EXTRA_PRESENTATION_ATTRIBUTES, PRIMARY_BUTTON_MAP, SESSION_ID, Session, WebVRDevice;
var init_WebVRDevice = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices/WebVRDevice.js"() {
    init_mat4();
    init_XRDevice();
    init_GamepadXRInputSource();
    init_utils();
    PRIVATE20 = Symbol("@@webxr-polyfill/WebVRDevice");
    TEST_ENV = false;
    EXTRA_PRESENTATION_ATTRIBUTES = {
      // Non-standard attribute to enable running at the native device refresh rate
      // on the Oculus Go.
      highRefreshRate: true
    };
    PRIMARY_BUTTON_MAP = {
      oculus: 1,
      openvr: 1,
      "spatial controller (spatial interaction source)": 1
    };
    SESSION_ID = 0;
    Session = class {
      constructor(mode, enabledFeatures, polyfillOptions = {}) {
        this.mode = mode;
        this.enabledFeatures = enabledFeatures;
        this.outputContext = null;
        this.immersive = mode == "immersive-vr" || mode == "immersive-ar";
        this.ended = null;
        this.baseLayer = null;
        this.id = ++SESSION_ID;
        this.modifiedCanvasLayer = false;
        if (this.outputContext && !TEST_ENV) {
          const renderContextType = polyfillOptions.renderContextType || "2d";
          this.renderContext = this.outputContext.canvas.getContext(renderContextType);
        }
      }
    };
    WebVRDevice = class extends XRDevice {
      /**
       * Takes a VRDisplay instance and a VRFrameData
       * constructor from the WebVR 1.1 spec.
       *
       * @param {VRDisplay} display
       * @param {VRFrameData} VRFrameData
       */
      constructor(global2, display) {
        const { canPresent } = display.capabilities;
        super(global2);
        this.display = display;
        this.frame = new global2.VRFrameData();
        this.sessions = /* @__PURE__ */ new Map();
        this.immersiveSession = null;
        this.canPresent = canPresent;
        this.baseModelMatrix = create7();
        this.gamepadInputSources = {};
        this.tempVec3 = new Float32Array(3);
        this.onVRDisplayPresentChange = this.onVRDisplayPresentChange.bind(this);
        global2.window.addEventListener("vrdisplaypresentchange", this.onVRDisplayPresentChange);
        this.CAN_USE_GAMEPAD = global2.navigator && "getGamepads" in global2.navigator;
        this.HAS_BITMAP_SUPPORT = isImageBitmapSupported(global2);
      }
      /**
       * @return {number}
       */
      get depthNear() {
        return this.display.depthNear;
      }
      /**
       * @param {number}
       */
      set depthNear(val) {
        this.display.depthNear = val;
      }
      /**
       * @return {number}
       */
      get depthFar() {
        return this.display.depthFar;
      }
      /**
       * @param {number}
       */
      set depthFar(val) {
        this.display.depthFar = val;
      }
      /**
       * Called when a XRSession has a `baseLayer` property set.
       *
       * @param {number} sessionId
       * @param {XRWebGLLayer} layer
       */
      onBaseLayerSet(sessionId, layer) {
        const session = this.sessions.get(sessionId);
        const canvas2 = layer.context.canvas;
        if (session.immersive) {
          const left = this.display.getEyeParameters("left");
          const right = this.display.getEyeParameters("right");
          canvas2.width = Math.max(left.renderWidth, right.renderWidth) * 2;
          canvas2.height = Math.max(left.renderHeight, right.renderHeight);
          this.display.requestPresent([{
            source: canvas2,
            attributes: EXTRA_PRESENTATION_ATTRIBUTES
          }]).then(() => {
            if (!TEST_ENV && !this.global.document.body.contains(canvas2)) {
              session.modifiedCanvasLayer = true;
              this.global.document.body.appendChild(canvas2);
              applyCanvasStylesForMinimalRendering(canvas2);
            }
            session.baseLayer = layer;
          });
        } else {
          session.baseLayer = layer;
        }
      }
      /**
       * If a 1.1 VRDisplay cannot present, it could be a 6DOF device
       * that doesn't have its own way to present, but used in magic
       * window mode. So in WebXR lingo, this cannot support an
       * "immersive" session.
       *
       * @param {XRSessionMode} mode
       * @return {boolean}
       */
      isSessionSupported(mode) {
        if (mode == "immersive-ar") {
          return false;
        }
        if (mode == "immersive-vr" && this.canPresent === false) {
          return false;
        }
        return true;
      }
      /**
       * @param {string} featureDescriptor
       * @return {boolean}
       */
      isFeatureSupported(featureDescriptor) {
        switch (featureDescriptor) {
          case "viewer":
            return true;
          case "local":
            return true;
          case "local-floor":
            return true;
          case "bounded":
            return false;
          case "unbounded":
            return false;
          default:
            return false;
        }
      }
      /**
       * Returns a promise of a session ID if creating a session is successful.
       * Usually used to set up presentation in the device.
       * We can't start presenting in a 1.1 device until we have a canvas
       * layer, so use a dummy layer until `onBaseLayerSet` is called.
       * May reject if session is not supported, or if an error is thrown
       * when calling `requestPresent`.
       *
       * @param {XRSessionMode} mode
       * @param {Set<string>} enabledFeatures
       * @return {Promise<number>}
       */
      async requestSession(mode, enabledFeatures) {
        if (!this.isSessionSupported(mode)) {
          return Promise.reject();
        }
        let immersive = mode == "immersive-vr";
        if (immersive) {
          const canvas2 = this.global.document.createElement("canvas");
          if (!TEST_ENV) {
            const ctx = canvas2.getContext("webgl");
          }
          await this.display.requestPresent([{
            source: canvas2,
            attributes: EXTRA_PRESENTATION_ATTRIBUTES
          }]);
        }
        const session = new Session(mode, enabledFeatures, {
          renderContextType: this.HAS_BITMAP_SUPPORT ? "bitmaprenderer" : "2d"
        });
        this.sessions.set(session.id, session);
        if (immersive) {
          this.immersiveSession = session;
          this.dispatchEvent("@@webxr-polyfill/vr-present-start", session.id);
        }
        return Promise.resolve(session.id);
      }
      /**
       * @return {Function}
       */
      requestAnimationFrame(callback) {
        return this.display.requestAnimationFrame(callback);
      }
      getPrimaryButtonIndex(gamepad) {
        let primaryButton = 0;
        let name = gamepad.id.toLowerCase();
        for (let key in PRIMARY_BUTTON_MAP) {
          if (name.includes(key)) {
            primaryButton = PRIMARY_BUTTON_MAP[key];
            break;
          }
        }
        return Math.min(primaryButton, gamepad.buttons.length - 1);
      }
      onFrameStart(sessionId, renderState) {
        this.display.depthNear = renderState.depthNear;
        this.display.depthFar = renderState.depthFar;
        this.display.getFrameData(this.frame);
        const session = this.sessions.get(sessionId);
        if (session.immersive && this.CAN_USE_GAMEPAD) {
          let prevInputSources = this.gamepadInputSources;
          this.gamepadInputSources = {};
          let gamepads = this.global.navigator.getGamepads();
          for (let i = 0; i < gamepads.length; ++i) {
            let gamepad = gamepads[i];
            if (gamepad && gamepad.displayId > 0) {
              let inputSourceImpl = prevInputSources[i];
              if (!inputSourceImpl) {
                inputSourceImpl = new GamepadXRInputSource(this, this.display, this.getPrimaryButtonIndex(gamepad));
              }
              inputSourceImpl.updateFromGamepad(gamepad);
              this.gamepadInputSources[i] = inputSourceImpl;
              if (inputSourceImpl.primaryButtonIndex != -1) {
                let primaryActionPressed = gamepad.buttons[inputSourceImpl.primaryButtonIndex].pressed;
                if (primaryActionPressed && !inputSourceImpl.primaryActionPressed) {
                  this.dispatchEvent("@@webxr-polyfill/input-select-start", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                } else if (!primaryActionPressed && inputSourceImpl.primaryActionPressed) {
                  this.dispatchEvent("@@webxr-polyfill/input-select-end", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                }
                inputSourceImpl.primaryActionPressed = primaryActionPressed;
              }
              if (inputSourceImpl.primarySqueezeButtonIndex != -1) {
                let primarySqueezeActionPressed = gamepad.buttons[inputSourceImpl.primarySqueezeButtonIndex].pressed;
                if (primarySqueezeActionPressed && !inputSourceImpl.primarySqueezeActionPressed) {
                  this.dispatchEvent("@@webxr-polyfill/input-squeeze-start", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                } else if (!primarySqueezeActionPressed && inputSourceImpl.primarySqueezeActionPressed) {
                  this.dispatchEvent("@@webxr-polyfill/input-squeeze-end", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
                }
                inputSourceImpl.primarySqueezeActionPressed = primarySqueezeActionPressed;
              }
            }
          }
        }
        if (TEST_ENV) {
          return;
        }
        if (!session.immersive && session.baseLayer) {
          const canvas2 = session.baseLayer.context.canvas;
          perspective2(
            this.frame.leftProjectionMatrix,
            renderState.inlineVerticalFieldOfView,
            canvas2.width / canvas2.height,
            renderState.depthNear,
            renderState.depthFar
          );
        }
      }
      onFrameEnd(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session.ended || !session.baseLayer) {
          return;
        }
        if (session.outputContext && !(session.immersive && !this.display.capabilities.hasExternalDisplay)) {
          const mirroring = session.immersive && this.display.capabilities.hasExternalDisplay;
          const iCanvas = session.baseLayer.context.canvas;
          const iWidth = mirroring ? iCanvas.width / 2 : iCanvas.width;
          const iHeight = iCanvas.height;
          if (!TEST_ENV) {
            const oCanvas = session.outputContext.canvas;
            const oWidth = oCanvas.width;
            const oHeight = oCanvas.height;
            const renderContext = session.renderContext;
            if (this.HAS_BITMAP_SUPPORT) {
              if (iCanvas.transferToImageBitmap) {
                renderContext.transferFromImageBitmap(iCanvas.transferToImageBitmap());
              } else {
                this.global.createImageBitmap(iCanvas, 0, 0, iWidth, iHeight, {
                  resizeWidth: oWidth,
                  resizeHeight: oHeight
                }).then((bitmap) => renderContext.transferFromImageBitmap(bitmap));
              }
            } else {
              renderContext.drawImage(
                iCanvas,
                0,
                0,
                iWidth,
                iHeight,
                0,
                0,
                oWidth,
                oHeight
              );
            }
          }
        }
        if (session.immersive && session.baseLayer) {
          this.display.submitFrame();
        }
      }
      /**
       * @param {number} handle
       */
      cancelAnimationFrame(handle) {
        this.display.cancelAnimationFrame(handle);
      }
      /**
       * @TODO Spec
       */
      async endSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session.ended) {
          return;
        }
        if (session.immersive) {
          return this.display.exitPresent();
        } else {
          session.ended = true;
        }
      }
      /**
       * @param {number} sessionId
       * @param {XRReferenceSpaceType} type
       * @return {boolean}
       */
      doesSessionSupportReferenceSpace(sessionId, type) {
        const session = this.sessions.get(sessionId);
        if (session.ended) {
          return false;
        }
        return session.enabledFeatures.has(type);
      }
      /**
       * If the VRDisplay has stage parameters, convert them
       * to an array of X, Z pairings.
       *
       * @return {Object?}
       */
      requestStageBounds() {
        if (this.display.stageParameters) {
          const width = this.display.stageParameters.sizeX;
          const depth = this.display.stageParameters.sizeZ;
          const data = [];
          data.push(-width / 2);
          data.push(-depth / 2);
          data.push(width / 2);
          data.push(-depth / 2);
          data.push(width / 2);
          data.push(depth / 2);
          data.push(-width / 2);
          data.push(depth / 2);
          return data;
        }
        return null;
      }
      /**
       * Returns a promise resolving to a transform if XRDevice
       * can support frame of reference and provides its own values.
       * Can resolve to `undefined` if the polyfilled API can provide
       * a default. Rejects if this XRDevice cannot
       * support the frame of reference.
       *
       * @param {XRFrameOfReferenceType} type
       * @param {XRFrameOfReferenceOptions} options
       * @return {Promise<float32rray>}
       */
      async requestFrameOfReferenceTransform(type, options) {
        if ((type === "local-floor" || type === "bounded-floor") && this.display.stageParameters && this.display.stageParameters.sittingToStandingTransform) {
          return this.display.stageParameters.sittingToStandingTransform;
        }
        return null;
      }
      /**
       * @param {XREye} eye
       * @return {Float32Array}
       */
      getProjectionMatrix(eye) {
        if (eye === "left") {
          return this.frame.leftProjectionMatrix;
        } else if (eye === "right") {
          return this.frame.rightProjectionMatrix;
        } else if (eye === "none") {
          return this.frame.leftProjectionMatrix;
        } else {
          throw new Error(`eye must be of type 'left' or 'right'`);
        }
      }
      /**
       * Takes a XREye and a target to apply properties of
       * `x`, `y`, `width` and `height` on. Returns a boolean
       * indicating if it successfully was able to populate
       * target's values.
       *
       * @param {number} sessionId
       * @param {XREye} eye
       * @param {XRWebGLLayer} layer
       * @param {Object?} target
       * @return {boolean}
       */
      getViewport(sessionId, eye, layer, target) {
        const session = this.sessions.get(sessionId);
        const { width, height } = layer.context.canvas;
        if (!session.immersive) {
          target.x = target.y = 0;
          target.width = width;
          target.height = height;
          return true;
        }
        if (eye === "left" || eye === "none") {
          target.x = 0;
        } else if (eye === "right") {
          target.x = width / 2;
        } else {
          return false;
        }
        target.y = 0;
        target.width = width / 2;
        target.height = height;
        return true;
      }
      /**
       * Get model matrix unaffected by frame of reference.
       *
       * @return {Float32Array}
       */
      getBasePoseMatrix() {
        let { position, orientation } = this.frame.pose;
        if (!position && !orientation) {
          return this.baseModelMatrix;
        }
        if (!position) {
          position = this.tempVec3;
          position[0] = position[1] = position[2] = 0;
        }
        fromRotationTranslation3(this.baseModelMatrix, orientation, position);
        return this.baseModelMatrix;
      }
      /**
       * Get view matrix unaffected by frame of reference.
       *
       * @param {XREye} eye
       * @return {Float32Array}
       */
      getBaseViewMatrix(eye) {
        if (eye === "left" || eye === "none") {
          return this.frame.leftViewMatrix;
        } else if (eye === "right") {
          return this.frame.rightViewMatrix;
        } else {
          throw new Error(`eye must be of type 'left' or 'right'`);
        }
      }
      getInputSources() {
        let inputSources = [];
        for (let i in this.gamepadInputSources) {
          inputSources.push(this.gamepadInputSources[i].inputSource);
        }
        return inputSources;
      }
      getInputPose(inputSource, coordinateSystem, poseType) {
        if (!coordinateSystem) {
          return null;
        }
        for (let i in this.gamepadInputSources) {
          let inputSourceImpl = this.gamepadInputSources[i];
          if (inputSourceImpl.inputSource === inputSource) {
            return inputSourceImpl.getXRPose(coordinateSystem, poseType);
          }
        }
        return null;
      }
      /**
       * Triggered on window resize.
       *
       */
      onWindowResize() {
      }
      /**
       * Listens to the Native 1.1 `window.addEventListener('vrdisplaypresentchange')`
       * event.
       *
       * @param {Event} event
       */
      onVRDisplayPresentChange(e) {
        if (!this.display.isPresenting) {
          this.sessions.forEach((session) => {
            if (session.immersive && !session.ended) {
              if (session.modifiedCanvasLayer) {
                const canvas2 = session.baseLayer.context.canvas;
                document.body.removeChild(canvas2);
                canvas2.setAttribute("style", "");
              }
              if (this.immersiveSession === session) {
                this.immersiveSession = null;
              }
              this.dispatchEvent("@@webxr-polyfill/vr-present-end", session.id);
            }
          });
        }
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices/CardboardXRDevice.js
var import_cardboard_vr_display, CardboardXRDevice;
var init_CardboardXRDevice = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices/CardboardXRDevice.js"() {
    import_cardboard_vr_display = __toESM(require_cardboard_vr_display());
    init_WebVRDevice();
    CardboardXRDevice = class extends WebVRDevice {
      /**
       * Takes a VRDisplay instance and a VRFrameData
       * constructor from the WebVR 1.1 spec.
       *
       * @param {VRDisplay} display
       * @param {Object?} cardboardConfig
       */
      constructor(global2, cardboardConfig) {
        const display = new import_cardboard_vr_display.default(cardboardConfig || {});
        super(global2, display);
        this.display = display;
        this.frame = {
          rightViewMatrix: new Float32Array(16),
          leftViewMatrix: new Float32Array(16),
          rightProjectionMatrix: new Float32Array(16),
          leftProjectionMatrix: new Float32Array(16),
          pose: null,
          timestamp: null
        };
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices/InlineDevice.js
var TEST_ENV2, SESSION_ID2, Session2, InlineDevice;
var init_InlineDevice = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices/InlineDevice.js"() {
    init_mat4();
    init_XRDevice();
    TEST_ENV2 = false;
    SESSION_ID2 = 0;
    Session2 = class {
      constructor(mode, enabledFeatures) {
        this.mode = mode;
        this.enabledFeatures = enabledFeatures;
        this.ended = null;
        this.baseLayer = null;
        this.id = ++SESSION_ID2;
      }
    };
    InlineDevice = class extends XRDevice {
      /**
       * Constructs an inline-only XRDevice
       */
      constructor(global2) {
        super(global2);
        this.sessions = /* @__PURE__ */ new Map();
        this.projectionMatrix = create7();
        this.identityMatrix = create7();
      }
      /**
       * Called when a XRSession has a `baseLayer` property set.
       *
       * @param {number} sessionId
       * @param {XRWebGLLayer} layer
       */
      onBaseLayerSet(sessionId, layer) {
        const session = this.sessions.get(sessionId);
        session.baseLayer = layer;
      }
      /**
       * Returns true if the requested mode is inline
       *
       * @param {XRSessionMode} mode
       * @return {boolean}
       */
      isSessionSupported(mode) {
        return mode == "inline";
      }
      /**
       * @param {string} featureDescriptor
       * @return {boolean}
       */
      isFeatureSupported(featureDescriptor) {
        switch (featureDescriptor) {
          case "viewer":
            return true;
          default:
            return false;
        }
      }
      /**
       * Returns a promise of a session ID if creating a session is successful.
       *
       * @param {XRSessionMode} mode
       * @param {Set<string>} enabledFeatures
       * @return {Promise<number>}
       */
      async requestSession(mode, enabledFeatures) {
        if (!this.isSessionSupported(mode)) {
          return Promise.reject();
        }
        const session = new Session2(mode, enabledFeatures);
        this.sessions.set(session.id, session);
        return Promise.resolve(session.id);
      }
      /**
       * @return {Function}
       */
      requestAnimationFrame(callback) {
        return window.requestAnimationFrame(callback);
      }
      /**
       * @param {number} handle
       */
      cancelAnimationFrame(handle) {
        window.cancelAnimationFrame(handle);
      }
      onFrameStart(sessionId, renderState) {
        if (TEST_ENV2) {
          return;
        }
        const session = this.sessions.get(sessionId);
        if (session.baseLayer) {
          const canvas2 = session.baseLayer.context.canvas;
          perspective2(
            this.projectionMatrix,
            renderState.inlineVerticalFieldOfView,
            canvas2.width / canvas2.height,
            renderState.depthNear,
            renderState.depthFar
          );
        }
      }
      onFrameEnd(sessionId) {
      }
      /**
       * @TODO Spec
       */
      async endSession(sessionId) {
        const session = this.sessions.get(sessionId);
        session.ended = true;
      }
      /**
       * @param {number} sessionId
       * @param {XRReferenceSpaceType} type
       * @return {boolean}
       */
      doesSessionSupportReferenceSpace(sessionId, type) {
        const session = this.sessions.get(sessionId);
        if (session.ended) {
          return false;
        }
        return session.enabledFeatures.has(type);
      }
      /**
       * Inline sessions don't have stage bounds
       *
       * @return {Object?}
       */
      requestStageBounds() {
        return null;
      }
      /**
       * Inline sessions don't have multiple frames of reference
       *
       * @param {XRFrameOfReferenceType} type
       * @param {XRFrameOfReferenceOptions} options
       * @return {Promise<Float32Array>}
       */
      async requestFrameOfReferenceTransform(type, options) {
        return null;
      }
      /**
       * @param {XREye} eye
       * @return {Float32Array}
       */
      getProjectionMatrix(eye) {
        return this.projectionMatrix;
      }
      /**
       * Takes a XREye and a target to apply properties of
       * `x`, `y`, `width` and `height` on. Returns a boolean
       * indicating if it successfully was able to populate
       * target's values.
       *
       * @param {number} sessionId
       * @param {XREye} eye
       * @param {XRWebGLLayer} layer
       * @param {Object?} target
       * @return {boolean}
       */
      getViewport(sessionId, eye, layer, target) {
        const session = this.sessions.get(sessionId);
        const { width, height } = layer.context.canvas;
        target.x = target.y = 0;
        target.width = width;
        target.height = height;
        return true;
      }
      /**
       * Get model matrix unaffected by frame of reference.
       *
       * @return {Float32Array}
       */
      getBasePoseMatrix() {
        return this.identityMatrix;
      }
      /**
       * Get view matrix unaffected by frame of reference.
       *
       * @param {XREye} eye
       * @return {Float32Array}
       */
      getBaseViewMatrix(eye) {
        return this.identityMatrix;
      }
      /**
       * No persistent input sources for the inline session
       */
      getInputSources() {
        return [];
      }
      getInputPose(inputSource, coordinateSystem, poseType) {
        return null;
      }
      /**
       * Triggered on window resize.
       */
      onWindowResize() {
      }
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/devices.js
var getWebVRDevice, requestXRDevice;
var init_devices = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/devices.js"() {
    init_CardboardXRDevice();
    init_InlineDevice();
    init_WebVRDevice();
    init_utils();
    getWebVRDevice = async function(global2) {
      let device = null;
      if ("getVRDisplays" in global2.navigator) {
        try {
          const displays = await global2.navigator.getVRDisplays();
          if (displays && displays.length) {
            device = new WebVRDevice(global2, displays[0]);
          }
        } catch (e) {
        }
      }
      return device;
    };
    requestXRDevice = async function(global2, config) {
      if (config.webvr) {
        let xr = await getWebVRDevice(global2);
        if (xr) {
          return xr;
        }
      }
      let mobile = isMobile(global2);
      if (mobile && config.cardboard || !mobile && config.allowCardboardOnDesktop) {
        if (!global2.VRFrameData) {
          global2.VRFrameData = function() {
            this.rightViewMatrix = new Float32Array(16);
            this.leftViewMatrix = new Float32Array(16);
            this.rightProjectionMatrix = new Float32Array(16);
            this.leftProjectionMatrix = new Float32Array(16);
            this.pose = null;
          };
        }
        return new CardboardXRDevice(global2, config.cardboardConfig);
      }
      return new InlineDevice(global2);
    };
  }
});

// ../node_modules/@lookingglass/webxr-polyfill/src/WebXRPolyfill.js
var WebXRPolyfill_exports = {};
__export(WebXRPolyfill_exports, {
  default: () => WebXRPolyfill
});
var CONFIG_DEFAULTS, partials, WebXRPolyfill;
var init_WebXRPolyfill = __esm({
  "../node_modules/@lookingglass/webxr-polyfill/src/WebXRPolyfill.js"() {
    init_global();
    init_api();
    init_polyfill_globals();
    init_utils();
    init_devices();
    CONFIG_DEFAULTS = {
      // The default global to use for needed APIs.
      global: global_default,
      // Whether support for a browser implementing WebVR 1.1 is enabled.
      // If enabled, XR support is powered by native WebVR 1.1 VRDisplays,
      // exposed as XRDevices.
      webvr: true,
      // Whether a CardboardXRDevice should be discoverable if on
      // a mobile device, and no other native (1.1 VRDisplay if `webvr` on,
      // or XRDevice) found.
      cardboard: true,
      // The configuration to be used for CardboardVRDisplay when used.
      // Has no effect if `cardboard: false` or another XRDevice is used.
      // Configuration can be found: https://github.com/immersive-web/cardboard-vr-display/blob/master/src/options.js
      cardboardConfig: null,
      // Whether a CardboardXRDevice should be created if no WebXR API found
      // on desktop or not. Stereoscopic rendering with a gyro often does not make sense on desktop, and probably only useful for debugging.
      allowCardboardOnDesktop: false
    };
    partials = ["navigator", "HTMLCanvasElement", "WebGLRenderingContext"];
    WebXRPolyfill = class {
      /**
       * @param {object?} config
       */
      constructor(config = {}) {
        this.config = Object.freeze(Object.assign({}, CONFIG_DEFAULTS, config));
        this.global = this.config.global;
        this.nativeWebXR = "xr" in this.global.navigator;
        this.injected = false;
        if (true) {
          this._injectPolyfill(this.global);
        } else {
          this._injectCompatibilityShims(this.global);
        }
      }
      _injectPolyfill(global2) {
        if (!partials.every((iface) => !!global2[iface])) {
          throw new Error(`Global must have the following attributes : ${partials}`);
        }
        for (const className of Object.keys(api_default)) {
          if (global2[className] !== void 0) {
            console.warn(`${className} already defined on global.`);
          } else {
            global2[className] = api_default[className];
          }
        }
        if (true) {
          const polyfilledCtx = polyfillMakeXRCompatible(global2.WebGLRenderingContext);
          if (polyfilledCtx) {
            polyfillGetContext(global2.HTMLCanvasElement);
            if (global2.OffscreenCanvas) {
              polyfillGetContext(global2.OffscreenCanvas);
            }
            if (global2.WebGL2RenderingContext) {
              polyfillMakeXRCompatible(global2.WebGL2RenderingContext);
            }
            if (!window.isSecureContext) {
              console.warn(`WebXR Polyfill Warning:
This page is not running in a secure context (https:// or localhost)!
This means that although the page may be able to use the WebXR Polyfill it will
not be able to use native WebXR implementations, and as such will not be able to
access dedicated VR or AR hardware, and will not be able to take advantage of
any performance improvements a native WebXR implementation may offer. Please
host this content on a secure origin for the best user experience.
`);
            }
          }
        }
        this.injected = true;
        this._patchNavigatorXR();
      }
      _patchNavigatorXR() {
        let devicePromise = requestXRDevice(this.global, this.config);
        this.xr = new api_default.XRSystem(devicePromise);
        Object.defineProperty(this.global.navigator, "xr", {
          value: this.xr,
          configurable: true
        });
      }
      _injectCompatibilityShims(global2) {
        if (!partials.every((iface) => !!global2[iface])) {
          throw new Error(`Global must have the following attributes : ${partials}`);
        }
        if (global2.navigator.xr && "supportsSession" in global2.navigator.xr && !("isSessionSupported" in global2.navigator.xr)) {
          let originalSupportsSession = global2.navigator.xr.supportsSession;
          global2.navigator.xr.isSessionSupported = function(mode) {
            return originalSupportsSession.call(this, mode).then(() => {
              return true;
            }).catch(() => {
              return false;
            });
          };
          global2.navigator.xr.supportsSession = function(mode) {
            console.warn("navigator.xr.supportsSession() is deprecated. Please call navigator.xr.isSessionSupported() instead and check the boolean value returned when the promise resolves.");
            return originalSupportsSession.call(this, mode);
          };
        }
      }
    };
  }
});

// ../node_modules/ws/browser.js
var require_browser = __commonJS({
  "../node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// ../node_modules/holoplay-core/dist/holoplaycore.js
var require_holoplaycore = __commonJS({
  "../node_modules/holoplay-core/dist/holoplaycore.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.HoloPlayCore = {}));
    })(exports, function(exports2) {
      "use strict";
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function createCommonjsModule(fn, module2) {
        return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
      }
      var cbor = createCommonjsModule(function(module2) {
        (function(global2, undefined$1) {
          var POW_2_24 = Math.pow(2, -24), POW_2_32 = Math.pow(2, 32), POW_2_53 = Math.pow(2, 53);
          function encode(value) {
            var data = new ArrayBuffer(256);
            var dataView = new DataView(data);
            var lastLength;
            var offset2 = 0;
            function ensureSpace(length7) {
              var newByteLength = data.byteLength;
              var requiredLength = offset2 + length7;
              while (newByteLength < requiredLength)
                newByteLength *= 2;
              if (newByteLength !== data.byteLength) {
                var oldDataView = dataView;
                data = new ArrayBuffer(newByteLength);
                dataView = new DataView(data);
                var uint32count = offset2 + 3 >> 2;
                for (var i2 = 0; i2 < uint32count; ++i2)
                  dataView.setUint32(i2 * 4, oldDataView.getUint32(i2 * 4));
              }
              lastLength = length7;
              return dataView;
            }
            function write() {
              offset2 += lastLength;
            }
            function writeFloat64(value2) {
              write(ensureSpace(8).setFloat64(offset2, value2));
            }
            function writeUint8(value2) {
              write(ensureSpace(1).setUint8(offset2, value2));
            }
            function writeUint8Array(value2) {
              var dataView2 = ensureSpace(value2.length);
              for (var i2 = 0; i2 < value2.length; ++i2)
                dataView2.setUint8(offset2 + i2, value2[i2]);
              write();
            }
            function writeUint16(value2) {
              write(ensureSpace(2).setUint16(offset2, value2));
            }
            function writeUint32(value2) {
              write(ensureSpace(4).setUint32(offset2, value2));
            }
            function writeUint64(value2) {
              var low = value2 % POW_2_32;
              var high = (value2 - low) / POW_2_32;
              var dataView2 = ensureSpace(8);
              dataView2.setUint32(offset2, high);
              dataView2.setUint32(offset2 + 4, low);
              write();
            }
            function writeTypeAndLength(type, length7) {
              if (length7 < 24) {
                writeUint8(type << 5 | length7);
              } else if (length7 < 256) {
                writeUint8(type << 5 | 24);
                writeUint8(length7);
              } else if (length7 < 65536) {
                writeUint8(type << 5 | 25);
                writeUint16(length7);
              } else if (length7 < 4294967296) {
                writeUint8(type << 5 | 26);
                writeUint32(length7);
              } else {
                writeUint8(type << 5 | 27);
                writeUint64(length7);
              }
            }
            function encodeItem(value2) {
              var i2;
              if (value2 === false)
                return writeUint8(244);
              if (value2 === true)
                return writeUint8(245);
              if (value2 === null)
                return writeUint8(246);
              if (value2 === undefined$1)
                return writeUint8(247);
              switch (typeof value2) {
                case "number":
                  if (Math.floor(value2) === value2) {
                    if (0 <= value2 && value2 <= POW_2_53)
                      return writeTypeAndLength(0, value2);
                    if (-POW_2_53 <= value2 && value2 < 0)
                      return writeTypeAndLength(1, -(value2 + 1));
                  }
                  writeUint8(251);
                  return writeFloat64(value2);
                case "string":
                  var utf8data = [];
                  for (i2 = 0; i2 < value2.length; ++i2) {
                    var charCode = value2.charCodeAt(i2);
                    if (charCode < 128) {
                      utf8data.push(charCode);
                    } else if (charCode < 2048) {
                      utf8data.push(192 | charCode >> 6);
                      utf8data.push(128 | charCode & 63);
                    } else if (charCode < 55296) {
                      utf8data.push(224 | charCode >> 12);
                      utf8data.push(128 | charCode >> 6 & 63);
                      utf8data.push(128 | charCode & 63);
                    } else {
                      charCode = (charCode & 1023) << 10;
                      charCode |= value2.charCodeAt(++i2) & 1023;
                      charCode += 65536;
                      utf8data.push(240 | charCode >> 18);
                      utf8data.push(128 | charCode >> 12 & 63);
                      utf8data.push(128 | charCode >> 6 & 63);
                      utf8data.push(128 | charCode & 63);
                    }
                  }
                  writeTypeAndLength(3, utf8data.length);
                  return writeUint8Array(utf8data);
                default:
                  var length7;
                  if (Array.isArray(value2)) {
                    length7 = value2.length;
                    writeTypeAndLength(4, length7);
                    for (i2 = 0; i2 < length7; ++i2)
                      encodeItem(value2[i2]);
                  } else if (value2 instanceof Uint8Array) {
                    writeTypeAndLength(2, value2.length);
                    writeUint8Array(value2);
                  } else {
                    var keys = Object.keys(value2);
                    length7 = keys.length;
                    writeTypeAndLength(5, length7);
                    for (i2 = 0; i2 < length7; ++i2) {
                      var key = keys[i2];
                      encodeItem(key);
                      encodeItem(value2[key]);
                    }
                  }
              }
            }
            encodeItem(value);
            if ("slice" in data)
              return data.slice(0, offset2);
            var ret = new ArrayBuffer(offset2);
            var retView = new DataView(ret);
            for (var i = 0; i < offset2; ++i)
              retView.setUint8(i, dataView.getUint8(i));
            return ret;
          }
          function decode(data, tagger, simpleValue) {
            var dataView = new DataView(data);
            var offset2 = 0;
            if (typeof tagger !== "function")
              tagger = function(value) {
                return value;
              };
            if (typeof simpleValue !== "function")
              simpleValue = function() {
                return undefined$1;
              };
            function read(value, length7) {
              offset2 += length7;
              return value;
            }
            function readArrayBuffer(length7) {
              return read(new Uint8Array(data, offset2, length7), length7);
            }
            function readFloat16() {
              var tempArrayBuffer = new ArrayBuffer(4);
              var tempDataView = new DataView(tempArrayBuffer);
              var value = readUint16();
              var sign = value & 32768;
              var exponent = value & 31744;
              var fraction = value & 1023;
              if (exponent === 31744)
                exponent = 255 << 10;
              else if (exponent !== 0)
                exponent += 127 - 15 << 10;
              else if (fraction !== 0)
                return fraction * POW_2_24;
              tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
              return tempDataView.getFloat32(0);
            }
            function readFloat32() {
              return read(dataView.getFloat32(offset2), 4);
            }
            function readFloat64() {
              return read(dataView.getFloat64(offset2), 8);
            }
            function readUint8() {
              return read(dataView.getUint8(offset2), 1);
            }
            function readUint16() {
              return read(dataView.getUint16(offset2), 2);
            }
            function readUint32() {
              return read(dataView.getUint32(offset2), 4);
            }
            function readUint64() {
              return readUint32() * POW_2_32 + readUint32();
            }
            function readBreak() {
              if (dataView.getUint8(offset2) !== 255)
                return false;
              offset2 += 1;
              return true;
            }
            function readLength(additionalInformation) {
              if (additionalInformation < 24)
                return additionalInformation;
              if (additionalInformation === 24)
                return readUint8();
              if (additionalInformation === 25)
                return readUint16();
              if (additionalInformation === 26)
                return readUint32();
              if (additionalInformation === 27)
                return readUint64();
              if (additionalInformation === 31)
                return -1;
              throw "Invalid length encoding";
            }
            function readIndefiniteStringLength(majorType) {
              var initialByte = readUint8();
              if (initialByte === 255)
                return -1;
              var length7 = readLength(initialByte & 31);
              if (length7 < 0 || initialByte >> 5 !== majorType)
                throw "Invalid indefinite length element";
              return length7;
            }
            function appendUtf16data(utf16data, length7) {
              for (var i = 0; i < length7; ++i) {
                var value = readUint8();
                if (value & 128) {
                  if (value < 224) {
                    value = (value & 31) << 6 | readUint8() & 63;
                    length7 -= 1;
                  } else if (value < 240) {
                    value = (value & 15) << 12 | (readUint8() & 63) << 6 | readUint8() & 63;
                    length7 -= 2;
                  } else {
                    value = (value & 15) << 18 | (readUint8() & 63) << 12 | (readUint8() & 63) << 6 | readUint8() & 63;
                    length7 -= 3;
                  }
                }
                if (value < 65536) {
                  utf16data.push(value);
                } else {
                  value -= 65536;
                  utf16data.push(55296 | value >> 10);
                  utf16data.push(56320 | value & 1023);
                }
              }
            }
            function decodeItem() {
              var initialByte = readUint8();
              var majorType = initialByte >> 5;
              var additionalInformation = initialByte & 31;
              var i;
              var length7;
              if (majorType === 7) {
                switch (additionalInformation) {
                  case 25:
                    return readFloat16();
                  case 26:
                    return readFloat32();
                  case 27:
                    return readFloat64();
                }
              }
              length7 = readLength(additionalInformation);
              if (length7 < 0 && (majorType < 2 || 6 < majorType))
                throw "Invalid length";
              switch (majorType) {
                case 0:
                  return length7;
                case 1:
                  return -1 - length7;
                case 2:
                  if (length7 < 0) {
                    var elements = [];
                    var fullArrayLength = 0;
                    while ((length7 = readIndefiniteStringLength(majorType)) >= 0) {
                      fullArrayLength += length7;
                      elements.push(readArrayBuffer(length7));
                    }
                    var fullArray = new Uint8Array(fullArrayLength);
                    var fullArrayOffset = 0;
                    for (i = 0; i < elements.length; ++i) {
                      fullArray.set(elements[i], fullArrayOffset);
                      fullArrayOffset += elements[i].length;
                    }
                    return fullArray;
                  }
                  return readArrayBuffer(length7);
                case 3:
                  var utf16data = [];
                  if (length7 < 0) {
                    while ((length7 = readIndefiniteStringLength(majorType)) >= 0)
                      appendUtf16data(utf16data, length7);
                  } else
                    appendUtf16data(utf16data, length7);
                  return String.fromCharCode.apply(null, utf16data);
                case 4:
                  var retArray;
                  if (length7 < 0) {
                    retArray = [];
                    while (!readBreak())
                      retArray.push(decodeItem());
                  } else {
                    retArray = new Array(length7);
                    for (i = 0; i < length7; ++i)
                      retArray[i] = decodeItem();
                  }
                  return retArray;
                case 5:
                  var retObject = {};
                  for (i = 0; i < length7 || length7 < 0 && !readBreak(); ++i) {
                    var key = decodeItem();
                    retObject[key] = decodeItem();
                  }
                  return retObject;
                case 6:
                  return tagger(decodeItem(), length7);
                case 7:
                  switch (length7) {
                    case 20:
                      return false;
                    case 21:
                      return true;
                    case 22:
                      return null;
                    case 23:
                      return undefined$1;
                    default:
                      return simpleValue(length7);
                  }
              }
            }
            var ret = decodeItem();
            if (offset2 !== data.byteLength)
              throw "Remaining bytes";
            return ret;
          }
          var obj = { encode, decode };
          if (typeof undefined$1 === "function" && undefined$1.amd)
            undefined$1("cbor/cbor", obj);
          else if (module2.exports)
            module2.exports = obj;
          else if (!global2.CBOR)
            global2.CBOR = obj;
        })(commonjsGlobal);
      });
      const WebSocket = typeof window === "undefined" ? require_browser() : window.WebSocket;
      class Client {
        /**
         * Establish a client to talk to HoloPlayService.
         * @constructor
         * @param {function} initCallback - optional; a function to trigger when
         *     response is received
         * @param {function} errCallback - optional; a function to trigger when there
         *     is a connection error
         * @param {function} closeCallback - optional; a function to trigger when the
         *     socket is closed
         * @param {boolean} debug - optional; default is false
         * @param {string}  appId - optional
         * @param {boolean} isGreedy - optional
         * @param {string}  oncloseBehavior - optional, can be 'wipe', 'hide', 'none'
         */
        constructor(initCallback, errCallback, closeCallback, debug = false, appId, isGreedy, oncloseBehavior) {
          this.reqs = [];
          this.reps = [];
          this.requestId = this.getRequestId();
          this.debug = debug;
          this.isGreedy = isGreedy;
          this.errCallback = errCallback;
          this.closeCallback = closeCallback;
          this.alwaysdebug = false;
          this.isConnected = false;
          let initCmd = null;
          if (appId || isGreedy || oncloseBehavior) {
            initCmd = new InitMessage(appId, isGreedy, oncloseBehavior, this.debug);
          } else {
            if (debug)
              this.alwaysdebug = true;
            if (typeof initCallback == "function")
              initCmd = new InfoMessage();
          }
          this.openWebsocket(initCmd, initCallback);
        }
        /**
         * Send a message over the websocket to HoloPlayService.
         * @public
         * @param {Message} msg - message object
         * @param {integer} timeoutSecs - optional, default is 60 seconds
         */
        sendMessage(msg, timeoutSecs = 60) {
          if (this.alwaysdebug)
            msg.cmd.debug = true;
          let cborData = msg.toCbor();
          return this.sendRequestObj(cborData, timeoutSecs);
        }
        /**
         * Disconnects from the web socket.
         * @public
         */
        disconnect() {
          this.ws.close();
        }
        /**
         * Open a websocket and set handlers
         * @private
         */
        openWebsocket(firstCmd = null, initCallback = null) {
          this.ws = new WebSocket("ws://localhost:11222/driver", ["rep.sp.nanomsg.org"]);
          this.ws.parent = this;
          this.ws.binaryType = "arraybuffer";
          this.ws.onmessage = this.messageHandler;
          this.ws.onopen = () => {
            this.isConnected = true;
            if (this.debug) {
              console.log("socket open");
            }
            if (firstCmd != null) {
              this.sendMessage(firstCmd).then(initCallback);
            }
          };
          this.ws.onerror = this.onSocketError;
          this.ws.onclose = this.onClose;
        }
        /**
         * Send a request object over websocket
         * @private
         */
        sendRequestObj(data, timeoutSecs) {
          return new Promise((resolve, reject) => {
            let reqObj = {
              id: this.requestId++,
              parent: this,
              payload: data,
              success: resolve,
              error: reject,
              send: function() {
                if (this.debug)
                  console.log("attemtping to send request with ID " + this.id);
                this.timeout = setTimeout(reqObj.send.bind(this), timeoutSecs * 1e3);
                let tmp = new Uint8Array(data.byteLength + 4);
                let view = new DataView(tmp.buffer);
                view.setUint32(0, this.id);
                tmp.set(new Uint8Array(this.payload), 4);
                this.parent.ws.send(tmp.buffer);
              }
            };
            this.reqs.push(reqObj);
            reqObj.send();
          });
        }
        /**
         * Handles a message when received
         * @private
         */
        messageHandler(event) {
          console.log("message");
          let data = event.data;
          if (data.byteLength < 4)
            return;
          let view = new DataView(data);
          let replyId = view.getUint32(0);
          if (replyId < 2147483648) {
            this.parent.err("bad nng header");
            return;
          }
          let i = this.parent.findReqIndex(replyId);
          if (i == -1) {
            this.parent.err("got reply that doesn't match known request!");
            return;
          }
          let rep = { id: replyId, payload: cbor.decode(data.slice(4)) };
          if (rep.payload.error == 0) {
            this.parent.reqs[i].success(rep.payload);
          } else {
            this.parent.reqs[i].error(rep.payload);
          }
          clearTimeout(this.parent.reqs[i].timeout);
          this.parent.reqs.splice(i, 1);
          this.parent.reps.push(rep);
          if (this.debug) {
            console.log(rep.payload);
          }
        }
        getRequestId() {
          return Math.floor(this.prng() * 2147483647) + 2147483648;
        }
        onClose(event) {
          this.parent.isConnected = false;
          if (this.parent.debug) {
            console.log("socket closed");
          }
          if (typeof this.parent.closeCallback == "function")
            this.parent.closeCallback(event);
        }
        onSocketError(error) {
          if (this.parent.debug) {
            console.log(error);
          }
          if (typeof this.parent.errCallback == "function") {
            this.parent.errCallback(error);
          }
        }
        err(errorMsg) {
          if (this.debug) {
            console.log("[DRIVER ERROR]" + errorMsg);
          }
        }
        findReqIndex(replyId) {
          let i = 0;
          for (; i < this.reqs.length; i++) {
            if (this.reqs[i].id == replyId) {
              return i;
            }
          }
          return -1;
        }
        prng() {
          if (this.rng == void 0) {
            this.rng = generateRng();
          }
          return this.rng();
        }
      }
      class Message {
        /**
         * Construct a barebone message.
         * @constructor
         */
        constructor(cmd, bin) {
          this.cmd = cmd;
          this.bin = bin;
        }
        /**
         * Convert the class instance to the CBOR format
         * @public
         * @returns {CBOR} - cbor object of the message
         */
        toCbor() {
          return cbor.encode(this);
        }
      }
      class InitMessage extends Message {
        /**
         * @constructor
         * @param {string}  appId - a unique id for app
         * @param {boolean} isGreedy - will it take over screen
         * @param {string}  oncloseBehavior - can be 'wipe', 'hide', 'none'
         */
        constructor(appId = "", isGreedy = false, onclose = "", debug = false) {
          let cmd = { "init": {} };
          if (appId != "")
            cmd["init"].appid = appId;
          if (onclose != "")
            cmd["init"].onclose = onclose;
          if (isGreedy)
            cmd["init"].greedy = true;
          if (debug)
            cmd["init"].debug = true;
          super(cmd, null);
        }
      }
      class DeleteMessage extends Message {
        /**
         * @constructor
         * @param {string} name - name of the quilt
         */
        constructor(name = "") {
          let cmd = { "delete": { "name": name } };
          super(cmd, null);
        }
      }
      class CheckMessage extends Message {
        /**
         * @constructor
         * @param {string} name - name of the quilt
         */
        constructor(name = "") {
          let cmd = { "check": { "name": name } };
          super(cmd, null);
        }
      }
      class WipeMessage extends Message {
        /**
         * @constructor
         * @param {number} targetDisplay - optional, if not provided, default is 0
         */
        constructor(targetDisplay = null) {
          let cmd = { "wipe": {} };
          if (targetDisplay != null)
            cmd["wipe"].targetDisplay = targetDisplay;
          super(cmd, null);
        }
      }
      class InfoMessage extends Message {
        /**
         * @constructor
         */
        constructor() {
          let cmd = { "info": {} };
          super(cmd, null);
        }
      }
      class UniformsMessage extends Message {
        /**
         * @constructor
         * @param {object}
         */
        constructor() {
          let cmd = { "uniforms": {} };
          super(cmd, bindata);
        }
      }
      class ShaderMessage extends Message {
        /**
         * @constructor
         * @param {object}
         */
        constructor() {
          let cmd = { "shader": {} };
          super(cmd, bindata);
        }
      }
      class ShowMessage extends Message {
        /**
         * @constructor
         * @param {object}
         */
        constructor(settings = { vx: 5, vy: 9, aspect: 1.6 }, bindata2 = "", targetDisplay = null) {
          let cmd = {
            "show": {
              "source": "bindata",
              "quilt": { "type": "image", "settings": settings }
            }
          };
          if (targetDisplay != null)
            cmd["show"]["targetDisplay"] = targetDisplay;
          super(cmd, bindata2);
        }
      }
      class CacheMessage extends Message {
        constructor(name, settings = { vx: 5, vy: 9, aspect: 1.6 }, bindata2 = "", show = false) {
          let cmd = {
            "cache": {
              "show": show,
              "quilt": {
                "name": name,
                "type": "image",
                "settings": settings
              }
            }
          };
          super(cmd, bindata2);
        }
      }
      class ShowCachedMessage extends Message {
        constructor(name, targetDisplay = null, settings = null) {
          let cmd = { "show": { "source": "cache", "quilt": { "name": name } } };
          if (targetDisplay != null)
            cmd["show"]["targetDisplay"] = targetDisplay;
          if (settings != null)
            cmd["show"]["quilt"].settings = settings;
          super(cmd, null);
        }
      }
      function generateRng() {
        function xmur3(str5) {
          for (var i = 0, h = 1779033703 ^ str5.length; i < str5.length; i++)
            h = Math.imul(h ^ str5.charCodeAt(i), 3432918353), h = h << 13 | h >>> 19;
          return function() {
            h = Math.imul(h ^ h >>> 16, 2246822507);
            h = Math.imul(h ^ h >>> 13, 3266489909);
            return (h ^= h >>> 16) >>> 0;
          };
        }
        function xoshiro128ss(a, b, c, d) {
          return () => {
            var t = b << 9, r = a * 5;
            r = (r << 7 | r >>> 25) * 9;
            c ^= a;
            d ^= b;
            b ^= c;
            a ^= d;
            c ^= t;
            d = d << 11 | d >>> 21;
            return (r >>> 0) / 4294967296;
          };
        }
        var state = Date.now();
        var seed = xmur3(state.toString());
        return xoshiro128ss(seed(), seed(), seed(), seed());
      }
      function glslifyNumbers(strings, ...values) {
        let s = strings[0];
        for (let i = 1; i < strings.length; ++i) {
          const v = values[i - 1];
          s += typeof v === "number" ? v.toPrecision(10) : v;
          s += strings[i];
        }
        return s;
      }
      function Shader(cfg) {
        return glslifyNumbers`
  precision mediump float;
  uniform int u_viewType;
  uniform sampler2D u_texture;
  varying vec2 v_texcoord;
  const float pitch    = ${cfg.pitch};
  const float tilt     = ${cfg.tilt};
  const float center   = ${cfg.calibration.center.value};
  const float invView  = ${cfg.calibration.invView.value};
  const float flipX    = ${cfg.calibration.flipImageX.value};
  const float flipY    = ${cfg.calibration.flipImageY.value};
  const float subp     = ${cfg.subp};
  const float numViews = ${cfg.numViews};
  const float tilesX   = ${cfg.quiltWidth};
  const float tilesY   = ${cfg.quiltHeight};
  const vec2 quiltViewPortion = vec2(
    ${cfg.quiltWidth * cfg.tileWidth / cfg.framebufferWidth},
    ${cfg.quiltHeight * cfg.tileHeight / cfg.framebufferHeight});
  vec2 texArr(vec3 uvz) {
    float z = floor(uvz.z * numViews);
    float x = (mod(z, tilesX) + uvz.x) / tilesX;
    float y = (floor(z / tilesX) + uvz.y) / tilesY;
    return vec2(x, y) * quiltViewPortion;
  }
  float remap(float value, float from1, float to1, float from2, float to2) {
    return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
  }
  void main() {
    if (u_viewType == 2) { // "quilt" view
      gl_FragColor = texture2D(u_texture, v_texcoord);
      return;
    }
    if (u_viewType == 1) { // middle view
      gl_FragColor = texture2D(u_texture, texArr(vec3(v_texcoord.x, v_texcoord.y, 0.5)));
      return;
    }
    vec4 rgb[3];
    vec3 nuv = vec3(v_texcoord.xy, 0.0);
    // Flip UVs if necessary
    nuv.x = (1.0 - flipX) * nuv.x + flipX * (1.0 - nuv.x);
    nuv.y = (1.0 - flipY) * nuv.y + flipY * (1.0 - nuv.y);
    for (int i = 0; i < 3; i++) {
      nuv.z = (v_texcoord.x + float(i) * subp + v_texcoord.y * tilt) * pitch - center;
      nuv.z = mod(nuv.z + ceil(abs(nuv.z)), 1.0);
      nuv.z = (1.0 - invView) * nuv.z + invView * (1.0 - nuv.z);
      rgb[i] = texture2D(u_texture, texArr(vec3(v_texcoord.x, v_texcoord.y, nuv.z)));
    }
    gl_FragColor = vec4(rgb[0].r, rgb[1].g, rgb[2].b, 1);
  }
`;
      }
      exports2.CacheMessage = CacheMessage;
      exports2.CheckMessage = CheckMessage;
      exports2.Client = Client;
      exports2.DeleteMessage = DeleteMessage;
      exports2.InfoMessage = InfoMessage;
      exports2.InitMessage = InitMessage;
      exports2.Message = Message;
      exports2.Shader = Shader;
      exports2.ShaderMessage = ShaderMessage;
      exports2.ShowCachedMessage = ShowCachedMessage;
      exports2.ShowMessage = ShowMessage;
      exports2.UniformsMessage = UniformsMessage;
      exports2.WipeMessage = WipeMessage;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../node_modules/gl-matrix/dist/gl-matrix.js
var require_gl_matrix = __commonJS({
  "../node_modules/gl-matrix/dist/gl-matrix.js"(exports, module) {
    !function(t, n) {
      if ("object" == typeof exports && "object" == typeof module)
        module.exports = n();
      else if ("function" == typeof define && define.amd)
        define([], n);
      else {
        var r = n();
        for (var a in r)
          ("object" == typeof exports ? exports : t)[a] = r[a];
      }
    }("undefined" != typeof self ? self : exports, function() {
      return function(t) {
        var n = {};
        function r(a) {
          if (n[a])
            return n[a].exports;
          var e = n[a] = { i: a, l: false, exports: {} };
          return t[a].call(e.exports, e, e.exports, r), e.l = true, e.exports;
        }
        return r.m = t, r.c = n, r.d = function(t2, n2, a) {
          r.o(t2, n2) || Object.defineProperty(t2, n2, { enumerable: true, get: a });
        }, r.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, r.t = function(t2, n2) {
          if (1 & n2 && (t2 = r(t2)), 8 & n2)
            return t2;
          if (4 & n2 && "object" == typeof t2 && t2 && t2.__esModule)
            return t2;
          var a = /* @__PURE__ */ Object.create(null);
          if (r.r(a), Object.defineProperty(a, "default", { enumerable: true, value: t2 }), 2 & n2 && "string" != typeof t2)
            for (var e in t2)
              r.d(a, e, function(n3) {
                return t2[n3];
              }.bind(null, e));
          return a;
        }, r.n = function(t2) {
          var n2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return r.d(n2, "a", n2), n2;
        }, r.o = function(t2, n2) {
          return Object.prototype.hasOwnProperty.call(t2, n2);
        }, r.p = "", r(r.s = 10);
      }([function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.setMatrixArrayType = function(t2) {
          n.ARRAY_TYPE = t2;
        }, n.toRadian = function(t2) {
          return t2 * e;
        }, n.equals = function(t2, n2) {
          return Math.abs(t2 - n2) <= a * Math.max(1, Math.abs(t2), Math.abs(n2));
        };
        var a = n.EPSILON = 1e-6;
        n.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, n.RANDOM = Math.random;
        var e = Math.PI / 180;
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.forEach = n.sqrLen = n.len = n.sqrDist = n.dist = n.div = n.mul = n.sub = void 0, n.create = e, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(4);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2;
        }, n.fromValues = function(t2, n2, r2, e2) {
          var u2 = new a.ARRAY_TYPE(4);
          return u2[0] = t2, u2[1] = n2, u2[2] = r2, u2[3] = e2, u2;
        }, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2;
        }, n.set = function(t2, n2, r2, a2, e2) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2[3] = e2, t2;
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2[3] = n2[3] + r2[3], t2;
        }, n.subtract = u, n.multiply = o, n.divide = i, n.ceil = function(t2, n2) {
          return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2[2] = Math.ceil(n2[2]), t2[3] = Math.ceil(n2[3]), t2;
        }, n.floor = function(t2, n2) {
          return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2[2] = Math.floor(n2[2]), t2[3] = Math.floor(n2[3]), t2;
        }, n.min = function(t2, n2, r2) {
          return t2[0] = Math.min(n2[0], r2[0]), t2[1] = Math.min(n2[1], r2[1]), t2[2] = Math.min(n2[2], r2[2]), t2[3] = Math.min(n2[3], r2[3]), t2;
        }, n.max = function(t2, n2, r2) {
          return t2[0] = Math.max(n2[0], r2[0]), t2[1] = Math.max(n2[1], r2[1]), t2[2] = Math.max(n2[2], r2[2]), t2[3] = Math.max(n2[3], r2[3]), t2;
        }, n.round = function(t2, n2) {
          return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2[2] = Math.round(n2[2]), t2[3] = Math.round(n2[3]), t2;
        }, n.scale = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2;
        }, n.scaleAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2[2] = n2[2] + r2[2] * a2, t2[3] = n2[3] + r2[3] * a2, t2;
        }, n.distance = s, n.squaredDistance = c, n.length = f, n.squaredLength = M, n.negate = function(t2, n2) {
          return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = -n2[3], t2;
        }, n.inverse = function(t2, n2) {
          return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2[2] = 1 / n2[2], t2[3] = 1 / n2[3], t2;
        }, n.normalize = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o2 = r2 * r2 + a2 * a2 + e2 * e2 + u2 * u2;
          o2 > 0 && (o2 = 1 / Math.sqrt(o2), t2[0] = r2 * o2, t2[1] = a2 * o2, t2[2] = e2 * o2, t2[3] = u2 * o2);
          return t2;
        }, n.dot = function(t2, n2) {
          return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2] + t2[3] * n2[3];
        }, n.lerp = function(t2, n2, r2, a2) {
          var e2 = n2[0], u2 = n2[1], o2 = n2[2], i2 = n2[3];
          return t2[0] = e2 + a2 * (r2[0] - e2), t2[1] = u2 + a2 * (r2[1] - u2), t2[2] = o2 + a2 * (r2[2] - o2), t2[3] = i2 + a2 * (r2[3] - i2), t2;
        }, n.random = function(t2, n2) {
          var r2, e2, u2, o2, i2, s2;
          n2 = n2 || 1;
          do {
            r2 = 2 * a.RANDOM() - 1, e2 = 2 * a.RANDOM() - 1, i2 = r2 * r2 + e2 * e2;
          } while (i2 >= 1);
          do {
            u2 = 2 * a.RANDOM() - 1, o2 = 2 * a.RANDOM() - 1, s2 = u2 * u2 + o2 * o2;
          } while (s2 >= 1);
          var c2 = Math.sqrt((1 - i2) / s2);
          return t2[0] = n2 * r2, t2[1] = n2 * e2, t2[2] = n2 * u2 * c2, t2[3] = n2 * o2 * c2, t2;
        }, n.transformMat4 = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3];
          return t2[0] = r2[0] * a2 + r2[4] * e2 + r2[8] * u2 + r2[12] * o2, t2[1] = r2[1] * a2 + r2[5] * e2 + r2[9] * u2 + r2[13] * o2, t2[2] = r2[2] * a2 + r2[6] * e2 + r2[10] * u2 + r2[14] * o2, t2[3] = r2[3] * a2 + r2[7] * e2 + r2[11] * u2 + r2[15] * o2, t2;
        }, n.transformQuat = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = r2[0], i2 = r2[1], s2 = r2[2], c2 = r2[3], f2 = c2 * a2 + i2 * u2 - s2 * e2, M2 = c2 * e2 + s2 * a2 - o2 * u2, h = c2 * u2 + o2 * e2 - i2 * a2, l = -o2 * a2 - i2 * e2 - s2 * u2;
          return t2[0] = f2 * c2 + l * -o2 + M2 * -s2 - h * -i2, t2[1] = M2 * c2 + l * -i2 + h * -o2 - f2 * -s2, t2[2] = h * c2 + l * -s2 + f2 * -i2 - M2 * -o2, t2[3] = n2[3], t2;
        }, n.str = function(t2) {
          return "vec4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o2 = t2[3], i2 = n2[0], s2 = n2[1], c2 = n2[2], f2 = n2[3];
          return Math.abs(r2 - i2) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(i2)) && Math.abs(e2 - s2) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(s2)) && Math.abs(u2 - c2) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(c2)) && Math.abs(o2 - f2) <= a.EPSILON * Math.max(1, Math.abs(o2), Math.abs(f2));
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e() {
          var t2 = new a.ARRAY_TYPE(4);
          return a.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
        }
        function u(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2[2] = n2[2] - r2[2], t2[3] = n2[3] - r2[3], t2;
        }
        function o(t2, n2, r2) {
          return t2[0] = n2[0] * r2[0], t2[1] = n2[1] * r2[1], t2[2] = n2[2] * r2[2], t2[3] = n2[3] * r2[3], t2;
        }
        function i(t2, n2, r2) {
          return t2[0] = n2[0] / r2[0], t2[1] = n2[1] / r2[1], t2[2] = n2[2] / r2[2], t2[3] = n2[3] / r2[3], t2;
        }
        function s(t2, n2) {
          var r2 = n2[0] - t2[0], a2 = n2[1] - t2[1], e2 = n2[2] - t2[2], u2 = n2[3] - t2[3];
          return Math.sqrt(r2 * r2 + a2 * a2 + e2 * e2 + u2 * u2);
        }
        function c(t2, n2) {
          var r2 = n2[0] - t2[0], a2 = n2[1] - t2[1], e2 = n2[2] - t2[2], u2 = n2[3] - t2[3];
          return r2 * r2 + a2 * a2 + e2 * e2 + u2 * u2;
        }
        function f(t2) {
          var n2 = t2[0], r2 = t2[1], a2 = t2[2], e2 = t2[3];
          return Math.sqrt(n2 * n2 + r2 * r2 + a2 * a2 + e2 * e2);
        }
        function M(t2) {
          var n2 = t2[0], r2 = t2[1], a2 = t2[2], e2 = t2[3];
          return n2 * n2 + r2 * r2 + a2 * a2 + e2 * e2;
        }
        n.sub = u, n.mul = o, n.div = i, n.dist = s, n.sqrDist = c, n.len = f, n.sqrLen = M, n.forEach = function() {
          var t2 = e();
          return function(n2, r2, a2, e2, u2, o2) {
            var i2 = void 0, s2 = void 0;
            for (r2 || (r2 = 4), a2 || (a2 = 0), s2 = e2 ? Math.min(e2 * r2 + a2, n2.length) : n2.length, i2 = a2; i2 < s2; i2 += r2)
              t2[0] = n2[i2], t2[1] = n2[i2 + 1], t2[2] = n2[i2 + 2], t2[3] = n2[i2 + 3], u2(t2, t2, o2), n2[i2] = t2[0], n2[i2 + 1] = t2[1], n2[i2 + 2] = t2[2], n2[i2 + 3] = t2[3];
            return n2;
          };
        }();
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.forEach = n.sqrLen = n.len = n.sqrDist = n.dist = n.div = n.mul = n.sub = void 0, n.create = e, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(3);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2;
        }, n.length = u, n.fromValues = o, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2;
        }, n.set = function(t2, n2, r2, a2) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2;
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2;
        }, n.subtract = i, n.multiply = s, n.divide = c, n.ceil = function(t2, n2) {
          return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2[2] = Math.ceil(n2[2]), t2;
        }, n.floor = function(t2, n2) {
          return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2[2] = Math.floor(n2[2]), t2;
        }, n.min = function(t2, n2, r2) {
          return t2[0] = Math.min(n2[0], r2[0]), t2[1] = Math.min(n2[1], r2[1]), t2[2] = Math.min(n2[2], r2[2]), t2;
        }, n.max = function(t2, n2, r2) {
          return t2[0] = Math.max(n2[0], r2[0]), t2[1] = Math.max(n2[1], r2[1]), t2[2] = Math.max(n2[2], r2[2]), t2;
        }, n.round = function(t2, n2) {
          return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2[2] = Math.round(n2[2]), t2;
        }, n.scale = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2;
        }, n.scaleAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2[2] = n2[2] + r2[2] * a2, t2;
        }, n.distance = f, n.squaredDistance = M, n.squaredLength = h, n.negate = function(t2, n2) {
          return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2;
        }, n.inverse = function(t2, n2) {
          return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2[2] = 1 / n2[2], t2;
        }, n.normalize = l, n.dot = v, n.cross = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = r2[0], i2 = r2[1], s2 = r2[2];
          return t2[0] = e2 * s2 - u2 * i2, t2[1] = u2 * o2 - a2 * s2, t2[2] = a2 * i2 - e2 * o2, t2;
        }, n.lerp = function(t2, n2, r2, a2) {
          var e2 = n2[0], u2 = n2[1], o2 = n2[2];
          return t2[0] = e2 + a2 * (r2[0] - e2), t2[1] = u2 + a2 * (r2[1] - u2), t2[2] = o2 + a2 * (r2[2] - o2), t2;
        }, n.hermite = function(t2, n2, r2, a2, e2, u2) {
          var o2 = u2 * u2, i2 = o2 * (2 * u2 - 3) + 1, s2 = o2 * (u2 - 2) + u2, c2 = o2 * (u2 - 1), f2 = o2 * (3 - 2 * u2);
          return t2[0] = n2[0] * i2 + r2[0] * s2 + a2[0] * c2 + e2[0] * f2, t2[1] = n2[1] * i2 + r2[1] * s2 + a2[1] * c2 + e2[1] * f2, t2[2] = n2[2] * i2 + r2[2] * s2 + a2[2] * c2 + e2[2] * f2, t2;
        }, n.bezier = function(t2, n2, r2, a2, e2, u2) {
          var o2 = 1 - u2, i2 = o2 * o2, s2 = u2 * u2, c2 = i2 * o2, f2 = 3 * u2 * i2, M2 = 3 * s2 * o2, h2 = s2 * u2;
          return t2[0] = n2[0] * c2 + r2[0] * f2 + a2[0] * M2 + e2[0] * h2, t2[1] = n2[1] * c2 + r2[1] * f2 + a2[1] * M2 + e2[1] * h2, t2[2] = n2[2] * c2 + r2[2] * f2 + a2[2] * M2 + e2[2] * h2, t2;
        }, n.random = function(t2, n2) {
          n2 = n2 || 1;
          var r2 = 2 * a.RANDOM() * Math.PI, e2 = 2 * a.RANDOM() - 1, u2 = Math.sqrt(1 - e2 * e2) * n2;
          return t2[0] = Math.cos(r2) * u2, t2[1] = Math.sin(r2) * u2, t2[2] = e2 * n2, t2;
        }, n.transformMat4 = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = r2[3] * a2 + r2[7] * e2 + r2[11] * u2 + r2[15];
          return o2 = o2 || 1, t2[0] = (r2[0] * a2 + r2[4] * e2 + r2[8] * u2 + r2[12]) / o2, t2[1] = (r2[1] * a2 + r2[5] * e2 + r2[9] * u2 + r2[13]) / o2, t2[2] = (r2[2] * a2 + r2[6] * e2 + r2[10] * u2 + r2[14]) / o2, t2;
        }, n.transformMat3 = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2];
          return t2[0] = a2 * r2[0] + e2 * r2[3] + u2 * r2[6], t2[1] = a2 * r2[1] + e2 * r2[4] + u2 * r2[7], t2[2] = a2 * r2[2] + e2 * r2[5] + u2 * r2[8], t2;
        }, n.transformQuat = function(t2, n2, r2) {
          var a2 = r2[0], e2 = r2[1], u2 = r2[2], o2 = r2[3], i2 = n2[0], s2 = n2[1], c2 = n2[2], f2 = e2 * c2 - u2 * s2, M2 = u2 * i2 - a2 * c2, h2 = a2 * s2 - e2 * i2, l2 = e2 * h2 - u2 * M2, v2 = u2 * f2 - a2 * h2, d = a2 * M2 - e2 * f2, b = 2 * o2;
          return f2 *= b, M2 *= b, h2 *= b, l2 *= 2, v2 *= 2, d *= 2, t2[0] = i2 + f2 + l2, t2[1] = s2 + M2 + v2, t2[2] = c2 + h2 + d, t2;
        }, n.rotateX = function(t2, n2, r2, a2) {
          var e2 = [], u2 = [];
          return e2[0] = n2[0] - r2[0], e2[1] = n2[1] - r2[1], e2[2] = n2[2] - r2[2], u2[0] = e2[0], u2[1] = e2[1] * Math.cos(a2) - e2[2] * Math.sin(a2), u2[2] = e2[1] * Math.sin(a2) + e2[2] * Math.cos(a2), t2[0] = u2[0] + r2[0], t2[1] = u2[1] + r2[1], t2[2] = u2[2] + r2[2], t2;
        }, n.rotateY = function(t2, n2, r2, a2) {
          var e2 = [], u2 = [];
          return e2[0] = n2[0] - r2[0], e2[1] = n2[1] - r2[1], e2[2] = n2[2] - r2[2], u2[0] = e2[2] * Math.sin(a2) + e2[0] * Math.cos(a2), u2[1] = e2[1], u2[2] = e2[2] * Math.cos(a2) - e2[0] * Math.sin(a2), t2[0] = u2[0] + r2[0], t2[1] = u2[1] + r2[1], t2[2] = u2[2] + r2[2], t2;
        }, n.rotateZ = function(t2, n2, r2, a2) {
          var e2 = [], u2 = [];
          return e2[0] = n2[0] - r2[0], e2[1] = n2[1] - r2[1], e2[2] = n2[2] - r2[2], u2[0] = e2[0] * Math.cos(a2) - e2[1] * Math.sin(a2), u2[1] = e2[0] * Math.sin(a2) + e2[1] * Math.cos(a2), u2[2] = e2[2], t2[0] = u2[0] + r2[0], t2[1] = u2[1] + r2[1], t2[2] = u2[2] + r2[2], t2;
        }, n.angle = function(t2, n2) {
          var r2 = o(t2[0], t2[1], t2[2]), a2 = o(n2[0], n2[1], n2[2]);
          l(r2, r2), l(a2, a2);
          var e2 = v(r2, a2);
          return e2 > 1 ? 0 : e2 < -1 ? Math.PI : Math.acos(e2);
        }, n.str = function(t2) {
          return "vec3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ")";
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o2 = n2[0], i2 = n2[1], s2 = n2[2];
          return Math.abs(r2 - o2) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(o2)) && Math.abs(e2 - i2) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(i2)) && Math.abs(u2 - s2) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(s2));
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e() {
          var t2 = new a.ARRAY_TYPE(3);
          return a.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
        }
        function u(t2) {
          var n2 = t2[0], r2 = t2[1], a2 = t2[2];
          return Math.sqrt(n2 * n2 + r2 * r2 + a2 * a2);
        }
        function o(t2, n2, r2) {
          var e2 = new a.ARRAY_TYPE(3);
          return e2[0] = t2, e2[1] = n2, e2[2] = r2, e2;
        }
        function i(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2[2] = n2[2] - r2[2], t2;
        }
        function s(t2, n2, r2) {
          return t2[0] = n2[0] * r2[0], t2[1] = n2[1] * r2[1], t2[2] = n2[2] * r2[2], t2;
        }
        function c(t2, n2, r2) {
          return t2[0] = n2[0] / r2[0], t2[1] = n2[1] / r2[1], t2[2] = n2[2] / r2[2], t2;
        }
        function f(t2, n2) {
          var r2 = n2[0] - t2[0], a2 = n2[1] - t2[1], e2 = n2[2] - t2[2];
          return Math.sqrt(r2 * r2 + a2 * a2 + e2 * e2);
        }
        function M(t2, n2) {
          var r2 = n2[0] - t2[0], a2 = n2[1] - t2[1], e2 = n2[2] - t2[2];
          return r2 * r2 + a2 * a2 + e2 * e2;
        }
        function h(t2) {
          var n2 = t2[0], r2 = t2[1], a2 = t2[2];
          return n2 * n2 + r2 * r2 + a2 * a2;
        }
        function l(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = r2 * r2 + a2 * a2 + e2 * e2;
          return u2 > 0 && (u2 = 1 / Math.sqrt(u2), t2[0] = n2[0] * u2, t2[1] = n2[1] * u2, t2[2] = n2[2] * u2), t2;
        }
        function v(t2, n2) {
          return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2];
        }
        n.sub = i, n.mul = s, n.div = c, n.dist = f, n.sqrDist = M, n.len = u, n.sqrLen = h, n.forEach = function() {
          var t2 = e();
          return function(n2, r2, a2, e2, u2, o2) {
            var i2 = void 0, s2 = void 0;
            for (r2 || (r2 = 3), a2 || (a2 = 0), s2 = e2 ? Math.min(e2 * r2 + a2, n2.length) : n2.length, i2 = a2; i2 < s2; i2 += r2)
              t2[0] = n2[i2], t2[1] = n2[i2 + 1], t2[2] = n2[i2 + 2], u2(t2, t2, o2), n2[i2] = t2[0], n2[i2 + 1] = t2[1], n2[i2 + 2] = t2[2];
            return n2;
          };
        }();
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.setAxes = n.sqlerp = n.rotationTo = n.equals = n.exactEquals = n.normalize = n.sqrLen = n.squaredLength = n.len = n.length = n.lerp = n.dot = n.scale = n.mul = n.add = n.set = n.copy = n.fromValues = n.clone = void 0, n.create = s, n.identity = function(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
        }, n.setAxisAngle = c, n.getAxisAngle = function(t2, n2) {
          var r2 = 2 * Math.acos(n2[3]), e2 = Math.sin(r2 / 2);
          e2 > a.EPSILON ? (t2[0] = n2[0] / e2, t2[1] = n2[1] / e2, t2[2] = n2[2] / e2) : (t2[0] = 1, t2[1] = 0, t2[2] = 0);
          return r2;
        }, n.multiply = f, n.rotateX = function(t2, n2, r2) {
          r2 *= 0.5;
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = Math.sin(r2), s2 = Math.cos(r2);
          return t2[0] = a2 * s2 + o2 * i2, t2[1] = e2 * s2 + u2 * i2, t2[2] = u2 * s2 - e2 * i2, t2[3] = o2 * s2 - a2 * i2, t2;
        }, n.rotateY = function(t2, n2, r2) {
          r2 *= 0.5;
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = Math.sin(r2), s2 = Math.cos(r2);
          return t2[0] = a2 * s2 - u2 * i2, t2[1] = e2 * s2 + o2 * i2, t2[2] = u2 * s2 + a2 * i2, t2[3] = o2 * s2 - e2 * i2, t2;
        }, n.rotateZ = function(t2, n2, r2) {
          r2 *= 0.5;
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = Math.sin(r2), s2 = Math.cos(r2);
          return t2[0] = a2 * s2 + e2 * i2, t2[1] = e2 * s2 - a2 * i2, t2[2] = u2 * s2 + o2 * i2, t2[3] = o2 * s2 - u2 * i2, t2;
        }, n.calculateW = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2];
          return t2[0] = r2, t2[1] = a2, t2[2] = e2, t2[3] = Math.sqrt(Math.abs(1 - r2 * r2 - a2 * a2 - e2 * e2)), t2;
        }, n.slerp = M, n.random = function(t2) {
          var n2 = a.RANDOM(), r2 = a.RANDOM(), e2 = a.RANDOM(), u2 = Math.sqrt(1 - n2), o2 = Math.sqrt(n2);
          return t2[0] = u2 * Math.sin(2 * Math.PI * r2), t2[1] = u2 * Math.cos(2 * Math.PI * r2), t2[2] = o2 * Math.sin(2 * Math.PI * e2), t2[3] = o2 * Math.cos(2 * Math.PI * e2), t2;
        }, n.invert = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o2 = r2 * r2 + a2 * a2 + e2 * e2 + u2 * u2, i2 = o2 ? 1 / o2 : 0;
          return t2[0] = -r2 * i2, t2[1] = -a2 * i2, t2[2] = -e2 * i2, t2[3] = u2 * i2, t2;
        }, n.conjugate = function(t2, n2) {
          return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = n2[3], t2;
        }, n.fromMat3 = h, n.fromEuler = function(t2, n2, r2, a2) {
          var e2 = 0.5 * Math.PI / 180;
          n2 *= e2, r2 *= e2, a2 *= e2;
          var u2 = Math.sin(n2), o2 = Math.cos(n2), i2 = Math.sin(r2), s2 = Math.cos(r2), c2 = Math.sin(a2), f2 = Math.cos(a2);
          return t2[0] = u2 * s2 * f2 - o2 * i2 * c2, t2[1] = o2 * i2 * f2 + u2 * s2 * c2, t2[2] = o2 * s2 * c2 - u2 * i2 * f2, t2[3] = o2 * s2 * f2 + u2 * i2 * c2, t2;
        }, n.str = function(t2) {
          return "quat(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
        };
        var a = i(r(0)), e = i(r(5)), u = i(r(2)), o = i(r(1));
        function i(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }
        function s() {
          var t2 = new a.ARRAY_TYPE(4);
          return a.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
        }
        function c(t2, n2, r2) {
          r2 *= 0.5;
          var a2 = Math.sin(r2);
          return t2[0] = a2 * n2[0], t2[1] = a2 * n2[1], t2[2] = a2 * n2[2], t2[3] = Math.cos(r2), t2;
        }
        function f(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = r2[0], s2 = r2[1], c2 = r2[2], f2 = r2[3];
          return t2[0] = a2 * f2 + o2 * i2 + e2 * c2 - u2 * s2, t2[1] = e2 * f2 + o2 * s2 + u2 * i2 - a2 * c2, t2[2] = u2 * f2 + o2 * c2 + a2 * s2 - e2 * i2, t2[3] = o2 * f2 - a2 * i2 - e2 * s2 - u2 * c2, t2;
        }
        function M(t2, n2, r2, e2) {
          var u2 = n2[0], o2 = n2[1], i2 = n2[2], s2 = n2[3], c2 = r2[0], f2 = r2[1], M2 = r2[2], h2 = r2[3], l2 = void 0, v2 = void 0, d2 = void 0, b = void 0, m = void 0;
          return (v2 = u2 * c2 + o2 * f2 + i2 * M2 + s2 * h2) < 0 && (v2 = -v2, c2 = -c2, f2 = -f2, M2 = -M2, h2 = -h2), 1 - v2 > a.EPSILON ? (l2 = Math.acos(v2), d2 = Math.sin(l2), b = Math.sin((1 - e2) * l2) / d2, m = Math.sin(e2 * l2) / d2) : (b = 1 - e2, m = e2), t2[0] = b * u2 + m * c2, t2[1] = b * o2 + m * f2, t2[2] = b * i2 + m * M2, t2[3] = b * s2 + m * h2, t2;
        }
        function h(t2, n2) {
          var r2 = n2[0] + n2[4] + n2[8], a2 = void 0;
          if (r2 > 0)
            a2 = Math.sqrt(r2 + 1), t2[3] = 0.5 * a2, a2 = 0.5 / a2, t2[0] = (n2[5] - n2[7]) * a2, t2[1] = (n2[6] - n2[2]) * a2, t2[2] = (n2[1] - n2[3]) * a2;
          else {
            var e2 = 0;
            n2[4] > n2[0] && (e2 = 1), n2[8] > n2[3 * e2 + e2] && (e2 = 2);
            var u2 = (e2 + 1) % 3, o2 = (e2 + 2) % 3;
            a2 = Math.sqrt(n2[3 * e2 + e2] - n2[3 * u2 + u2] - n2[3 * o2 + o2] + 1), t2[e2] = 0.5 * a2, a2 = 0.5 / a2, t2[3] = (n2[3 * u2 + o2] - n2[3 * o2 + u2]) * a2, t2[u2] = (n2[3 * u2 + e2] + n2[3 * e2 + u2]) * a2, t2[o2] = (n2[3 * o2 + e2] + n2[3 * e2 + o2]) * a2;
          }
          return t2;
        }
        n.clone = o.clone, n.fromValues = o.fromValues, n.copy = o.copy, n.set = o.set, n.add = o.add, n.mul = f, n.scale = o.scale, n.dot = o.dot, n.lerp = o.lerp;
        var l = n.length = o.length, v = (n.len = l, n.squaredLength = o.squaredLength), d = (n.sqrLen = v, n.normalize = o.normalize);
        n.exactEquals = o.exactEquals, n.equals = o.equals, n.rotationTo = function() {
          var t2 = u.create(), n2 = u.fromValues(1, 0, 0), r2 = u.fromValues(0, 1, 0);
          return function(a2, e2, o2) {
            var i2 = u.dot(e2, o2);
            return i2 < -0.999999 ? (u.cross(t2, n2, e2), u.len(t2) < 1e-6 && u.cross(t2, r2, e2), u.normalize(t2, t2), c(a2, t2, Math.PI), a2) : i2 > 0.999999 ? (a2[0] = 0, a2[1] = 0, a2[2] = 0, a2[3] = 1, a2) : (u.cross(t2, e2, o2), a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = 1 + i2, d(a2, a2));
          };
        }(), n.sqlerp = function() {
          var t2 = s(), n2 = s();
          return function(r2, a2, e2, u2, o2, i2) {
            return M(t2, a2, o2, i2), M(n2, e2, u2, i2), M(r2, t2, n2, 2 * i2 * (1 - i2)), r2;
          };
        }(), n.setAxes = function() {
          var t2 = e.create();
          return function(n2, r2, a2, e2) {
            return t2[0] = a2[0], t2[3] = a2[1], t2[6] = a2[2], t2[1] = e2[0], t2[4] = e2[1], t2[7] = e2[2], t2[2] = -r2[0], t2[5] = -r2[1], t2[8] = -r2[2], d(n2, h(n2, t2));
          };
        }();
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.sub = n.mul = void 0, n.create = function() {
          var t2 = new a.ARRAY_TYPE(16);
          a.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0);
          return t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(16);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2[6] = t2[6], n2[7] = t2[7], n2[8] = t2[8], n2[9] = t2[9], n2[10] = t2[10], n2[11] = t2[11], n2[12] = t2[12], n2[13] = t2[13], n2[14] = t2[14], n2[15] = t2[15], n2;
        }, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2[9] = n2[9], t2[10] = n2[10], t2[11] = n2[11], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15], t2;
        }, n.fromValues = function(t2, n2, r2, e2, u2, o2, i2, s, c, f, M, h, l, v, d, b) {
          var m = new a.ARRAY_TYPE(16);
          return m[0] = t2, m[1] = n2, m[2] = r2, m[3] = e2, m[4] = u2, m[5] = o2, m[6] = i2, m[7] = s, m[8] = c, m[9] = f, m[10] = M, m[11] = h, m[12] = l, m[13] = v, m[14] = d, m[15] = b, m;
        }, n.set = function(t2, n2, r2, a2, e2, u2, o2, i2, s, c, f, M, h, l, v, d, b) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2[3] = e2, t2[4] = u2, t2[5] = o2, t2[6] = i2, t2[7] = s, t2[8] = c, t2[9] = f, t2[10] = M, t2[11] = h, t2[12] = l, t2[13] = v, t2[14] = d, t2[15] = b, t2;
        }, n.identity = e, n.transpose = function(t2, n2) {
          if (t2 === n2) {
            var r2 = n2[1], a2 = n2[2], e2 = n2[3], u2 = n2[6], o2 = n2[7], i2 = n2[11];
            t2[1] = n2[4], t2[2] = n2[8], t2[3] = n2[12], t2[4] = r2, t2[6] = n2[9], t2[7] = n2[13], t2[8] = a2, t2[9] = u2, t2[11] = n2[14], t2[12] = e2, t2[13] = o2, t2[14] = i2;
          } else
            t2[0] = n2[0], t2[1] = n2[4], t2[2] = n2[8], t2[3] = n2[12], t2[4] = n2[1], t2[5] = n2[5], t2[6] = n2[9], t2[7] = n2[13], t2[8] = n2[2], t2[9] = n2[6], t2[10] = n2[10], t2[11] = n2[14], t2[12] = n2[3], t2[13] = n2[7], t2[14] = n2[11], t2[15] = n2[15];
          return t2;
        }, n.invert = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o2 = n2[4], i2 = n2[5], s = n2[6], c = n2[7], f = n2[8], M = n2[9], h = n2[10], l = n2[11], v = n2[12], d = n2[13], b = n2[14], m = n2[15], p = r2 * i2 - a2 * o2, P = r2 * s - e2 * o2, A = r2 * c - u2 * o2, E = a2 * s - e2 * i2, O = a2 * c - u2 * i2, R = e2 * c - u2 * s, y = f * d - M * v, q = f * b - h * v, x = f * m - l * v, _ = M * b - h * d, Y = M * m - l * d, L = h * m - l * b, S = p * L - P * Y + A * _ + E * x - O * q + R * y;
          if (!S)
            return null;
          return S = 1 / S, t2[0] = (i2 * L - s * Y + c * _) * S, t2[1] = (e2 * Y - a2 * L - u2 * _) * S, t2[2] = (d * R - b * O + m * E) * S, t2[3] = (h * O - M * R - l * E) * S, t2[4] = (s * x - o2 * L - c * q) * S, t2[5] = (r2 * L - e2 * x + u2 * q) * S, t2[6] = (b * A - v * R - m * P) * S, t2[7] = (f * R - h * A + l * P) * S, t2[8] = (o2 * Y - i2 * x + c * y) * S, t2[9] = (a2 * x - r2 * Y - u2 * y) * S, t2[10] = (v * O - d * A + m * p) * S, t2[11] = (M * A - f * O - l * p) * S, t2[12] = (i2 * q - o2 * _ - s * y) * S, t2[13] = (r2 * _ - a2 * q + e2 * y) * S, t2[14] = (d * P - v * E - b * p) * S, t2[15] = (f * E - M * P + h * p) * S, t2;
        }, n.adjoint = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o2 = n2[4], i2 = n2[5], s = n2[6], c = n2[7], f = n2[8], M = n2[9], h = n2[10], l = n2[11], v = n2[12], d = n2[13], b = n2[14], m = n2[15];
          return t2[0] = i2 * (h * m - l * b) - M * (s * m - c * b) + d * (s * l - c * h), t2[1] = -(a2 * (h * m - l * b) - M * (e2 * m - u2 * b) + d * (e2 * l - u2 * h)), t2[2] = a2 * (s * m - c * b) - i2 * (e2 * m - u2 * b) + d * (e2 * c - u2 * s), t2[3] = -(a2 * (s * l - c * h) - i2 * (e2 * l - u2 * h) + M * (e2 * c - u2 * s)), t2[4] = -(o2 * (h * m - l * b) - f * (s * m - c * b) + v * (s * l - c * h)), t2[5] = r2 * (h * m - l * b) - f * (e2 * m - u2 * b) + v * (e2 * l - u2 * h), t2[6] = -(r2 * (s * m - c * b) - o2 * (e2 * m - u2 * b) + v * (e2 * c - u2 * s)), t2[7] = r2 * (s * l - c * h) - o2 * (e2 * l - u2 * h) + f * (e2 * c - u2 * s), t2[8] = o2 * (M * m - l * d) - f * (i2 * m - c * d) + v * (i2 * l - c * M), t2[9] = -(r2 * (M * m - l * d) - f * (a2 * m - u2 * d) + v * (a2 * l - u2 * M)), t2[10] = r2 * (i2 * m - c * d) - o2 * (a2 * m - u2 * d) + v * (a2 * c - u2 * i2), t2[11] = -(r2 * (i2 * l - c * M) - o2 * (a2 * l - u2 * M) + f * (a2 * c - u2 * i2)), t2[12] = -(o2 * (M * b - h * d) - f * (i2 * b - s * d) + v * (i2 * h - s * M)), t2[13] = r2 * (M * b - h * d) - f * (a2 * b - e2 * d) + v * (a2 * h - e2 * M), t2[14] = -(r2 * (i2 * b - s * d) - o2 * (a2 * b - e2 * d) + v * (a2 * s - e2 * i2)), t2[15] = r2 * (i2 * h - s * M) - o2 * (a2 * h - e2 * M) + f * (a2 * s - e2 * i2), t2;
        }, n.determinant = function(t2) {
          var n2 = t2[0], r2 = t2[1], a2 = t2[2], e2 = t2[3], u2 = t2[4], o2 = t2[5], i2 = t2[6], s = t2[7], c = t2[8], f = t2[9], M = t2[10], h = t2[11], l = t2[12], v = t2[13], d = t2[14], b = t2[15];
          return (n2 * o2 - r2 * u2) * (M * b - h * d) - (n2 * i2 - a2 * u2) * (f * b - h * v) + (n2 * s - e2 * u2) * (f * d - M * v) + (r2 * i2 - a2 * o2) * (c * b - h * l) - (r2 * s - e2 * o2) * (c * d - M * l) + (a2 * s - e2 * i2) * (c * v - f * l);
        }, n.multiply = u, n.translate = function(t2, n2, r2) {
          var a2 = r2[0], e2 = r2[1], u2 = r2[2], o2 = void 0, i2 = void 0, s = void 0, c = void 0, f = void 0, M = void 0, h = void 0, l = void 0, v = void 0, d = void 0, b = void 0, m = void 0;
          n2 === t2 ? (t2[12] = n2[0] * a2 + n2[4] * e2 + n2[8] * u2 + n2[12], t2[13] = n2[1] * a2 + n2[5] * e2 + n2[9] * u2 + n2[13], t2[14] = n2[2] * a2 + n2[6] * e2 + n2[10] * u2 + n2[14], t2[15] = n2[3] * a2 + n2[7] * e2 + n2[11] * u2 + n2[15]) : (o2 = n2[0], i2 = n2[1], s = n2[2], c = n2[3], f = n2[4], M = n2[5], h = n2[6], l = n2[7], v = n2[8], d = n2[9], b = n2[10], m = n2[11], t2[0] = o2, t2[1] = i2, t2[2] = s, t2[3] = c, t2[4] = f, t2[5] = M, t2[6] = h, t2[7] = l, t2[8] = v, t2[9] = d, t2[10] = b, t2[11] = m, t2[12] = o2 * a2 + f * e2 + v * u2 + n2[12], t2[13] = i2 * a2 + M * e2 + d * u2 + n2[13], t2[14] = s * a2 + h * e2 + b * u2 + n2[14], t2[15] = c * a2 + l * e2 + m * u2 + n2[15]);
          return t2;
        }, n.scale = function(t2, n2, r2) {
          var a2 = r2[0], e2 = r2[1], u2 = r2[2];
          return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2[4] = n2[4] * e2, t2[5] = n2[5] * e2, t2[6] = n2[6] * e2, t2[7] = n2[7] * e2, t2[8] = n2[8] * u2, t2[9] = n2[9] * u2, t2[10] = n2[10] * u2, t2[11] = n2[11] * u2, t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15], t2;
        }, n.rotate = function(t2, n2, r2, e2) {
          var u2 = e2[0], o2 = e2[1], i2 = e2[2], s = Math.sqrt(u2 * u2 + o2 * o2 + i2 * i2), c = void 0, f = void 0, M = void 0, h = void 0, l = void 0, v = void 0, d = void 0, b = void 0, m = void 0, p = void 0, P = void 0, A = void 0, E = void 0, O = void 0, R = void 0, y = void 0, q = void 0, x = void 0, _ = void 0, Y = void 0, L = void 0, S = void 0, w = void 0, I = void 0;
          if (s < a.EPSILON)
            return null;
          u2 *= s = 1 / s, o2 *= s, i2 *= s, c = Math.sin(r2), f = Math.cos(r2), M = 1 - f, h = n2[0], l = n2[1], v = n2[2], d = n2[3], b = n2[4], m = n2[5], p = n2[6], P = n2[7], A = n2[8], E = n2[9], O = n2[10], R = n2[11], y = u2 * u2 * M + f, q = o2 * u2 * M + i2 * c, x = i2 * u2 * M - o2 * c, _ = u2 * o2 * M - i2 * c, Y = o2 * o2 * M + f, L = i2 * o2 * M + u2 * c, S = u2 * i2 * M + o2 * c, w = o2 * i2 * M - u2 * c, I = i2 * i2 * M + f, t2[0] = h * y + b * q + A * x, t2[1] = l * y + m * q + E * x, t2[2] = v * y + p * q + O * x, t2[3] = d * y + P * q + R * x, t2[4] = h * _ + b * Y + A * L, t2[5] = l * _ + m * Y + E * L, t2[6] = v * _ + p * Y + O * L, t2[7] = d * _ + P * Y + R * L, t2[8] = h * S + b * w + A * I, t2[9] = l * S + m * w + E * I, t2[10] = v * S + p * w + O * I, t2[11] = d * S + P * w + R * I, n2 !== t2 && (t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]);
          return t2;
        }, n.rotateX = function(t2, n2, r2) {
          var a2 = Math.sin(r2), e2 = Math.cos(r2), u2 = n2[4], o2 = n2[5], i2 = n2[6], s = n2[7], c = n2[8], f = n2[9], M = n2[10], h = n2[11];
          n2 !== t2 && (t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]);
          return t2[4] = u2 * e2 + c * a2, t2[5] = o2 * e2 + f * a2, t2[6] = i2 * e2 + M * a2, t2[7] = s * e2 + h * a2, t2[8] = c * e2 - u2 * a2, t2[9] = f * e2 - o2 * a2, t2[10] = M * e2 - i2 * a2, t2[11] = h * e2 - s * a2, t2;
        }, n.rotateY = function(t2, n2, r2) {
          var a2 = Math.sin(r2), e2 = Math.cos(r2), u2 = n2[0], o2 = n2[1], i2 = n2[2], s = n2[3], c = n2[8], f = n2[9], M = n2[10], h = n2[11];
          n2 !== t2 && (t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]);
          return t2[0] = u2 * e2 - c * a2, t2[1] = o2 * e2 - f * a2, t2[2] = i2 * e2 - M * a2, t2[3] = s * e2 - h * a2, t2[8] = u2 * a2 + c * e2, t2[9] = o2 * a2 + f * e2, t2[10] = i2 * a2 + M * e2, t2[11] = s * a2 + h * e2, t2;
        }, n.rotateZ = function(t2, n2, r2) {
          var a2 = Math.sin(r2), e2 = Math.cos(r2), u2 = n2[0], o2 = n2[1], i2 = n2[2], s = n2[3], c = n2[4], f = n2[5], M = n2[6], h = n2[7];
          n2 !== t2 && (t2[8] = n2[8], t2[9] = n2[9], t2[10] = n2[10], t2[11] = n2[11], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]);
          return t2[0] = u2 * e2 + c * a2, t2[1] = o2 * e2 + f * a2, t2[2] = i2 * e2 + M * a2, t2[3] = s * e2 + h * a2, t2[4] = c * e2 - u2 * a2, t2[5] = f * e2 - o2 * a2, t2[6] = M * e2 - i2 * a2, t2[7] = h * e2 - s * a2, t2;
        }, n.fromTranslation = function(t2, n2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = n2[0], t2[13] = n2[1], t2[14] = n2[2], t2[15] = 1, t2;
        }, n.fromScaling = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = n2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = n2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, n.fromRotation = function(t2, n2, r2) {
          var e2 = r2[0], u2 = r2[1], o2 = r2[2], i2 = Math.sqrt(e2 * e2 + u2 * u2 + o2 * o2), s = void 0, c = void 0, f = void 0;
          if (i2 < a.EPSILON)
            return null;
          return e2 *= i2 = 1 / i2, u2 *= i2, o2 *= i2, s = Math.sin(n2), c = Math.cos(n2), f = 1 - c, t2[0] = e2 * e2 * f + c, t2[1] = u2 * e2 * f + o2 * s, t2[2] = o2 * e2 * f - u2 * s, t2[3] = 0, t2[4] = e2 * u2 * f - o2 * s, t2[5] = u2 * u2 * f + c, t2[6] = o2 * u2 * f + e2 * s, t2[7] = 0, t2[8] = e2 * o2 * f + u2 * s, t2[9] = u2 * o2 * f - e2 * s, t2[10] = o2 * o2 * f + c, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, n.fromXRotation = function(t2, n2) {
          var r2 = Math.sin(n2), a2 = Math.cos(n2);
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = r2, t2[7] = 0, t2[8] = 0, t2[9] = -r2, t2[10] = a2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, n.fromYRotation = function(t2, n2) {
          var r2 = Math.sin(n2), a2 = Math.cos(n2);
          return t2[0] = a2, t2[1] = 0, t2[2] = -r2, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = r2, t2[9] = 0, t2[10] = a2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, n.fromZRotation = function(t2, n2) {
          var r2 = Math.sin(n2), a2 = Math.cos(n2);
          return t2[0] = a2, t2[1] = r2, t2[2] = 0, t2[3] = 0, t2[4] = -r2, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, n.fromRotationTranslation = o, n.fromQuat2 = function(t2, n2) {
          var r2 = new a.ARRAY_TYPE(3), e2 = -n2[0], u2 = -n2[1], i2 = -n2[2], s = n2[3], c = n2[4], f = n2[5], M = n2[6], h = n2[7], l = e2 * e2 + u2 * u2 + i2 * i2 + s * s;
          l > 0 ? (r2[0] = 2 * (c * s + h * e2 + f * i2 - M * u2) / l, r2[1] = 2 * (f * s + h * u2 + M * e2 - c * i2) / l, r2[2] = 2 * (M * s + h * i2 + c * u2 - f * e2) / l) : (r2[0] = 2 * (c * s + h * e2 + f * i2 - M * u2), r2[1] = 2 * (f * s + h * u2 + M * e2 - c * i2), r2[2] = 2 * (M * s + h * i2 + c * u2 - f * e2));
          return o(t2, n2, r2), t2;
        }, n.getTranslation = function(t2, n2) {
          return t2[0] = n2[12], t2[1] = n2[13], t2[2] = n2[14], t2;
        }, n.getScaling = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[4], o2 = n2[5], i2 = n2[6], s = n2[8], c = n2[9], f = n2[10];
          return t2[0] = Math.sqrt(r2 * r2 + a2 * a2 + e2 * e2), t2[1] = Math.sqrt(u2 * u2 + o2 * o2 + i2 * i2), t2[2] = Math.sqrt(s * s + c * c + f * f), t2;
        }, n.getRotation = function(t2, n2) {
          var r2 = n2[0] + n2[5] + n2[10], a2 = 0;
          r2 > 0 ? (a2 = 2 * Math.sqrt(r2 + 1), t2[3] = 0.25 * a2, t2[0] = (n2[6] - n2[9]) / a2, t2[1] = (n2[8] - n2[2]) / a2, t2[2] = (n2[1] - n2[4]) / a2) : n2[0] > n2[5] && n2[0] > n2[10] ? (a2 = 2 * Math.sqrt(1 + n2[0] - n2[5] - n2[10]), t2[3] = (n2[6] - n2[9]) / a2, t2[0] = 0.25 * a2, t2[1] = (n2[1] + n2[4]) / a2, t2[2] = (n2[8] + n2[2]) / a2) : n2[5] > n2[10] ? (a2 = 2 * Math.sqrt(1 + n2[5] - n2[0] - n2[10]), t2[3] = (n2[8] - n2[2]) / a2, t2[0] = (n2[1] + n2[4]) / a2, t2[1] = 0.25 * a2, t2[2] = (n2[6] + n2[9]) / a2) : (a2 = 2 * Math.sqrt(1 + n2[10] - n2[0] - n2[5]), t2[3] = (n2[1] - n2[4]) / a2, t2[0] = (n2[8] + n2[2]) / a2, t2[1] = (n2[6] + n2[9]) / a2, t2[2] = 0.25 * a2);
          return t2;
        }, n.fromRotationTranslationScale = function(t2, n2, r2, a2) {
          var e2 = n2[0], u2 = n2[1], o2 = n2[2], i2 = n2[3], s = e2 + e2, c = u2 + u2, f = o2 + o2, M = e2 * s, h = e2 * c, l = e2 * f, v = u2 * c, d = u2 * f, b = o2 * f, m = i2 * s, p = i2 * c, P = i2 * f, A = a2[0], E = a2[1], O = a2[2];
          return t2[0] = (1 - (v + b)) * A, t2[1] = (h + P) * A, t2[2] = (l - p) * A, t2[3] = 0, t2[4] = (h - P) * E, t2[5] = (1 - (M + b)) * E, t2[6] = (d + m) * E, t2[7] = 0, t2[8] = (l + p) * O, t2[9] = (d - m) * O, t2[10] = (1 - (M + v)) * O, t2[11] = 0, t2[12] = r2[0], t2[13] = r2[1], t2[14] = r2[2], t2[15] = 1, t2;
        }, n.fromRotationTranslationScaleOrigin = function(t2, n2, r2, a2, e2) {
          var u2 = n2[0], o2 = n2[1], i2 = n2[2], s = n2[3], c = u2 + u2, f = o2 + o2, M = i2 + i2, h = u2 * c, l = u2 * f, v = u2 * M, d = o2 * f, b = o2 * M, m = i2 * M, p = s * c, P = s * f, A = s * M, E = a2[0], O = a2[1], R = a2[2], y = e2[0], q = e2[1], x = e2[2], _ = (1 - (d + m)) * E, Y = (l + A) * E, L = (v - P) * E, S = (l - A) * O, w = (1 - (h + m)) * O, I = (b + p) * O, N = (v + P) * R, g = (b - p) * R, T = (1 - (h + d)) * R;
          return t2[0] = _, t2[1] = Y, t2[2] = L, t2[3] = 0, t2[4] = S, t2[5] = w, t2[6] = I, t2[7] = 0, t2[8] = N, t2[9] = g, t2[10] = T, t2[11] = 0, t2[12] = r2[0] + y - (_ * y + S * q + N * x), t2[13] = r2[1] + q - (Y * y + w * q + g * x), t2[14] = r2[2] + x - (L * y + I * q + T * x), t2[15] = 1, t2;
        }, n.fromQuat = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o2 = r2 + r2, i2 = a2 + a2, s = e2 + e2, c = r2 * o2, f = a2 * o2, M = a2 * i2, h = e2 * o2, l = e2 * i2, v = e2 * s, d = u2 * o2, b = u2 * i2, m = u2 * s;
          return t2[0] = 1 - M - v, t2[1] = f + m, t2[2] = h - b, t2[3] = 0, t2[4] = f - m, t2[5] = 1 - c - v, t2[6] = l + d, t2[7] = 0, t2[8] = h + b, t2[9] = l - d, t2[10] = 1 - c - M, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, n.frustum = function(t2, n2, r2, a2, e2, u2, o2) {
          var i2 = 1 / (r2 - n2), s = 1 / (e2 - a2), c = 1 / (u2 - o2);
          return t2[0] = 2 * u2 * i2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 2 * u2 * s, t2[6] = 0, t2[7] = 0, t2[8] = (r2 + n2) * i2, t2[9] = (e2 + a2) * s, t2[10] = (o2 + u2) * c, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = o2 * u2 * 2 * c, t2[15] = 0, t2;
        }, n.perspective = function(t2, n2, r2, a2, e2) {
          var u2 = 1 / Math.tan(n2 / 2), o2 = void 0;
          t2[0] = u2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = u2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != e2 && e2 !== 1 / 0 ? (o2 = 1 / (a2 - e2), t2[10] = (e2 + a2) * o2, t2[14] = 2 * e2 * a2 * o2) : (t2[10] = -1, t2[14] = -2 * a2);
          return t2;
        }, n.perspectiveFromFieldOfView = function(t2, n2, r2, a2) {
          var e2 = Math.tan(n2.upDegrees * Math.PI / 180), u2 = Math.tan(n2.downDegrees * Math.PI / 180), o2 = Math.tan(n2.leftDegrees * Math.PI / 180), i2 = Math.tan(n2.rightDegrees * Math.PI / 180), s = 2 / (o2 + i2), c = 2 / (e2 + u2);
          return t2[0] = s, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = c, t2[6] = 0, t2[7] = 0, t2[8] = -(o2 - i2) * s * 0.5, t2[9] = (e2 - u2) * c * 0.5, t2[10] = a2 / (r2 - a2), t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = a2 * r2 / (r2 - a2), t2[15] = 0, t2;
        }, n.ortho = function(t2, n2, r2, a2, e2, u2, o2) {
          var i2 = 1 / (n2 - r2), s = 1 / (a2 - e2), c = 1 / (u2 - o2);
          return t2[0] = -2 * i2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * s, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * c, t2[11] = 0, t2[12] = (n2 + r2) * i2, t2[13] = (e2 + a2) * s, t2[14] = (o2 + u2) * c, t2[15] = 1, t2;
        }, n.lookAt = function(t2, n2, r2, u2) {
          var o2 = void 0, i2 = void 0, s = void 0, c = void 0, f = void 0, M = void 0, h = void 0, l = void 0, v = void 0, d = void 0, b = n2[0], m = n2[1], p = n2[2], P = u2[0], A = u2[1], E = u2[2], O = r2[0], R = r2[1], y = r2[2];
          if (Math.abs(b - O) < a.EPSILON && Math.abs(m - R) < a.EPSILON && Math.abs(p - y) < a.EPSILON)
            return e(t2);
          h = b - O, l = m - R, v = p - y, d = 1 / Math.sqrt(h * h + l * l + v * v), o2 = A * (v *= d) - E * (l *= d), i2 = E * (h *= d) - P * v, s = P * l - A * h, (d = Math.sqrt(o2 * o2 + i2 * i2 + s * s)) ? (o2 *= d = 1 / d, i2 *= d, s *= d) : (o2 = 0, i2 = 0, s = 0);
          c = l * s - v * i2, f = v * o2 - h * s, M = h * i2 - l * o2, (d = Math.sqrt(c * c + f * f + M * M)) ? (c *= d = 1 / d, f *= d, M *= d) : (c = 0, f = 0, M = 0);
          return t2[0] = o2, t2[1] = c, t2[2] = h, t2[3] = 0, t2[4] = i2, t2[5] = f, t2[6] = l, t2[7] = 0, t2[8] = s, t2[9] = M, t2[10] = v, t2[11] = 0, t2[12] = -(o2 * b + i2 * m + s * p), t2[13] = -(c * b + f * m + M * p), t2[14] = -(h * b + l * m + v * p), t2[15] = 1, t2;
        }, n.targetTo = function(t2, n2, r2, a2) {
          var e2 = n2[0], u2 = n2[1], o2 = n2[2], i2 = a2[0], s = a2[1], c = a2[2], f = e2 - r2[0], M = u2 - r2[1], h = o2 - r2[2], l = f * f + M * M + h * h;
          l > 0 && (l = 1 / Math.sqrt(l), f *= l, M *= l, h *= l);
          var v = s * h - c * M, d = c * f - i2 * h, b = i2 * M - s * f;
          (l = v * v + d * d + b * b) > 0 && (l = 1 / Math.sqrt(l), v *= l, d *= l, b *= l);
          return t2[0] = v, t2[1] = d, t2[2] = b, t2[3] = 0, t2[4] = M * b - h * d, t2[5] = h * v - f * b, t2[6] = f * d - M * v, t2[7] = 0, t2[8] = f, t2[9] = M, t2[10] = h, t2[11] = 0, t2[12] = e2, t2[13] = u2, t2[14] = o2, t2[15] = 1, t2;
        }, n.str = function(t2) {
          return "mat4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ", " + t2[9] + ", " + t2[10] + ", " + t2[11] + ", " + t2[12] + ", " + t2[13] + ", " + t2[14] + ", " + t2[15] + ")";
        }, n.frob = function(t2) {
          return Math.sqrt(Math.pow(t2[0], 2) + Math.pow(t2[1], 2) + Math.pow(t2[2], 2) + Math.pow(t2[3], 2) + Math.pow(t2[4], 2) + Math.pow(t2[5], 2) + Math.pow(t2[6], 2) + Math.pow(t2[7], 2) + Math.pow(t2[8], 2) + Math.pow(t2[9], 2) + Math.pow(t2[10], 2) + Math.pow(t2[11], 2) + Math.pow(t2[12], 2) + Math.pow(t2[13], 2) + Math.pow(t2[14], 2) + Math.pow(t2[15], 2));
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2[3] = n2[3] + r2[3], t2[4] = n2[4] + r2[4], t2[5] = n2[5] + r2[5], t2[6] = n2[6] + r2[6], t2[7] = n2[7] + r2[7], t2[8] = n2[8] + r2[8], t2[9] = n2[9] + r2[9], t2[10] = n2[10] + r2[10], t2[11] = n2[11] + r2[11], t2[12] = n2[12] + r2[12], t2[13] = n2[13] + r2[13], t2[14] = n2[14] + r2[14], t2[15] = n2[15] + r2[15], t2;
        }, n.subtract = i, n.multiplyScalar = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2[4] = n2[4] * r2, t2[5] = n2[5] * r2, t2[6] = n2[6] * r2, t2[7] = n2[7] * r2, t2[8] = n2[8] * r2, t2[9] = n2[9] * r2, t2[10] = n2[10] * r2, t2[11] = n2[11] * r2, t2[12] = n2[12] * r2, t2[13] = n2[13] * r2, t2[14] = n2[14] * r2, t2[15] = n2[15] * r2, t2;
        }, n.multiplyScalarAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2[2] = n2[2] + r2[2] * a2, t2[3] = n2[3] + r2[3] * a2, t2[4] = n2[4] + r2[4] * a2, t2[5] = n2[5] + r2[5] * a2, t2[6] = n2[6] + r2[6] * a2, t2[7] = n2[7] + r2[7] * a2, t2[8] = n2[8] + r2[8] * a2, t2[9] = n2[9] + r2[9] * a2, t2[10] = n2[10] + r2[10] * a2, t2[11] = n2[11] + r2[11] * a2, t2[12] = n2[12] + r2[12] * a2, t2[13] = n2[13] + r2[13] * a2, t2[14] = n2[14] + r2[14] * a2, t2[15] = n2[15] + r2[15] * a2, t2;
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5] && t2[6] === n2[6] && t2[7] === n2[7] && t2[8] === n2[8] && t2[9] === n2[9] && t2[10] === n2[10] && t2[11] === n2[11] && t2[12] === n2[12] && t2[13] === n2[13] && t2[14] === n2[14] && t2[15] === n2[15];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o2 = t2[3], i2 = t2[4], s = t2[5], c = t2[6], f = t2[7], M = t2[8], h = t2[9], l = t2[10], v = t2[11], d = t2[12], b = t2[13], m = t2[14], p = t2[15], P = n2[0], A = n2[1], E = n2[2], O = n2[3], R = n2[4], y = n2[5], q = n2[6], x = n2[7], _ = n2[8], Y = n2[9], L = n2[10], S = n2[11], w = n2[12], I = n2[13], N = n2[14], g = n2[15];
          return Math.abs(r2 - P) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(P)) && Math.abs(e2 - A) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(A)) && Math.abs(u2 - E) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(E)) && Math.abs(o2 - O) <= a.EPSILON * Math.max(1, Math.abs(o2), Math.abs(O)) && Math.abs(i2 - R) <= a.EPSILON * Math.max(1, Math.abs(i2), Math.abs(R)) && Math.abs(s - y) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(y)) && Math.abs(c - q) <= a.EPSILON * Math.max(1, Math.abs(c), Math.abs(q)) && Math.abs(f - x) <= a.EPSILON * Math.max(1, Math.abs(f), Math.abs(x)) && Math.abs(M - _) <= a.EPSILON * Math.max(1, Math.abs(M), Math.abs(_)) && Math.abs(h - Y) <= a.EPSILON * Math.max(1, Math.abs(h), Math.abs(Y)) && Math.abs(l - L) <= a.EPSILON * Math.max(1, Math.abs(l), Math.abs(L)) && Math.abs(v - S) <= a.EPSILON * Math.max(1, Math.abs(v), Math.abs(S)) && Math.abs(d - w) <= a.EPSILON * Math.max(1, Math.abs(d), Math.abs(w)) && Math.abs(b - I) <= a.EPSILON * Math.max(1, Math.abs(b), Math.abs(I)) && Math.abs(m - N) <= a.EPSILON * Math.max(1, Math.abs(m), Math.abs(N)) && Math.abs(p - g) <= a.EPSILON * Math.max(1, Math.abs(p), Math.abs(g));
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function u(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = n2[4], s = n2[5], c = n2[6], f = n2[7], M = n2[8], h = n2[9], l = n2[10], v = n2[11], d = n2[12], b = n2[13], m = n2[14], p = n2[15], P = r2[0], A = r2[1], E = r2[2], O = r2[3];
          return t2[0] = P * a2 + A * i2 + E * M + O * d, t2[1] = P * e2 + A * s + E * h + O * b, t2[2] = P * u2 + A * c + E * l + O * m, t2[3] = P * o2 + A * f + E * v + O * p, P = r2[4], A = r2[5], E = r2[6], O = r2[7], t2[4] = P * a2 + A * i2 + E * M + O * d, t2[5] = P * e2 + A * s + E * h + O * b, t2[6] = P * u2 + A * c + E * l + O * m, t2[7] = P * o2 + A * f + E * v + O * p, P = r2[8], A = r2[9], E = r2[10], O = r2[11], t2[8] = P * a2 + A * i2 + E * M + O * d, t2[9] = P * e2 + A * s + E * h + O * b, t2[10] = P * u2 + A * c + E * l + O * m, t2[11] = P * o2 + A * f + E * v + O * p, P = r2[12], A = r2[13], E = r2[14], O = r2[15], t2[12] = P * a2 + A * i2 + E * M + O * d, t2[13] = P * e2 + A * s + E * h + O * b, t2[14] = P * u2 + A * c + E * l + O * m, t2[15] = P * o2 + A * f + E * v + O * p, t2;
        }
        function o(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = a2 + a2, s = e2 + e2, c = u2 + u2, f = a2 * i2, M = a2 * s, h = a2 * c, l = e2 * s, v = e2 * c, d = u2 * c, b = o2 * i2, m = o2 * s, p = o2 * c;
          return t2[0] = 1 - (l + d), t2[1] = M + p, t2[2] = h - m, t2[3] = 0, t2[4] = M - p, t2[5] = 1 - (f + d), t2[6] = v + b, t2[7] = 0, t2[8] = h + m, t2[9] = v - b, t2[10] = 1 - (f + l), t2[11] = 0, t2[12] = r2[0], t2[13] = r2[1], t2[14] = r2[2], t2[15] = 1, t2;
        }
        function i(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2[2] = n2[2] - r2[2], t2[3] = n2[3] - r2[3], t2[4] = n2[4] - r2[4], t2[5] = n2[5] - r2[5], t2[6] = n2[6] - r2[6], t2[7] = n2[7] - r2[7], t2[8] = n2[8] - r2[8], t2[9] = n2[9] - r2[9], t2[10] = n2[10] - r2[10], t2[11] = n2[11] - r2[11], t2[12] = n2[12] - r2[12], t2[13] = n2[13] - r2[13], t2[14] = n2[14] - r2[14], t2[15] = n2[15] - r2[15], t2;
        }
        n.mul = u, n.sub = i;
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.sub = n.mul = void 0, n.create = function() {
          var t2 = new a.ARRAY_TYPE(9);
          a.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0);
          return t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }, n.fromMat4 = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[4], t2[4] = n2[5], t2[5] = n2[6], t2[6] = n2[8], t2[7] = n2[9], t2[8] = n2[10], t2;
        }, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(9);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2[6] = t2[6], n2[7] = t2[7], n2[8] = t2[8], n2;
        }, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2;
        }, n.fromValues = function(t2, n2, r2, e2, u2, o, i, s, c) {
          var f = new a.ARRAY_TYPE(9);
          return f[0] = t2, f[1] = n2, f[2] = r2, f[3] = e2, f[4] = u2, f[5] = o, f[6] = i, f[7] = s, f[8] = c, f;
        }, n.set = function(t2, n2, r2, a2, e2, u2, o, i, s, c) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2[3] = e2, t2[4] = u2, t2[5] = o, t2[6] = i, t2[7] = s, t2[8] = c, t2;
        }, n.identity = function(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, n.transpose = function(t2, n2) {
          if (t2 === n2) {
            var r2 = n2[1], a2 = n2[2], e2 = n2[5];
            t2[1] = n2[3], t2[2] = n2[6], t2[3] = r2, t2[5] = n2[7], t2[6] = a2, t2[7] = e2;
          } else
            t2[0] = n2[0], t2[1] = n2[3], t2[2] = n2[6], t2[3] = n2[1], t2[4] = n2[4], t2[5] = n2[7], t2[6] = n2[2], t2[7] = n2[5], t2[8] = n2[8];
          return t2;
        }, n.invert = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o = n2[4], i = n2[5], s = n2[6], c = n2[7], f = n2[8], M = f * o - i * c, h = -f * u2 + i * s, l = c * u2 - o * s, v = r2 * M + a2 * h + e2 * l;
          if (!v)
            return null;
          return v = 1 / v, t2[0] = M * v, t2[1] = (-f * a2 + e2 * c) * v, t2[2] = (i * a2 - e2 * o) * v, t2[3] = h * v, t2[4] = (f * r2 - e2 * s) * v, t2[5] = (-i * r2 + e2 * u2) * v, t2[6] = l * v, t2[7] = (-c * r2 + a2 * s) * v, t2[8] = (o * r2 - a2 * u2) * v, t2;
        }, n.adjoint = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o = n2[4], i = n2[5], s = n2[6], c = n2[7], f = n2[8];
          return t2[0] = o * f - i * c, t2[1] = e2 * c - a2 * f, t2[2] = a2 * i - e2 * o, t2[3] = i * s - u2 * f, t2[4] = r2 * f - e2 * s, t2[5] = e2 * u2 - r2 * i, t2[6] = u2 * c - o * s, t2[7] = a2 * s - r2 * c, t2[8] = r2 * o - a2 * u2, t2;
        }, n.determinant = function(t2) {
          var n2 = t2[0], r2 = t2[1], a2 = t2[2], e2 = t2[3], u2 = t2[4], o = t2[5], i = t2[6], s = t2[7], c = t2[8];
          return n2 * (c * u2 - o * s) + r2 * (-c * e2 + o * i) + a2 * (s * e2 - u2 * i);
        }, n.multiply = e, n.translate = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = n2[6], f = n2[7], M = n2[8], h = r2[0], l = r2[1];
          return t2[0] = a2, t2[1] = e2, t2[2] = u2, t2[3] = o, t2[4] = i, t2[5] = s, t2[6] = h * a2 + l * o + c, t2[7] = h * e2 + l * i + f, t2[8] = h * u2 + l * s + M, t2;
        }, n.rotate = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = n2[6], f = n2[7], M = n2[8], h = Math.sin(r2), l = Math.cos(r2);
          return t2[0] = l * a2 + h * o, t2[1] = l * e2 + h * i, t2[2] = l * u2 + h * s, t2[3] = l * o - h * a2, t2[4] = l * i - h * e2, t2[5] = l * s - h * u2, t2[6] = c, t2[7] = f, t2[8] = M, t2;
        }, n.scale = function(t2, n2, r2) {
          var a2 = r2[0], e2 = r2[1];
          return t2[0] = a2 * n2[0], t2[1] = a2 * n2[1], t2[2] = a2 * n2[2], t2[3] = e2 * n2[3], t2[4] = e2 * n2[4], t2[5] = e2 * n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2;
        }, n.fromTranslation = function(t2, n2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = n2[0], t2[7] = n2[1], t2[8] = 1, t2;
        }, n.fromRotation = function(t2, n2) {
          var r2 = Math.sin(n2), a2 = Math.cos(n2);
          return t2[0] = a2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = a2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, n.fromScaling = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = n2[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, n.fromMat2d = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = 0, t2[3] = n2[2], t2[4] = n2[3], t2[5] = 0, t2[6] = n2[4], t2[7] = n2[5], t2[8] = 1, t2;
        }, n.fromQuat = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o = r2 + r2, i = a2 + a2, s = e2 + e2, c = r2 * o, f = a2 * o, M = a2 * i, h = e2 * o, l = e2 * i, v = e2 * s, d = u2 * o, b = u2 * i, m = u2 * s;
          return t2[0] = 1 - M - v, t2[3] = f - m, t2[6] = h + b, t2[1] = f + m, t2[4] = 1 - c - v, t2[7] = l - d, t2[2] = h - b, t2[5] = l + d, t2[8] = 1 - c - M, t2;
        }, n.normalFromMat4 = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o = n2[4], i = n2[5], s = n2[6], c = n2[7], f = n2[8], M = n2[9], h = n2[10], l = n2[11], v = n2[12], d = n2[13], b = n2[14], m = n2[15], p = r2 * i - a2 * o, P = r2 * s - e2 * o, A = r2 * c - u2 * o, E = a2 * s - e2 * i, O = a2 * c - u2 * i, R = e2 * c - u2 * s, y = f * d - M * v, q = f * b - h * v, x = f * m - l * v, _ = M * b - h * d, Y = M * m - l * d, L = h * m - l * b, S = p * L - P * Y + A * _ + E * x - O * q + R * y;
          if (!S)
            return null;
          return S = 1 / S, t2[0] = (i * L - s * Y + c * _) * S, t2[1] = (s * x - o * L - c * q) * S, t2[2] = (o * Y - i * x + c * y) * S, t2[3] = (e2 * Y - a2 * L - u2 * _) * S, t2[4] = (r2 * L - e2 * x + u2 * q) * S, t2[5] = (a2 * x - r2 * Y - u2 * y) * S, t2[6] = (d * R - b * O + m * E) * S, t2[7] = (b * A - v * R - m * P) * S, t2[8] = (v * O - d * A + m * p) * S, t2;
        }, n.projection = function(t2, n2, r2) {
          return t2[0] = 2 / n2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = -2 / r2, t2[5] = 0, t2[6] = -1, t2[7] = 1, t2[8] = 1, t2;
        }, n.str = function(t2) {
          return "mat3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ")";
        }, n.frob = function(t2) {
          return Math.sqrt(Math.pow(t2[0], 2) + Math.pow(t2[1], 2) + Math.pow(t2[2], 2) + Math.pow(t2[3], 2) + Math.pow(t2[4], 2) + Math.pow(t2[5], 2) + Math.pow(t2[6], 2) + Math.pow(t2[7], 2) + Math.pow(t2[8], 2));
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2[3] = n2[3] + r2[3], t2[4] = n2[4] + r2[4], t2[5] = n2[5] + r2[5], t2[6] = n2[6] + r2[6], t2[7] = n2[7] + r2[7], t2[8] = n2[8] + r2[8], t2;
        }, n.subtract = u, n.multiplyScalar = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2[4] = n2[4] * r2, t2[5] = n2[5] * r2, t2[6] = n2[6] * r2, t2[7] = n2[7] * r2, t2[8] = n2[8] * r2, t2;
        }, n.multiplyScalarAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2[2] = n2[2] + r2[2] * a2, t2[3] = n2[3] + r2[3] * a2, t2[4] = n2[4] + r2[4] * a2, t2[5] = n2[5] + r2[5] * a2, t2[6] = n2[6] + r2[6] * a2, t2[7] = n2[7] + r2[7] * a2, t2[8] = n2[8] + r2[8] * a2, t2;
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5] && t2[6] === n2[6] && t2[7] === n2[7] && t2[8] === n2[8];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o = t2[3], i = t2[4], s = t2[5], c = t2[6], f = t2[7], M = t2[8], h = n2[0], l = n2[1], v = n2[2], d = n2[3], b = n2[4], m = n2[5], p = n2[6], P = n2[7], A = n2[8];
          return Math.abs(r2 - h) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(h)) && Math.abs(e2 - l) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(l)) && Math.abs(u2 - v) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(v)) && Math.abs(o - d) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(i - b) <= a.EPSILON * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(s - m) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(c - p) <= a.EPSILON * Math.max(1, Math.abs(c), Math.abs(p)) && Math.abs(f - P) <= a.EPSILON * Math.max(1, Math.abs(f), Math.abs(P)) && Math.abs(M - A) <= a.EPSILON * Math.max(1, Math.abs(M), Math.abs(A));
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = n2[6], f = n2[7], M = n2[8], h = r2[0], l = r2[1], v = r2[2], d = r2[3], b = r2[4], m = r2[5], p = r2[6], P = r2[7], A = r2[8];
          return t2[0] = h * a2 + l * o + v * c, t2[1] = h * e2 + l * i + v * f, t2[2] = h * u2 + l * s + v * M, t2[3] = d * a2 + b * o + m * c, t2[4] = d * e2 + b * i + m * f, t2[5] = d * u2 + b * s + m * M, t2[6] = p * a2 + P * o + A * c, t2[7] = p * e2 + P * i + A * f, t2[8] = p * u2 + P * s + A * M, t2;
        }
        function u(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2[2] = n2[2] - r2[2], t2[3] = n2[3] - r2[3], t2[4] = n2[4] - r2[4], t2[5] = n2[5] - r2[5], t2[6] = n2[6] - r2[6], t2[7] = n2[7] - r2[7], t2[8] = n2[8] - r2[8], t2;
        }
        n.mul = e, n.sub = u;
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.forEach = n.sqrLen = n.sqrDist = n.dist = n.div = n.mul = n.sub = n.len = void 0, n.create = e, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(2);
          return n2[0] = t2[0], n2[1] = t2[1], n2;
        }, n.fromValues = function(t2, n2) {
          var r2 = new a.ARRAY_TYPE(2);
          return r2[0] = t2, r2[1] = n2, r2;
        }, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2;
        }, n.set = function(t2, n2, r2) {
          return t2[0] = n2, t2[1] = r2, t2;
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2;
        }, n.subtract = u, n.multiply = o, n.divide = i, n.ceil = function(t2, n2) {
          return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2;
        }, n.floor = function(t2, n2) {
          return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2;
        }, n.min = function(t2, n2, r2) {
          return t2[0] = Math.min(n2[0], r2[0]), t2[1] = Math.min(n2[1], r2[1]), t2;
        }, n.max = function(t2, n2, r2) {
          return t2[0] = Math.max(n2[0], r2[0]), t2[1] = Math.max(n2[1], r2[1]), t2;
        }, n.round = function(t2, n2) {
          return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2;
        }, n.scale = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2;
        }, n.scaleAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2;
        }, n.distance = s, n.squaredDistance = c, n.length = f, n.squaredLength = M, n.negate = function(t2, n2) {
          return t2[0] = -n2[0], t2[1] = -n2[1], t2;
        }, n.inverse = function(t2, n2) {
          return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2;
        }, n.normalize = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = r2 * r2 + a2 * a2;
          e2 > 0 && (e2 = 1 / Math.sqrt(e2), t2[0] = n2[0] * e2, t2[1] = n2[1] * e2);
          return t2;
        }, n.dot = function(t2, n2) {
          return t2[0] * n2[0] + t2[1] * n2[1];
        }, n.cross = function(t2, n2, r2) {
          var a2 = n2[0] * r2[1] - n2[1] * r2[0];
          return t2[0] = t2[1] = 0, t2[2] = a2, t2;
        }, n.lerp = function(t2, n2, r2, a2) {
          var e2 = n2[0], u2 = n2[1];
          return t2[0] = e2 + a2 * (r2[0] - e2), t2[1] = u2 + a2 * (r2[1] - u2), t2;
        }, n.random = function(t2, n2) {
          n2 = n2 || 1;
          var r2 = 2 * a.RANDOM() * Math.PI;
          return t2[0] = Math.cos(r2) * n2, t2[1] = Math.sin(r2) * n2, t2;
        }, n.transformMat2 = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1];
          return t2[0] = r2[0] * a2 + r2[2] * e2, t2[1] = r2[1] * a2 + r2[3] * e2, t2;
        }, n.transformMat2d = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1];
          return t2[0] = r2[0] * a2 + r2[2] * e2 + r2[4], t2[1] = r2[1] * a2 + r2[3] * e2 + r2[5], t2;
        }, n.transformMat3 = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1];
          return t2[0] = r2[0] * a2 + r2[3] * e2 + r2[6], t2[1] = r2[1] * a2 + r2[4] * e2 + r2[7], t2;
        }, n.transformMat4 = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1];
          return t2[0] = r2[0] * a2 + r2[4] * e2 + r2[12], t2[1] = r2[1] * a2 + r2[5] * e2 + r2[13], t2;
        }, n.rotate = function(t2, n2, r2, a2) {
          var e2 = n2[0] - r2[0], u2 = n2[1] - r2[1], o2 = Math.sin(a2), i2 = Math.cos(a2);
          return t2[0] = e2 * i2 - u2 * o2 + r2[0], t2[1] = e2 * o2 + u2 * i2 + r2[1], t2;
        }, n.angle = function(t2, n2) {
          var r2 = t2[0], a2 = t2[1], e2 = n2[0], u2 = n2[1], o2 = r2 * r2 + a2 * a2;
          o2 > 0 && (o2 = 1 / Math.sqrt(o2));
          var i2 = e2 * e2 + u2 * u2;
          i2 > 0 && (i2 = 1 / Math.sqrt(i2));
          var s2 = (r2 * e2 + a2 * u2) * o2 * i2;
          return s2 > 1 ? 0 : s2 < -1 ? Math.PI : Math.acos(s2);
        }, n.str = function(t2) {
          return "vec2(" + t2[0] + ", " + t2[1] + ")";
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = n2[0], o2 = n2[1];
          return Math.abs(r2 - u2) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(u2)) && Math.abs(e2 - o2) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(o2));
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e() {
          var t2 = new a.ARRAY_TYPE(2);
          return a.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
        }
        function u(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2;
        }
        function o(t2, n2, r2) {
          return t2[0] = n2[0] * r2[0], t2[1] = n2[1] * r2[1], t2;
        }
        function i(t2, n2, r2) {
          return t2[0] = n2[0] / r2[0], t2[1] = n2[1] / r2[1], t2;
        }
        function s(t2, n2) {
          var r2 = n2[0] - t2[0], a2 = n2[1] - t2[1];
          return Math.sqrt(r2 * r2 + a2 * a2);
        }
        function c(t2, n2) {
          var r2 = n2[0] - t2[0], a2 = n2[1] - t2[1];
          return r2 * r2 + a2 * a2;
        }
        function f(t2) {
          var n2 = t2[0], r2 = t2[1];
          return Math.sqrt(n2 * n2 + r2 * r2);
        }
        function M(t2) {
          var n2 = t2[0], r2 = t2[1];
          return n2 * n2 + r2 * r2;
        }
        n.len = f, n.sub = u, n.mul = o, n.div = i, n.dist = s, n.sqrDist = c, n.sqrLen = M, n.forEach = function() {
          var t2 = e();
          return function(n2, r2, a2, e2, u2, o2) {
            var i2 = void 0, s2 = void 0;
            for (r2 || (r2 = 2), a2 || (a2 = 0), s2 = e2 ? Math.min(e2 * r2 + a2, n2.length) : n2.length, i2 = a2; i2 < s2; i2 += r2)
              t2[0] = n2[i2], t2[1] = n2[i2 + 1], u2(t2, t2, o2), n2[i2] = t2[0], n2[i2 + 1] = t2[1];
            return n2;
          };
        }();
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.sqrLen = n.squaredLength = n.len = n.length = n.dot = n.mul = n.setReal = n.getReal = void 0, n.create = function() {
          var t2 = new a.ARRAY_TYPE(8);
          a.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0);
          return t2[3] = 1, t2;
        }, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(8);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2[6] = t2[6], n2[7] = t2[7], n2;
        }, n.fromValues = function(t2, n2, r2, e2, u2, o2, i2, s2) {
          var c2 = new a.ARRAY_TYPE(8);
          return c2[0] = t2, c2[1] = n2, c2[2] = r2, c2[3] = e2, c2[4] = u2, c2[5] = o2, c2[6] = i2, c2[7] = s2, c2;
        }, n.fromRotationTranslationValues = function(t2, n2, r2, e2, u2, o2, i2) {
          var s2 = new a.ARRAY_TYPE(8);
          s2[0] = t2, s2[1] = n2, s2[2] = r2, s2[3] = e2;
          var c2 = 0.5 * u2, f2 = 0.5 * o2, M2 = 0.5 * i2;
          return s2[4] = c2 * e2 + f2 * r2 - M2 * n2, s2[5] = f2 * e2 + M2 * t2 - c2 * r2, s2[6] = M2 * e2 + c2 * n2 - f2 * t2, s2[7] = -c2 * t2 - f2 * n2 - M2 * r2, s2;
        }, n.fromRotationTranslation = i, n.fromTranslation = function(t2, n2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0.5 * n2[0], t2[5] = 0.5 * n2[1], t2[6] = 0.5 * n2[2], t2[7] = 0, t2;
        }, n.fromRotation = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
        }, n.fromMat4 = function(t2, n2) {
          var r2 = e.create();
          u.getRotation(r2, n2);
          var o2 = new a.ARRAY_TYPE(3);
          return u.getTranslation(o2, n2), i(t2, r2, o2), t2;
        }, n.copy = s, n.identity = function(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
        }, n.set = function(t2, n2, r2, a2, e2, u2, o2, i2, s2) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2[3] = e2, t2[4] = u2, t2[5] = o2, t2[6] = i2, t2[7] = s2, t2;
        }, n.getDual = function(t2, n2) {
          return t2[0] = n2[4], t2[1] = n2[5], t2[2] = n2[6], t2[3] = n2[7], t2;
        }, n.setDual = function(t2, n2) {
          return t2[4] = n2[0], t2[5] = n2[1], t2[6] = n2[2], t2[7] = n2[3], t2;
        }, n.getTranslation = function(t2, n2) {
          var r2 = n2[4], a2 = n2[5], e2 = n2[6], u2 = n2[7], o2 = -n2[0], i2 = -n2[1], s2 = -n2[2], c2 = n2[3];
          return t2[0] = 2 * (r2 * c2 + u2 * o2 + a2 * s2 - e2 * i2), t2[1] = 2 * (a2 * c2 + u2 * i2 + e2 * o2 - r2 * s2), t2[2] = 2 * (e2 * c2 + u2 * s2 + r2 * i2 - a2 * o2), t2;
        }, n.translate = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = 0.5 * r2[0], s2 = 0.5 * r2[1], c2 = 0.5 * r2[2], f2 = n2[4], M2 = n2[5], h2 = n2[6], l = n2[7];
          return t2[0] = a2, t2[1] = e2, t2[2] = u2, t2[3] = o2, t2[4] = o2 * i2 + e2 * c2 - u2 * s2 + f2, t2[5] = o2 * s2 + u2 * i2 - a2 * c2 + M2, t2[6] = o2 * c2 + a2 * s2 - e2 * i2 + h2, t2[7] = -a2 * i2 - e2 * s2 - u2 * c2 + l, t2;
        }, n.rotateX = function(t2, n2, r2) {
          var a2 = -n2[0], u2 = -n2[1], o2 = -n2[2], i2 = n2[3], s2 = n2[4], c2 = n2[5], f2 = n2[6], M2 = n2[7], h2 = s2 * i2 + M2 * a2 + c2 * o2 - f2 * u2, l = c2 * i2 + M2 * u2 + f2 * a2 - s2 * o2, v = f2 * i2 + M2 * o2 + s2 * u2 - c2 * a2, d = M2 * i2 - s2 * a2 - c2 * u2 - f2 * o2;
          return e.rotateX(t2, n2, r2), a2 = t2[0], u2 = t2[1], o2 = t2[2], i2 = t2[3], t2[4] = h2 * i2 + d * a2 + l * o2 - v * u2, t2[5] = l * i2 + d * u2 + v * a2 - h2 * o2, t2[6] = v * i2 + d * o2 + h2 * u2 - l * a2, t2[7] = d * i2 - h2 * a2 - l * u2 - v * o2, t2;
        }, n.rotateY = function(t2, n2, r2) {
          var a2 = -n2[0], u2 = -n2[1], o2 = -n2[2], i2 = n2[3], s2 = n2[4], c2 = n2[5], f2 = n2[6], M2 = n2[7], h2 = s2 * i2 + M2 * a2 + c2 * o2 - f2 * u2, l = c2 * i2 + M2 * u2 + f2 * a2 - s2 * o2, v = f2 * i2 + M2 * o2 + s2 * u2 - c2 * a2, d = M2 * i2 - s2 * a2 - c2 * u2 - f2 * o2;
          return e.rotateY(t2, n2, r2), a2 = t2[0], u2 = t2[1], o2 = t2[2], i2 = t2[3], t2[4] = h2 * i2 + d * a2 + l * o2 - v * u2, t2[5] = l * i2 + d * u2 + v * a2 - h2 * o2, t2[6] = v * i2 + d * o2 + h2 * u2 - l * a2, t2[7] = d * i2 - h2 * a2 - l * u2 - v * o2, t2;
        }, n.rotateZ = function(t2, n2, r2) {
          var a2 = -n2[0], u2 = -n2[1], o2 = -n2[2], i2 = n2[3], s2 = n2[4], c2 = n2[5], f2 = n2[6], M2 = n2[7], h2 = s2 * i2 + M2 * a2 + c2 * o2 - f2 * u2, l = c2 * i2 + M2 * u2 + f2 * a2 - s2 * o2, v = f2 * i2 + M2 * o2 + s2 * u2 - c2 * a2, d = M2 * i2 - s2 * a2 - c2 * u2 - f2 * o2;
          return e.rotateZ(t2, n2, r2), a2 = t2[0], u2 = t2[1], o2 = t2[2], i2 = t2[3], t2[4] = h2 * i2 + d * a2 + l * o2 - v * u2, t2[5] = l * i2 + d * u2 + v * a2 - h2 * o2, t2[6] = v * i2 + d * o2 + h2 * u2 - l * a2, t2[7] = d * i2 - h2 * a2 - l * u2 - v * o2, t2;
        }, n.rotateByQuatAppend = function(t2, n2, r2) {
          var a2 = r2[0], e2 = r2[1], u2 = r2[2], o2 = r2[3], i2 = n2[0], s2 = n2[1], c2 = n2[2], f2 = n2[3];
          return t2[0] = i2 * o2 + f2 * a2 + s2 * u2 - c2 * e2, t2[1] = s2 * o2 + f2 * e2 + c2 * a2 - i2 * u2, t2[2] = c2 * o2 + f2 * u2 + i2 * e2 - s2 * a2, t2[3] = f2 * o2 - i2 * a2 - s2 * e2 - c2 * u2, i2 = n2[4], s2 = n2[5], c2 = n2[6], f2 = n2[7], t2[4] = i2 * o2 + f2 * a2 + s2 * u2 - c2 * e2, t2[5] = s2 * o2 + f2 * e2 + c2 * a2 - i2 * u2, t2[6] = c2 * o2 + f2 * u2 + i2 * e2 - s2 * a2, t2[7] = f2 * o2 - i2 * a2 - s2 * e2 - c2 * u2, t2;
        }, n.rotateByQuatPrepend = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = r2[0], s2 = r2[1], c2 = r2[2], f2 = r2[3];
          return t2[0] = a2 * f2 + o2 * i2 + e2 * c2 - u2 * s2, t2[1] = e2 * f2 + o2 * s2 + u2 * i2 - a2 * c2, t2[2] = u2 * f2 + o2 * c2 + a2 * s2 - e2 * i2, t2[3] = o2 * f2 - a2 * i2 - e2 * s2 - u2 * c2, i2 = r2[4], s2 = r2[5], c2 = r2[6], f2 = r2[7], t2[4] = a2 * f2 + o2 * i2 + e2 * c2 - u2 * s2, t2[5] = e2 * f2 + o2 * s2 + u2 * i2 - a2 * c2, t2[6] = u2 * f2 + o2 * c2 + a2 * s2 - e2 * i2, t2[7] = o2 * f2 - a2 * i2 - e2 * s2 - u2 * c2, t2;
        }, n.rotateAroundAxis = function(t2, n2, r2, e2) {
          if (Math.abs(e2) < a.EPSILON)
            return s(t2, n2);
          var u2 = Math.sqrt(r2[0] * r2[0] + r2[1] * r2[1] + r2[2] * r2[2]);
          e2 *= 0.5;
          var o2 = Math.sin(e2), i2 = o2 * r2[0] / u2, c2 = o2 * r2[1] / u2, f2 = o2 * r2[2] / u2, M2 = Math.cos(e2), h2 = n2[0], l = n2[1], v = n2[2], d = n2[3];
          t2[0] = h2 * M2 + d * i2 + l * f2 - v * c2, t2[1] = l * M2 + d * c2 + v * i2 - h2 * f2, t2[2] = v * M2 + d * f2 + h2 * c2 - l * i2, t2[3] = d * M2 - h2 * i2 - l * c2 - v * f2;
          var b = n2[4], m = n2[5], p = n2[6], P = n2[7];
          return t2[4] = b * M2 + P * i2 + m * f2 - p * c2, t2[5] = m * M2 + P * c2 + p * i2 - b * f2, t2[6] = p * M2 + P * f2 + b * c2 - m * i2, t2[7] = P * M2 - b * i2 - m * c2 - p * f2, t2;
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2[3] = n2[3] + r2[3], t2[4] = n2[4] + r2[4], t2[5] = n2[5] + r2[5], t2[6] = n2[6] + r2[6], t2[7] = n2[7] + r2[7], t2;
        }, n.multiply = c, n.scale = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2[4] = n2[4] * r2, t2[5] = n2[5] * r2, t2[6] = n2[6] * r2, t2[7] = n2[7] * r2, t2;
        }, n.lerp = function(t2, n2, r2, a2) {
          var e2 = 1 - a2;
          f(n2, r2) < 0 && (a2 = -a2);
          return t2[0] = n2[0] * e2 + r2[0] * a2, t2[1] = n2[1] * e2 + r2[1] * a2, t2[2] = n2[2] * e2 + r2[2] * a2, t2[3] = n2[3] * e2 + r2[3] * a2, t2[4] = n2[4] * e2 + r2[4] * a2, t2[5] = n2[5] * e2 + r2[5] * a2, t2[6] = n2[6] * e2 + r2[6] * a2, t2[7] = n2[7] * e2 + r2[7] * a2, t2;
        }, n.invert = function(t2, n2) {
          var r2 = h(n2);
          return t2[0] = -n2[0] / r2, t2[1] = -n2[1] / r2, t2[2] = -n2[2] / r2, t2[3] = n2[3] / r2, t2[4] = -n2[4] / r2, t2[5] = -n2[5] / r2, t2[6] = -n2[6] / r2, t2[7] = n2[7] / r2, t2;
        }, n.conjugate = function(t2, n2) {
          return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = n2[3], t2[4] = -n2[4], t2[5] = -n2[5], t2[6] = -n2[6], t2[7] = n2[7], t2;
        }, n.normalize = function(t2, n2) {
          var r2 = h(n2);
          if (r2 > 0) {
            r2 = Math.sqrt(r2);
            var a2 = n2[0] / r2, e2 = n2[1] / r2, u2 = n2[2] / r2, o2 = n2[3] / r2, i2 = n2[4], s2 = n2[5], c2 = n2[6], f2 = n2[7], M2 = a2 * i2 + e2 * s2 + u2 * c2 + o2 * f2;
            t2[0] = a2, t2[1] = e2, t2[2] = u2, t2[3] = o2, t2[4] = (i2 - a2 * M2) / r2, t2[5] = (s2 - e2 * M2) / r2, t2[6] = (c2 - u2 * M2) / r2, t2[7] = (f2 - o2 * M2) / r2;
          }
          return t2;
        }, n.str = function(t2) {
          return "quat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ")";
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5] && t2[6] === n2[6] && t2[7] === n2[7];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o2 = t2[3], i2 = t2[4], s2 = t2[5], c2 = t2[6], f2 = t2[7], M2 = n2[0], h2 = n2[1], l = n2[2], v = n2[3], d = n2[4], b = n2[5], m = n2[6], p = n2[7];
          return Math.abs(r2 - M2) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(M2)) && Math.abs(e2 - h2) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(h2)) && Math.abs(u2 - l) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(l)) && Math.abs(o2 - v) <= a.EPSILON * Math.max(1, Math.abs(o2), Math.abs(v)) && Math.abs(i2 - d) <= a.EPSILON * Math.max(1, Math.abs(i2), Math.abs(d)) && Math.abs(s2 - b) <= a.EPSILON * Math.max(1, Math.abs(s2), Math.abs(b)) && Math.abs(c2 - m) <= a.EPSILON * Math.max(1, Math.abs(c2), Math.abs(m)) && Math.abs(f2 - p) <= a.EPSILON * Math.max(1, Math.abs(f2), Math.abs(p));
        };
        var a = o(r(0)), e = o(r(3)), u = o(r(4));
        function o(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }
        function i(t2, n2, r2) {
          var a2 = 0.5 * r2[0], e2 = 0.5 * r2[1], u2 = 0.5 * r2[2], o2 = n2[0], i2 = n2[1], s2 = n2[2], c2 = n2[3];
          return t2[0] = o2, t2[1] = i2, t2[2] = s2, t2[3] = c2, t2[4] = a2 * c2 + e2 * s2 - u2 * i2, t2[5] = e2 * c2 + u2 * o2 - a2 * s2, t2[6] = u2 * c2 + a2 * i2 - e2 * o2, t2[7] = -a2 * o2 - e2 * i2 - u2 * s2, t2;
        }
        function s(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2;
        }
        n.getReal = e.copy;
        n.setReal = e.copy;
        function c(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o2 = n2[3], i2 = r2[4], s2 = r2[5], c2 = r2[6], f2 = r2[7], M2 = n2[4], h2 = n2[5], l = n2[6], v = n2[7], d = r2[0], b = r2[1], m = r2[2], p = r2[3];
          return t2[0] = a2 * p + o2 * d + e2 * m - u2 * b, t2[1] = e2 * p + o2 * b + u2 * d - a2 * m, t2[2] = u2 * p + o2 * m + a2 * b - e2 * d, t2[3] = o2 * p - a2 * d - e2 * b - u2 * m, t2[4] = a2 * f2 + o2 * i2 + e2 * c2 - u2 * s2 + M2 * p + v * d + h2 * m - l * b, t2[5] = e2 * f2 + o2 * s2 + u2 * i2 - a2 * c2 + h2 * p + v * b + l * d - M2 * m, t2[6] = u2 * f2 + o2 * c2 + a2 * s2 - e2 * i2 + l * p + v * m + M2 * b - h2 * d, t2[7] = o2 * f2 - a2 * i2 - e2 * s2 - u2 * c2 + v * p - M2 * d - h2 * b - l * m, t2;
        }
        n.mul = c;
        var f = n.dot = e.dot;
        var M = n.length = e.length, h = (n.len = M, n.squaredLength = e.squaredLength);
        n.sqrLen = h;
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.sub = n.mul = void 0, n.create = function() {
          var t2 = new a.ARRAY_TYPE(6);
          a.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0);
          return t2[0] = 1, t2[3] = 1, t2;
        }, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(6);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2;
        }, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2;
        }, n.identity = function(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2;
        }, n.fromValues = function(t2, n2, r2, e2, u2, o) {
          var i = new a.ARRAY_TYPE(6);
          return i[0] = t2, i[1] = n2, i[2] = r2, i[3] = e2, i[4] = u2, i[5] = o, i;
        }, n.set = function(t2, n2, r2, a2, e2, u2, o) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2[3] = e2, t2[4] = u2, t2[5] = o, t2;
        }, n.invert = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o = n2[4], i = n2[5], s = r2 * u2 - a2 * e2;
          if (!s)
            return null;
          return s = 1 / s, t2[0] = u2 * s, t2[1] = -a2 * s, t2[2] = -e2 * s, t2[3] = r2 * s, t2[4] = (e2 * i - u2 * o) * s, t2[5] = (a2 * o - r2 * i) * s, t2;
        }, n.determinant = function(t2) {
          return t2[0] * t2[3] - t2[1] * t2[2];
        }, n.multiply = e, n.rotate = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = Math.sin(r2), f = Math.cos(r2);
          return t2[0] = a2 * f + u2 * c, t2[1] = e2 * f + o * c, t2[2] = a2 * -c + u2 * f, t2[3] = e2 * -c + o * f, t2[4] = i, t2[5] = s, t2;
        }, n.scale = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = r2[0], f = r2[1];
          return t2[0] = a2 * c, t2[1] = e2 * c, t2[2] = u2 * f, t2[3] = o * f, t2[4] = i, t2[5] = s, t2;
        }, n.translate = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = r2[0], f = r2[1];
          return t2[0] = a2, t2[1] = e2, t2[2] = u2, t2[3] = o, t2[4] = a2 * c + u2 * f + i, t2[5] = e2 * c + o * f + s, t2;
        }, n.fromRotation = function(t2, n2) {
          var r2 = Math.sin(n2), a2 = Math.cos(n2);
          return t2[0] = a2, t2[1] = r2, t2[2] = -r2, t2[3] = a2, t2[4] = 0, t2[5] = 0, t2;
        }, n.fromScaling = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = n2[1], t2[4] = 0, t2[5] = 0, t2;
        }, n.fromTranslation = function(t2, n2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = n2[0], t2[5] = n2[1], t2;
        }, n.str = function(t2) {
          return "mat2d(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ")";
        }, n.frob = function(t2) {
          return Math.sqrt(Math.pow(t2[0], 2) + Math.pow(t2[1], 2) + Math.pow(t2[2], 2) + Math.pow(t2[3], 2) + Math.pow(t2[4], 2) + Math.pow(t2[5], 2) + 1);
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2[3] = n2[3] + r2[3], t2[4] = n2[4] + r2[4], t2[5] = n2[5] + r2[5], t2;
        }, n.subtract = u, n.multiplyScalar = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2[4] = n2[4] * r2, t2[5] = n2[5] * r2, t2;
        }, n.multiplyScalarAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2[2] = n2[2] + r2[2] * a2, t2[3] = n2[3] + r2[3] * a2, t2[4] = n2[4] + r2[4] * a2, t2[5] = n2[5] + r2[5] * a2, t2;
        }, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3] && t2[4] === n2[4] && t2[5] === n2[5];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o = t2[3], i = t2[4], s = t2[5], c = n2[0], f = n2[1], M = n2[2], h = n2[3], l = n2[4], v = n2[5];
          return Math.abs(r2 - c) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(c)) && Math.abs(e2 - f) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(f)) && Math.abs(u2 - M) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(M)) && Math.abs(o - h) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(i - l) <= a.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - v) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(v));
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = n2[4], s = n2[5], c = r2[0], f = r2[1], M = r2[2], h = r2[3], l = r2[4], v = r2[5];
          return t2[0] = a2 * c + u2 * f, t2[1] = e2 * c + o * f, t2[2] = a2 * M + u2 * h, t2[3] = e2 * M + o * h, t2[4] = a2 * l + u2 * v + i, t2[5] = e2 * l + o * v + s, t2;
        }
        function u(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2[2] = n2[2] - r2[2], t2[3] = n2[3] - r2[3], t2[4] = n2[4] - r2[4], t2[5] = n2[5] - r2[5], t2;
        }
        n.mul = e, n.sub = u;
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.sub = n.mul = void 0, n.create = function() {
          var t2 = new a.ARRAY_TYPE(4);
          a.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0);
          return t2[0] = 1, t2[3] = 1, t2;
        }, n.clone = function(t2) {
          var n2 = new a.ARRAY_TYPE(4);
          return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2;
        }, n.copy = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2;
        }, n.identity = function(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
        }, n.fromValues = function(t2, n2, r2, e2) {
          var u2 = new a.ARRAY_TYPE(4);
          return u2[0] = t2, u2[1] = n2, u2[2] = r2, u2[3] = e2, u2;
        }, n.set = function(t2, n2, r2, a2, e2) {
          return t2[0] = n2, t2[1] = r2, t2[2] = a2, t2[3] = e2, t2;
        }, n.transpose = function(t2, n2) {
          if (t2 === n2) {
            var r2 = n2[1];
            t2[1] = n2[2], t2[2] = r2;
          } else
            t2[0] = n2[0], t2[1] = n2[2], t2[2] = n2[1], t2[3] = n2[3];
          return t2;
        }, n.invert = function(t2, n2) {
          var r2 = n2[0], a2 = n2[1], e2 = n2[2], u2 = n2[3], o = r2 * u2 - e2 * a2;
          if (!o)
            return null;
          return o = 1 / o, t2[0] = u2 * o, t2[1] = -a2 * o, t2[2] = -e2 * o, t2[3] = r2 * o, t2;
        }, n.adjoint = function(t2, n2) {
          var r2 = n2[0];
          return t2[0] = n2[3], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = r2, t2;
        }, n.determinant = function(t2) {
          return t2[0] * t2[3] - t2[2] * t2[1];
        }, n.multiply = e, n.rotate = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = Math.sin(r2), s = Math.cos(r2);
          return t2[0] = a2 * s + u2 * i, t2[1] = e2 * s + o * i, t2[2] = a2 * -i + u2 * s, t2[3] = e2 * -i + o * s, t2;
        }, n.scale = function(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = r2[0], s = r2[1];
          return t2[0] = a2 * i, t2[1] = e2 * i, t2[2] = u2 * s, t2[3] = o * s, t2;
        }, n.fromRotation = function(t2, n2) {
          var r2 = Math.sin(n2), a2 = Math.cos(n2);
          return t2[0] = a2, t2[1] = r2, t2[2] = -r2, t2[3] = a2, t2;
        }, n.fromScaling = function(t2, n2) {
          return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = n2[1], t2;
        }, n.str = function(t2) {
          return "mat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
        }, n.frob = function(t2) {
          return Math.sqrt(Math.pow(t2[0], 2) + Math.pow(t2[1], 2) + Math.pow(t2[2], 2) + Math.pow(t2[3], 2));
        }, n.LDU = function(t2, n2, r2, a2) {
          return t2[2] = a2[2] / a2[0], r2[0] = a2[0], r2[1] = a2[1], r2[3] = a2[3] - t2[2] * r2[1], [t2, n2, r2];
        }, n.add = function(t2, n2, r2) {
          return t2[0] = n2[0] + r2[0], t2[1] = n2[1] + r2[1], t2[2] = n2[2] + r2[2], t2[3] = n2[3] + r2[3], t2;
        }, n.subtract = u, n.exactEquals = function(t2, n2) {
          return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3];
        }, n.equals = function(t2, n2) {
          var r2 = t2[0], e2 = t2[1], u2 = t2[2], o = t2[3], i = n2[0], s = n2[1], c = n2[2], f = n2[3];
          return Math.abs(r2 - i) <= a.EPSILON * Math.max(1, Math.abs(r2), Math.abs(i)) && Math.abs(e2 - s) <= a.EPSILON * Math.max(1, Math.abs(e2), Math.abs(s)) && Math.abs(u2 - c) <= a.EPSILON * Math.max(1, Math.abs(u2), Math.abs(c)) && Math.abs(o - f) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(f));
        }, n.multiplyScalar = function(t2, n2, r2) {
          return t2[0] = n2[0] * r2, t2[1] = n2[1] * r2, t2[2] = n2[2] * r2, t2[3] = n2[3] * r2, t2;
        }, n.multiplyScalarAndAdd = function(t2, n2, r2, a2) {
          return t2[0] = n2[0] + r2[0] * a2, t2[1] = n2[1] + r2[1] * a2, t2[2] = n2[2] + r2[2] * a2, t2[3] = n2[3] + r2[3] * a2, t2;
        };
        var a = function(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }(r(0));
        function e(t2, n2, r2) {
          var a2 = n2[0], e2 = n2[1], u2 = n2[2], o = n2[3], i = r2[0], s = r2[1], c = r2[2], f = r2[3];
          return t2[0] = a2 * i + u2 * s, t2[1] = e2 * i + o * s, t2[2] = a2 * c + u2 * f, t2[3] = e2 * c + o * f, t2;
        }
        function u(t2, n2, r2) {
          return t2[0] = n2[0] - r2[0], t2[1] = n2[1] - r2[1], t2[2] = n2[2] - r2[2], t2[3] = n2[3] - r2[3], t2;
        }
        n.mul = e, n.sub = u;
      }, function(t, n, r) {
        "use strict";
        Object.defineProperty(n, "__esModule", { value: true }), n.vec4 = n.vec3 = n.vec2 = n.quat2 = n.quat = n.mat4 = n.mat3 = n.mat2d = n.mat2 = n.glMatrix = void 0;
        var a = l(r(0)), e = l(r(9)), u = l(r(8)), o = l(r(5)), i = l(r(4)), s = l(r(3)), c = l(r(7)), f = l(r(6)), M = l(r(2)), h = l(r(1));
        function l(t2) {
          if (t2 && t2.__esModule)
            return t2;
          var n2 = {};
          if (null != t2)
            for (var r2 in t2)
              Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          return n2.default = t2, n2;
        }
        n.glMatrix = a, n.mat2 = e, n.mat2d = u, n.mat3 = o, n.mat4 = i, n.quat = s, n.quat2 = c, n.vec2 = f, n.vec3 = M, n.vec4 = h;
      }]);
    });
  }
});

// ../node_modules/@lookingglass/webxr/dist/webxr.umd.cjs
var require_webxr_umd = __commonJS({
  "../node_modules/@lookingglass/webxr/dist/webxr.umd.cjs"(exports, module) {
    (function(v, k) {
      typeof exports == "object" && typeof module < "u" ? k(exports, (init_api(), __toCommonJS(api_exports)), (init_XRSystem(), __toCommonJS(XRSystem_exports)), (init_WebXRPolyfill(), __toCommonJS(WebXRPolyfill_exports)), require_holoplaycore(), (init_XRDevice(), __toCommonJS(XRDevice_exports)), (init_XRSpace(), __toCommonJS(XRSpace_exports)), require_gl_matrix(), (init_XRWebGLLayer(), __toCommonJS(XRWebGLLayer_exports))) : typeof define == "function" && define.amd ? define(["exports", "@lookingglass/webxr-polyfill/src/api/index", "@lookingglass/webxr-polyfill/src/api/XRSystem", "@lookingglass/webxr-polyfill/src/WebXRPolyfill", "holoplay-core", "@lookingglass/webxr-polyfill/src/devices/XRDevice", "@lookingglass/webxr-polyfill/src/api/XRSpace", "gl-matrix", "@lookingglass/webxr-polyfill/src/api/XRWebGLLayer"], k) : (v = typeof globalThis < "u" ? globalThis : v || self, k(v["Looking Glass WebXR"] = {}, v["@lookingglass/webxr-polyfill/src/api/index"], v["@lookingglass/webxr-polyfill/src/api/XRSystem"], v["@lookingglass/webxr-polyfill/src/WebXRPolyfill"], v.holoPlayCore, v["@lookingglass/webxr-polyfill/src/devices/XRDevice"], v["@lookingglass/webxr-polyfill/src/api/XRSpace"], v.glMatrix, v["@lookingglass/webxr-polyfill/src/api/XRWebGLLayer"]));
    })(exports, function(v, k, V, te, O, ne, ie, g, $) {
      "use strict";
      var Xe = Object.defineProperty;
      var Ve = (v2, k2, V2) => k2 in v2 ? Xe(v2, k2, { enumerable: true, configurable: true, writable: true, value: V2 }) : v2[k2] = V2;
      var x = (v2, k2, V2) => (Ve(v2, typeof k2 != "symbol" ? k2 + "" : k2, V2), V2);
      const G = (n) => n && typeof n == "object" && "default" in n ? n : { default: n };
      function ae(n) {
        if (n && n.__esModule)
          return n;
        const a = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
        if (n) {
          for (const e in n)
            if (e !== "default") {
              const s = Object.getOwnPropertyDescriptor(n, e);
              Object.defineProperty(a, e, s.get ? s : { enumerable: true, get: () => n[e] });
            }
        }
        return a.default = n, Object.freeze(a);
      }
      const Z = G(k), se = G(V), re = G(te), oe = ae(O), le = G(ne), ce = G(ie), ue = G($), q = 1.6;
      var Y;
      (function(n) {
        n[n.Swizzled = 0] = "Swizzled", n[n.Center = 1] = "Center", n[n.Quilt = 2] = "Quilt";
      })(Y || (Y = {}));
      class de extends EventTarget {
        constructor(e) {
          super();
          x(this, "_calibration", { configVersion: "1.0", pitch: { value: 45 }, slope: { value: -5 }, center: { value: -0.5 }, viewCone: { value: 40 }, invView: { value: 1 }, verticalAngle: { value: 0 }, DPI: { value: 338 }, screenW: { value: 250 }, screenH: { value: 250 }, flipImageX: { value: 0 }, flipImageY: { value: 0 }, flipSubp: { value: 0 }, serial: "LKG-DEFAULT-#####" });
          x(this, "_viewControls", { tileHeight: 512, numViews: 48, trackballX: 0, trackballY: 0, targetX: 0, targetY: q, targetZ: -0.5, targetDiam: 2, fovy: 13 / 180 * Math.PI, depthiness: 1.25, inlineView: Y.Center, capturing: false, quiltResolution: 3840, popup: null, XRSession: null, lkgCanvas: null, appCanvas: null });
          x(this, "LookingGlassDetected");
          this._viewControls = { ...this._viewControls, ...e }, this.syncCalibration();
        }
        syncCalibration() {
          new oe.Client((e) => {
            if (e.devices.length < 1) {
              console.log("No Looking Glass devices found");
              return;
            }
            e.devices.length > 1 && console.log("More than one Looking Glass device found... using the first one"), this.calibration = e.devices[0].calibration;
          });
        }
        addEventListener(e, s, t) {
          super.addEventListener(e, s, t);
        }
        onConfigChange() {
          this.dispatchEvent(new Event("on-config-changed"));
        }
        get calibration() {
          return this._calibration;
        }
        set calibration(e) {
          this._calibration = { ...this._calibration, ...e }, this.onConfigChange();
        }
        updateViewControls(e) {
          e != null && (this._viewControls = { ...this._viewControls, ...e }, this.onConfigChange());
        }
        get tileHeight() {
          return Math.round(this.framebufferHeight / this.quiltHeight);
        }
        get quiltResolution() {
          return this._viewControls.quiltResolution;
        }
        set quiltResolution(e) {
          this.updateViewControls({ quiltResolution: e });
        }
        get numViews() {
          return this.quiltWidth * this.quiltHeight;
        }
        get targetX() {
          return this._viewControls.targetX;
        }
        set targetX(e) {
          this.updateViewControls({ targetX: e });
        }
        get targetY() {
          return this._viewControls.targetY;
        }
        set targetY(e) {
          this.updateViewControls({ targetY: e });
        }
        get targetZ() {
          return this._viewControls.targetZ;
        }
        set targetZ(e) {
          this.updateViewControls({ targetZ: e });
        }
        get trackballX() {
          return this._viewControls.trackballX;
        }
        set trackballX(e) {
          this.updateViewControls({ trackballX: e });
        }
        get trackballY() {
          return this._viewControls.trackballY;
        }
        set trackballY(e) {
          this.updateViewControls({ trackballY: e });
        }
        get targetDiam() {
          return this._viewControls.targetDiam;
        }
        set targetDiam(e) {
          this.updateViewControls({ targetDiam: e });
        }
        get fovy() {
          return this._viewControls.fovy;
        }
        set fovy(e) {
          this.updateViewControls({ fovy: e });
        }
        get depthiness() {
          return this._viewControls.depthiness;
        }
        set depthiness(e) {
          this.updateViewControls({ depthiness: e });
        }
        get inlineView() {
          return this._viewControls.inlineView;
        }
        set inlineView(e) {
          this.updateViewControls({ inlineView: e });
        }
        get capturing() {
          return this._viewControls.capturing;
        }
        set capturing(e) {
          this.updateViewControls({ capturing: e });
        }
        get popup() {
          return this._viewControls.popup;
        }
        set popup(e) {
          this.updateViewControls({ popup: e });
        }
        get XRSession() {
          return this._viewControls.XRSession;
        }
        set XRSession(e) {
          this.updateViewControls({ XRSession: e });
        }
        get lkgCanvas() {
          return this._viewControls.lkgCanvas;
        }
        set lkgCanvas(e) {
          this.updateViewControls({ lkgCanvas: e });
        }
        get appCanvas() {
          return this._viewControls.appCanvas;
        }
        set appCanvas(e) {
          this.updateViewControls({ appCanvas: e });
        }
        get aspect() {
          return this._calibration.screenW.value / this._calibration.screenH.value;
        }
        get tileWidth() {
          return Math.round(this.framebufferWidth / this.quiltWidth);
        }
        get framebufferWidth() {
          return this._calibration.screenW.value < 7e3 ? this._viewControls.quiltResolution : 7680;
        }
        get quiltWidth() {
          return this.calibration.screenW.value == 1536 ? 8 : this.calibration.screenW.value == 3840 || this.calibration.screenW.value > 7e3 ? 5 : 8;
        }
        get quiltHeight() {
          return this.calibration.screenW.value == 1536 ? 6 : this.calibration.screenW.value == 3840 || this.calibration.screenW.value > 7e3 ? 9 : 6;
        }
        get framebufferHeight() {
          return this._calibration.screenW.value < 7e3 ? this._viewControls.quiltResolution : 4320;
        }
        get viewCone() {
          return this._calibration.viewCone.value * this.depthiness / 180 * Math.PI;
        }
        get tilt() {
          return this._calibration.screenH.value / (this._calibration.screenW.value * this._calibration.slope.value) * (this._calibration.flipImageX.value ? -1 : 1);
        }
        set tilt(e) {
        }
        get subp() {
          return 1 / (this._calibration.screenW.value * 3);
        }
        get pitch() {
          const e = this._calibration.screenW.value / this._calibration.DPI.value;
          return this._calibration.pitch.value * e * Math.cos(Math.atan(1 / this._calibration.slope.value));
        }
      }
      let j = null;
      function P() {
        return j == null && (j = new de()), j;
      }
      function Q(n) {
        const a = P();
        n != null && a.updateViewControls(n);
      }
      async function fe() {
        const n = P();
        function a() {
          if (n.appCanvas != null)
            try {
              let s = n.appCanvas.toDataURL();
              const t = document.createElement("a");
              t.style.display = "none", t.href = s, t.download = `hologram_qs${n.quiltWidth}x${n.quiltHeight}a${n.aspect}.png`, document.body.appendChild(t), t.click(), document.body.removeChild(t), window.URL.revokeObjectURL(s);
            } catch (s) {
              console.error("Error while capturing canvas data:", s);
            }
        }
        const e = document.getElementById("screenshotbutton");
        e && e.addEventListener("click", () => {
          const s = N.getInstance();
          if (!s) {
            console.warn("LookingGlassXRDevice not initialized");
            return;
          }
          s.captureScreenshot = true, s.screenshotCallback = a;
        });
      }
      function he() {
        var a;
        const n = P();
        if (console.log(n, "for debugging purposes"), n.lkgCanvas == null)
          console.warn("window placement called without a valid XR Session!");
        else {
          let e = function() {
            let r = w.d - w.a, c = w.w - w.s;
            r && c && (r *= Math.sqrt(0.5), c *= Math.sqrt(0.5));
            const u = n.trackballX, p = n.trackballY, E = Math.cos(u) * r - Math.sin(u) * Math.cos(p) * c, A = -Math.sin(p) * c, S = -Math.sin(u) * r - Math.cos(u) * Math.cos(p) * c;
            n.targetX = n.targetX + E * n.targetDiam * 0.03, n.targetY = n.targetY + A * n.targetDiam * 0.03, n.targetZ = n.targetZ + S * n.targetDiam * 0.03, requestAnimationFrame(e);
          };
          const s = document.createElement("style");
          document.head.appendChild(s), (a = s.sheet) == null || a.insertRule("#LookingGlassWebXRControls * { all: revert; font-family: sans-serif }");
          const t = document.createElement("div");
          t.id = "LookingGlassWebXRControls", t.style.position = "fixed", t.style.zIndex = "1000", t.style.padding = "15px", t.style.width = "320px", t.style.maxWidth = "calc(100vw - 18px)", t.style.maxHeight = "calc(100vh - 18px)", t.style.whiteSpace = "nowrap", t.style.background = "rgba(0, 0, 0, 0.6)", t.style.color = "white", t.style.borderRadius = "10px", t.style.right = "15px", t.style.bottom = "15px", t.style.flex = "row";
          const l = document.createElement("div");
          t.appendChild(l), l.style.width = "100%", l.style.textAlign = "center", l.style.fontWeight = "bold", l.style.marginBottom = "8px", l.innerText = "Looking Glass Controls";
          const o = document.createElement("button");
          o.style.display = "block", o.style.margin = "auto", o.style.width = "100%", o.style.height = "35px", o.style.padding = "4px", o.style.marginBottom = "8px", o.style.borderRadius = "8px", o.id = "screenshotbutton", t.appendChild(o), o.innerText = "Save Hologram";
          const d = document.createElement("button");
          d.style.display = "block", d.style.margin = "auto", d.style.width = "100%", d.style.height = "35px", d.style.padding = "4px", d.style.marginBottom = "8px", d.style.borderRadius = "8px", d.id = "copybutton", t.appendChild(d), d.innerText = "Copy Config", d.addEventListener("click", () => {
            pe(n);
          });
          const f = document.createElement("div");
          t.appendChild(f), f.style.width = "290px", f.style.whiteSpace = "normal", f.style.color = "rgba(255,255,255,0.7)", f.style.fontSize = "14px", f.style.margin = "5px 0", f.innerHTML = "Click the popup and use WASD, mouse left/right drag, and scroll.";
          const F = document.createElement("div");
          t.appendChild(F);
          const C = (r, c, u) => {
            const p = u.stringify, E = document.createElement("div");
            E.style.marginBottom = "8px", F.appendChild(E);
            const A = r, S = n[r], y = document.createElement("label");
            E.appendChild(y), y.innerText = u.label, y.setAttribute("for", A), y.style.width = "100px", y.style.display = "inline-block", y.style.textDecoration = "dotted underline 1px", y.style.fontFamily = '"Courier New"', y.style.fontSize = "13px", y.style.fontWeight = "bold", y.title = u.title;
            const m = document.createElement("input");
            E.appendChild(m), Object.assign(m, c), m.id = A, m.title = u.title, m.value = c.value !== void 0 ? c.value : S;
            const B = (b) => {
              n[r] = b, D(b);
            };
            m.oninput = () => {
              const b = c.type === "range" ? parseFloat(m.value) : c.type === "checkbox" ? m.checked : m.value;
              B(b);
            };
            const M = (b) => {
              let I = b(n[r]);
              u.fixRange && (I = u.fixRange(I), m.max = Math.max(parseFloat(m.max), I).toString(), m.min = Math.min(parseFloat(m.min), I).toString()), m.value = I, B(I);
            };
            c.type === "range" && (m.style.width = "110px", m.style.height = "8px", m.onwheel = (b) => {
              M((I) => I + Math.sign(b.deltaX - b.deltaY) * c.step);
            });
            let D = (b) => {
            };
            if (p) {
              const b = document.createElement("span");
              b.style.fontFamily = '"Courier New"', b.style.fontSize = "13px", b.style.marginLeft = "3px", E.appendChild(b), D = (I) => {
                b.innerHTML = p(I);
              }, D(S);
            }
            return M;
          };
          C("fovy", { type: "range", min: 1 / 180 * Math.PI, max: 120.1 / 180 * Math.PI, step: 1 / 180 * Math.PI }, { label: "fov", title: "perspective fov (degrades stereo effect)", fixRange: (r) => Math.max(1 / 180 * Math.PI, Math.min(r, 120.1 / 180 * Math.PI)), stringify: (r) => {
            const c = r / Math.PI * 180, u = Math.atan(Math.tan(r / 2) * n.aspect) * 2 / Math.PI * 180;
            return `${c.toFixed()}&deg;&times;${u.toFixed()}&deg;`;
          } }), C("depthiness", { type: "range", min: 0, max: 2, step: 0.01 }, { label: "depthiness", title: 'exaggerates depth by multiplying the width of the view cone (as reported by the firmware) - can somewhat compensate for depthiness lost using higher fov. 1.25 seems to be most physically accurate on Looking Glass 8.9".', fixRange: (r) => Math.max(0, r), stringify: (r) => `${r.toFixed(2)}x` }), C("inlineView", { type: "range", min: 0, max: 2, step: 1 }, { label: "inline view", title: "what to show inline on the original canvas (swizzled = no overwrite)", fixRange: (r) => Math.max(0, Math.min(r, 2)), stringify: (r) => r === 0 ? "swizzled" : r === 1 ? "center" : r === 2 ? "quilt" : "?" }), n.lkgCanvas.oncontextmenu = (r) => {
            r.preventDefault();
          }, n.lkgCanvas.addEventListener("wheel", (r) => {
            const c = n.targetDiam, u = 1.1, p = Math.log(c) / Math.log(u);
            return n.targetDiam = Math.pow(u, p + r.deltaY * 0.01);
          }), n.lkgCanvas.addEventListener("mousemove", (r) => {
            const c = r.movementX, u = -r.movementY;
            if (r.buttons & 2 || r.buttons & 1 && (r.shiftKey || r.ctrlKey)) {
              const p = n.trackballX, E = n.trackballY, A = -Math.cos(p) * c + Math.sin(p) * Math.sin(E) * u, S = -Math.cos(E) * u, y = Math.sin(p) * c + Math.cos(p) * Math.sin(E) * u;
              n.targetX = n.targetX + A * n.targetDiam * 1e-3, n.targetY = n.targetY + S * n.targetDiam * 1e-3, n.targetZ = n.targetZ + y * n.targetDiam * 1e-3;
            } else
              r.buttons & 1 && (n.trackballX = n.trackballX - c * 0.01, n.trackballY = n.trackballY - u * 0.01);
          });
          const w = { w: 0, a: 0, s: 0, d: 0 };
          return n.lkgCanvas.addEventListener("keydown", (r) => {
            switch (r.code) {
              case "KeyW":
                w.w = 1;
                break;
              case "KeyA":
                w.a = 1;
                break;
              case "KeyS":
                w.s = 1;
                break;
              case "KeyD":
                w.d = 1;
                break;
            }
          }), n.lkgCanvas.addEventListener("keyup", (r) => {
            switch (r.code) {
              case "KeyW":
                w.w = 0;
                break;
              case "KeyA":
                w.a = 0;
                break;
              case "KeyS":
                w.s = 0;
                break;
              case "KeyD":
                w.d = 0;
                break;
            }
          }), requestAnimationFrame(e), setTimeout(() => {
            fe();
          }, 1e3), t;
        }
      }
      function pe(n) {
        let a = n.targetX, e = n.targetY, s = n.targetZ, t = `${Math.round(n.fovy / Math.PI * 180)} * Math.PI / 180`, l = n.targetDiam, o = n.trackballX, d = n.trackballY, f = n.depthiness;
        const F = { targetX: a, targetY: e, targetZ: s, fovy: t, targetDiam: l, trackballX: o, trackballY: d, depthiness: f };
        let C = JSON.stringify(F, null, 4);
        navigator.clipboard.writeText(C);
      }
      let H;
      const me = (n, a) => {
        const e = P();
        if (e.lkgCanvas == null) {
          console.warn("window placement called without a valid XR Session!");
          return;
        } else if (n == false)
          ve(e, H);
        else {
          H == null && (H = he()), e.lkgCanvas.style.position = "fixed", e.lkgCanvas.style.bottom = "0", e.lkgCanvas.style.left = "0", e.lkgCanvas.width = e.calibration.screenW.value, e.lkgCanvas.height = e.calibration.screenH.value, document.body.appendChild(H);
          const s = "getScreenDetails" in window;
          console.log(s, "Screen placement API exists"), s ? be(e.lkgCanvas, e, a) : J(e, e.lkgCanvas, a);
        }
      };
      async function be(n, a, e) {
        const s = await window.getScreenDetails();
        console.log(s);
        const t = s.screens.filter((l) => l.label.includes("LKG"))[0];
        if (console.log(t, "monitors"), t === void 0) {
          console.log("no Looking Glass monitor detected - manually opening popup window"), J(a, n, e);
          return;
        } else {
          console.log("monitor ID", t.label, "serial number", a.calibration);
          const l = [`left=${t.left}`, `top=${t.top}`, `width=${t.width}`, `height=${t.height}`, "menubar=no", "toolbar=no", "location=no", "status=no", "resizable=yes", "scrollbars=no", "fullscreenEnabled=true"].join(",");
          a.popup = window.open("", "new", l), a.popup && (a.popup.document.body.style.background = "black", a.popup.document.body.appendChild(n), console.assert(e), a.popup.onbeforeunload = e);
        }
      }
      function J(n, a, e) {
        n.popup = window.open("", void 0, "width=640,height=360"), n.popup && (n.popup.document.title = "Looking Glass Window (fullscreen me on Looking Glass!)", n.popup.document.body.style.background = "black", n.popup.document.body.appendChild(a), console.assert(e), n.popup.onbeforeunload = e);
      }
      function ve(n, a) {
        var e;
        (e = a.parentElement) == null || e.removeChild(a), n.popup && (n.popup.onbeforeunload = null, n.popup.close(), n.popup = null);
      }
      const X = Symbol("LookingGlassXRWebGLLayer");
      class we extends ue.default {
        constructor(a, e, s) {
          super(a, e, s);
          const t = P();
          t.appCanvas = e.canvas, t.lkgCanvas = document.createElement("canvas"), t.lkgCanvas.tabIndex = 0;
          const l = t.lkgCanvas.getContext("2d", { alpha: false });
          t.lkgCanvas.addEventListener("dblclick", function() {
            this.requestFullscreen();
          });
          const o = this[$.PRIVATE].config, d = e.createTexture();
          let f, F;
          const C = e.createFramebuffer(), w = e.getExtension("OES_vertex_array_object"), r = 34229, c = w ? w.bindVertexArrayOES.bind(w) : e.bindVertexArray.bind(e);
          (o.depth || o.stencil) && (o.depth && o.stencil ? F = { format: e.DEPTH_STENCIL, attachment: e.DEPTH_STENCIL_ATTACHMENT } : o.depth ? F = { format: e.DEPTH_COMPONENT16, attachment: e.DEPTH_ATTACHMENT } : o.stencil && (F = { format: e.STENCIL_INDEX8, attachment: e.STENCIL_ATTACHMENT }), f = e.createRenderbuffer());
          const u = (i, _, R, h, T) => {
            p(i, _, T.framebufferWidth, T.framebufferHeight), R && E(i, R, h, T.framebufferWidth, T.framebufferHeight);
          }, p = (i, _, R, h) => {
            const T = i.getParameter(i.TEXTURE_BINDING_2D);
            i.bindTexture(i.TEXTURE_2D, _), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, R, h, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.bindTexture(i.TEXTURE_2D, T);
          }, E = (i, _, R, h, T) => {
            const L = i.getParameter(i.RENDERBUFFER_BINDING);
            i.bindRenderbuffer(i.RENDERBUFFER, _), i.renderbufferStorage(i.RENDERBUFFER, R.format, h, T), i.bindRenderbuffer(i.RENDERBUFFER, L);
          }, A = (i, _, R, h, T, L) => {
            const K = i.getParameter(i.FRAMEBUFFER_BINDING);
            i.bindFramebuffer(i.FRAMEBUFFER, _), i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, R, 0), (L.depth || L.stencil) && i.framebufferRenderbuffer(i.FRAMEBUFFER, h.attachment, i.RENDERBUFFER, T), i.bindFramebuffer(i.FRAMEBUFFER, K);
          };
          u(e, d, f, F, t), t.addEventListener("on-config-changed", () => u(e, d, f, F, t)), A(e, C, d, F, f, o);
          const S = `
		attribute vec2 a_position;
		varying vec2 v_texcoord;
		void main() {
		  gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
		  v_texcoord = a_position;
		}
	  `;
          function y(i, _, R) {
            const h = i.createShader(_);
            return i.shaderSource(h, R), i.compileShader(h), i.getShaderParameter(h, i.COMPILE_STATUS) ? h : (console.warn(i.getShaderInfoLog(h)), null);
          }
          function m(i, _, R) {
            let h = i.createProgram();
            const T = y(i, i.VERTEX_SHADER, _), L = y(i, i.FRAGMENT_SHADER, R);
            return T === null || L === null ? (console.error("There was a problem with shader construction"), null) : (i.attachShader(h, T), i.attachShader(h, L), i.linkProgram(h), i.getProgramParameter(h, i.LINK_STATUS) ? h : (console.warn(i.getProgramInfoLog(h)), null));
          }
          let B, M, D, b;
          const I = (i, _, R) => {
            const h = R(_);
            if (h === M)
              return;
            M = h;
            const T = y(i, i.FRAGMENT_SHADER, h);
            if (T === null)
              return;
            B && i.deleteShader(B), B = T;
            const L = m(i, S, h);
            if (L === null) {
              console.warn("There was a problem with shader construction");
              return;
            }
            D = i.getAttribLocation(L, "a_position"), b = i.getUniformLocation(L, "u_viewType");
            const K = i.getUniformLocation(L, "u_texture"), Me = i.getParameter(i.CURRENT_PROGRAM);
            i.useProgram(L), i.uniform1i(K, 0), i.useProgram(Me), U && i.deleteProgram(U), U = L;
          };
          let U = m(e, S, O.Shader(t));
          U === null && console.warn("There was a problem with shader construction"), t.addEventListener("on-config-changed", () => {
            I(e, t, O.Shader);
          });
          const ee = w ? w.createVertexArrayOES() : e.createVertexArray(), xe = e.createBuffer(), _e = e.getParameter(e.ARRAY_BUFFER_BINDING), Le = e.getParameter(r);
          c(ee), e.bindBuffer(e.ARRAY_BUFFER, xe), e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW), e.enableVertexAttribArray(D), e.vertexAttribPointer(D, 2, e.FLOAT, false, 0, 0), c(Le), e.bindBuffer(e.ARRAY_BUFFER, _e);
          const ke = () => {
            console.assert(this[X].LookingGlassEnabled), e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer);
            const i = e.getParameter(e.COLOR_CLEAR_VALUE), _ = e.getParameter(e.DEPTH_CLEAR_VALUE), R = e.getParameter(e.STENCIL_CLEAR_VALUE);
            e.clearColor(0, 0, 0, 0), e.clearDepth(1), e.clearStencil(0), e.clear(e.DEPTH_BUFFER_BIT | e.COLOR_BUFFER_BIT | e.STENCIL_BUFFER_BIT), e.clearColor(i[0], i[1], i[2], i[3]), e.clearDepth(_), e.clearStencil(R);
          };
          function Se() {
            if (!t.appCanvas || !t.lkgCanvas)
              return;
            (t.appCanvas.width !== t.framebufferWidth || t.appCanvas.height !== t.framebufferHeight) && (t.appCanvas.width, t.appCanvas.height, t.appCanvas.width = t.framebufferWidth, t.appCanvas.height = t.framebufferHeight);
            const i = Fe();
            Ae(), Ie(), De(), Be(), Pe(i);
          }
          function Pe(i) {
            e.activeTexture(i.activeTexture), e.bindTexture(e.TEXTURE_2D, i.textureBinding), e.useProgram(i.program), e.bindRenderbuffer(e.RENDERBUFFER, i.renderbufferBinding), e.bindFramebuffer(e.FRAMEBUFFER, i.framebufferBinding), i.scissorTest ? e.enable(e.SCISSOR_TEST) : e.disable(e.SCISSOR_TEST), i.stencilTest ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), i.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), i.blend ? e.enable(e.BLEND) : e.disable(e.BLEND), i.cullFace ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), c(i.VAO);
          }
          function Fe() {
            return { VAO: e.getParameter(e.VERTEX_ARRAY_BINDING), cullFace: e.getParameter(e.CULL_FACE), blend: e.getParameter(e.BLEND), depthTest: e.getParameter(e.DEPTH_TEST), stencilTest: e.getParameter(e.STENCIL_TEST), scissorTest: e.getParameter(e.SCISSOR_TEST), viewport: e.getParameter(e.VIEWPORT), framebufferBinding: e.getParameter(e.FRAMEBUFFER_BINDING), renderbufferBinding: e.getParameter(e.RENDERBUFFER_BINDING), program: e.getParameter(e.CURRENT_PROGRAM), activeTexture: e.getParameter(e.ACTIVE_TEXTURE), textureBinding: e.getParameter(e.TEXTURE_BINDING_2D) };
          }
          function Ae() {
            e.bindFramebuffer(e.FRAMEBUFFER, null), e.useProgram(U), c(ee), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, d), e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.viewport(0, 0, e.drawingBufferWidth, e.drawingBufferHeight);
          }
          function Ie() {
            e.uniform1i(b, 0), e.drawArrays(e.TRIANGLES, 0, 6);
          }
          function De() {
            if (!t.lkgCanvas || !t.appCanvas) {
              console.warn("Looking Glass Canvas is not defined");
              return;
            }
            l == null || l.clearRect(0, 0, t.lkgCanvas.width, t.lkgCanvas.height), l == null || l.drawImage(t.appCanvas, 0, 0, t.framebufferWidth, t.framebufferHeight, 0, 0, t.calibration.screenW.value, t.calibration.screenH.value);
          }
          function Be() {
            if (!t.appCanvas) {
              console.warn("Looking Glass Canvas is not defined");
              return;
            }
            t.inlineView !== 0 && (t.capturing && t.appCanvas.width !== t.framebufferWidth && (t.appCanvas.width = t.framebufferWidth, t.appCanvas.height = t.framebufferHeight, e.viewport(0, 0, t.framebufferHeight, t.framebufferWidth)), e.uniform1i(b, t.inlineView), e.drawArrays(e.TRIANGLES, 0, 6));
          }
          window.addEventListener("unload", () => {
            t.popup && t.popup.close(), t.popup = null;
          }), this[X] = { LookingGlassEnabled: false, framebuffer: C, clearFramebuffer: ke, blitTextureToDefaultFramebufferIfNeeded: Se, moveCanvasToWindow: me };
        }
        get framebuffer() {
          return this[X].LookingGlassEnabled ? this[X].framebuffer : null;
        }
        get framebufferWidth() {
          return P().framebufferWidth;
        }
        get framebufferHeight() {
          return P().framebufferHeight;
        }
      }
      const W = class extends le.default {
        constructor(a) {
          super(a), this.sessions = /* @__PURE__ */ new Map(), this.viewSpaces = [], this.basePoseMatrix = g.mat4.create(), this.inlineProjectionMatrix = g.mat4.create(), this.inlineInverseViewMatrix = g.mat4.create(), this.LookingGlassProjectionMatrices = [], this.LookingGlassInverseViewMatrices = [], this.captureScreenshot = false, this.screenshotCallback = null, W.instance || (W.instance = this);
        }
        static getInstance() {
          return W.instance;
        }
        onBaseLayerSet(a, e) {
          const s = this.sessions.get(a);
          s.baseLayer = e;
          const t = P(), l = e[X];
          l.LookingGlassEnabled = s.immersive, s.immersive && (t.XRSession = this.sessions.get(a), t.popup == null ? l.moveCanvasToWindow(true, () => {
            this.endSession(a);
          }) : console.warn("attempted to assign baselayer twice?"));
        }
        isSessionSupported(a) {
          return a === "inline" || a === "immersive-vr";
        }
        isFeatureSupported(a) {
          switch (a) {
            case "viewer":
              return true;
            case "local":
              return true;
            case "local-floor":
              return true;
            case "bounded-floor":
              return false;
            case "unbounded":
              return false;
            default:
              return console.warn("LookingGlassXRDevice.isFeatureSupported: feature not understood:", a), false;
          }
        }
        async requestSession(a, e) {
          if (!this.isSessionSupported(a))
            return Promise.reject();
          const s = a !== "inline", t = new ge(a, e);
          return this.sessions.set(t.id, t), s && this.dispatchEvent("@@webxr-polyfill/vr-present-start", t.id), Promise.resolve(t.id);
        }
        requestAnimationFrame(a) {
          return this.global.requestAnimationFrame(a);
        }
        cancelAnimationFrame(a) {
          this.global.cancelAnimationFrame(a);
        }
        onFrameStart(a, e) {
          const s = this.sessions.get(a), t = P();
          if (s.immersive) {
            const l = Math.tan(0.5 * t.fovy), o = 0.5 * t.targetDiam / l, d = o - t.targetDiam, f = this.basePoseMatrix;
            g.mat4.fromTranslation(f, [t.targetX, t.targetY, t.targetZ]), g.mat4.rotate(f, f, t.trackballX, [0, 1, 0]), g.mat4.rotate(f, f, -t.trackballY, [1, 0, 0]), g.mat4.translate(f, f, [0, 0, o]);
            for (let C = 0; C < t.numViews; ++C) {
              const w = (C + 0.5) / t.numViews - 0.5, r = Math.tan(t.viewCone * w), c = o * r, u = this.LookingGlassInverseViewMatrices[C] = this.LookingGlassInverseViewMatrices[C] || g.mat4.create();
              g.mat4.translate(u, f, [c, 0, 0]), g.mat4.invert(u, u);
              const p = Math.max(d + e.depthNear, 0.01), E = d + e.depthFar, A = p * l, S = A, y = -A, m = p * -r, B = t.aspect * A, M = m + B, D = m - B, b = this.LookingGlassProjectionMatrices[C] = this.LookingGlassProjectionMatrices[C] || g.mat4.create();
              g.mat4.set(b, 2 * p / (M - D), 0, 0, 0, 0, 2 * p / (S - y), 0, 0, (M + D) / (M - D), (S + y) / (S - y), -(E + p) / (E - p), -1, 0, 0, -2 * E * p / (E - p), 0);
            }
            s.baseLayer[X].clearFramebuffer();
          } else {
            const l = s.baseLayer.context, o = l.drawingBufferWidth / l.drawingBufferHeight;
            g.mat4.perspective(this.inlineProjectionMatrix, e.inlineVerticalFieldOfView, o, e.depthNear, e.depthFar), g.mat4.fromTranslation(this.basePoseMatrix, [0, q, 0]), g.mat4.invert(this.inlineInverseViewMatrix, this.basePoseMatrix);
          }
        }
        onFrameEnd(a) {
          this.sessions.get(a).baseLayer[X].blitTextureToDefaultFramebufferIfNeeded(), this.captureScreenshot && this.screenshotCallback && (this.screenshotCallback(), this.captureScreenshot = false);
        }
        async requestFrameOfReferenceTransform(a, e) {
          const s = g.mat4.create();
          switch (a) {
            case "viewer":
            case "local":
              return g.mat4.fromTranslation(s, [0, -q, 0]), s;
            case "local-floor":
              return s;
            default:
              throw new Error("XRReferenceSpaceType not understood");
          }
        }
        endSession(a) {
          const e = this.sessions.get(a);
          e.immersive && e.baseLayer && (e.baseLayer[X].moveCanvasToWindow(false), this.dispatchEvent("@@webxr-polyfill/vr-present-end", a)), e.ended = true;
        }
        doesSessionSupportReferenceSpace(a, e) {
          const s = this.sessions.get(a);
          return s.ended ? false : s.enabledFeatures.has(e);
        }
        getViewSpaces(a) {
          if (a === "immersive-vr") {
            const e = P();
            for (let s = this.viewSpaces.length; s < e.numViews; ++s)
              this.viewSpaces[s] = new Ee(s);
            return this.viewSpaces.length = e.numViews, this.viewSpaces;
          }
        }
        getViewport(a, e, s, t, l) {
          if (l === void 0) {
            const d = this.sessions.get(a).baseLayer.context;
            t.x = 0, t.y = 0, t.width = d.drawingBufferWidth, t.height = d.drawingBufferHeight;
          } else {
            const o = P(), d = l % o.quiltWidth, f = Math.floor(l / o.quiltWidth);
            t.x = o.framebufferWidth / o.quiltWidth * d, t.y = o.framebufferHeight / o.quiltHeight * f, t.width = o.framebufferWidth / o.quiltWidth, t.height = o.framebufferHeight / o.quiltHeight;
          }
          return true;
        }
        getProjectionMatrix(a, e) {
          return e === void 0 ? this.inlineProjectionMatrix : this.LookingGlassProjectionMatrices[e] || g.mat4.create();
        }
        getBasePoseMatrix() {
          return this.basePoseMatrix;
        }
        getBaseViewMatrix() {
          return this.inlineInverseViewMatrix;
        }
        _getViewMatrixByIndex(a) {
          return this.LookingGlassInverseViewMatrices[a] = this.LookingGlassInverseViewMatrices[a] || g.mat4.create();
        }
        getInputSources() {
          return [];
        }
        getInputPose(a, e, s) {
          return null;
        }
        onWindowResize() {
        }
      };
      let N = W;
      x(N, "instance", null);
      let ye = 0;
      class ge {
        constructor(a, e) {
          x(this, "mode");
          x(this, "immersive");
          x(this, "id");
          x(this, "baseLayer");
          x(this, "inlineVerticalFieldOfView");
          x(this, "ended");
          x(this, "enabledFeatures");
          this.mode = a, this.immersive = a === "immersive-vr" || a === "immersive-ar", this.id = ++ye, this.baseLayer = null, this.inlineVerticalFieldOfView = Math.PI * 0.5, this.ended = false, this.enabledFeatures = e;
        }
      }
      class Ee extends ce.default {
        constructor(e) {
          super();
          x(this, "viewIndex");
          this.viewIndex = e;
        }
        get eye() {
          return "none";
        }
        _onPoseUpdate(e) {
          this._inverseBaseMatrix = e._getViewMatrixByIndex(this.viewIndex);
        }
      }
      class z extends re.default {
        constructor(e) {
          super();
          x(this, "vrButton");
          x(this, "device");
          x(this, "isPresenting", false);
          Q(e), this.loadPolyfill();
        }
        static async init(e) {
          new z(e);
        }
        async loadPolyfill() {
          this.overrideDefaultVRButton(), console.warn('Looking Glass WebXR "polyfill" overriding native WebXR API.');
          for (const e in Z.default)
            this.global[e] = Z.default[e];
          this.global.XRWebGLLayer = we, this.injected = true, this.device = new N(this.global), this.xr = new se.default(Promise.resolve(this.device)), Object.defineProperty(this.global.navigator, "xr", { value: this.xr, configurable: true });
        }
        async overrideDefaultVRButton() {
          this.vrButton = await Ce("VRButton"), this.vrButton && this.device ? (this.device.addEventListener("@@webxr-polyfill/vr-present-start", () => {
            this.isPresenting = true, this.updateVRButtonUI();
          }), this.device.addEventListener("@@webxr-polyfill/vr-present-end", () => {
            this.isPresenting = false, this.updateVRButtonUI();
          }), this.vrButton.addEventListener("click", (e) => {
            this.updateVRButtonUI();
          }), this.updateVRButtonUI()) : console.warn("Unable to find VRButton");
        }
        async updateVRButtonUI() {
          if (this.vrButton) {
            await Re(100), this.isPresenting ? this.vrButton.innerHTML = "EXIT LOOKING GLASS" : this.vrButton.innerHTML = "ENTER LOOKING GLASS";
            const e = 220;
            this.vrButton.style.width = `${e}px`, this.vrButton.style.left = `calc(50% - ${e / 2}px)`;
          }
        }
        update(e) {
          Q(e);
        }
      }
      async function Ce(n) {
        return new Promise((a) => {
          const e = new MutationObserver(function(s) {
            s.forEach(function(t) {
              t.addedNodes.forEach(function(l) {
                const o = l;
                o.id === n && (a(o), e.disconnect());
              });
            });
          });
          e.observe(document.body, { subtree: false, childList: true }), setTimeout(() => {
            e.disconnect(), a(null);
          }, 5e3);
        });
      }
      function Re(n) {
        return new Promise((a) => setTimeout(a, n));
      }
      const Te = P();
      v.LookingGlassConfig = Te, v.LookingGlassWebXRPolyfill = z, Object.defineProperties(v, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  }
});

// node_modules/@wonderlandengine/api/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  APIVersion: () => APIVersion,
  Alignment: () => Alignment,
  Animation: () => Animation,
  AnimationComponent: () => AnimationComponent,
  AnimationState: () => AnimationState,
  Collider: () => Collider,
  CollisionComponent: () => CollisionComponent,
  CollisionEventType: () => CollisionEventType,
  Component: () => Component,
  Emitter: () => Emitter,
  ForceMode: () => ForceMode,
  I18N: () => I18N,
  InputComponent: () => InputComponent,
  InputType: () => InputType,
  Justification: () => Justification,
  LightComponent: () => LightComponent,
  LightType: () => LightType,
  LockAxis: () => LockAxis,
  Material: () => Material,
  MaterialParamType: () => MaterialParamType,
  Mesh: () => Mesh,
  MeshAttribute: () => MeshAttribute,
  MeshAttributeAccessor: () => MeshAttributeAccessor,
  MeshComponent: () => MeshComponent,
  MeshIndexType: () => MeshIndexType,
  MeshSkinningType: () => MeshSkinningType,
  Object: () => Object3D,
  Object3D: () => Object3D,
  PhysXComponent: () => PhysXComponent,
  Physics: () => Physics,
  Property: () => Property,
  RayHit: () => RayHit,
  RetainEmitter: () => RetainEmitter,
  Scene: () => Scene,
  Shape: () => Shape,
  Skin: () => Skin,
  TextComponent: () => TextComponent,
  TextEffect: () => TextEffect,
  Texture: () => Texture,
  TextureManager: () => TextureManager,
  Type: () => Type,
  ViewComponent: () => ViewComponent,
  WASM: () => WASM,
  WonderlandEngine: () => WonderlandEngine,
  XR: () => XR,
  checkRuntimeCompatibility: () => checkRuntimeCompatibility,
  loadRuntime: () => loadRuntime,
  math: () => math
});

// node_modules/wasm-feature-detect/dist/esm/index.js
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
var threads = () => (async (e) => {
  try {
    return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
  } catch (e2) {
    return false;
  }
})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

// node_modules/@wonderlandengine/api/dist/property.js
var Type;
(function(Type3) {
  Type3[Type3["Native"] = 1] = "Native";
  Type3[Type3["Bool"] = 2] = "Bool";
  Type3[Type3["Int"] = 4] = "Int";
  Type3[Type3["Float"] = 8] = "Float";
  Type3[Type3["String"] = 16] = "String";
  Type3[Type3["Enum"] = 32] = "Enum";
  Type3[Type3["Object"] = 64] = "Object";
  Type3[Type3["Mesh"] = 128] = "Mesh";
  Type3[Type3["Texture"] = 256] = "Texture";
  Type3[Type3["Material"] = 512] = "Material";
  Type3[Type3["Animation"] = 1024] = "Animation";
  Type3[Type3["Skin"] = 2048] = "Skin";
  Type3[Type3["Color"] = 4096] = "Color";
})(Type || (Type = {}));
var Property = {
  /**
   * Create an boolean property.
   *
   * @param defaultValue The default value. If not provided, defaults to `false`.
   */
  bool(defaultValue = false) {
    return { type: Type.Bool, default: defaultValue };
  },
  /**
   * Create an integer property.
   *
   * @param defaultValue The default value. If not provided, defaults to `0`.
   */
  int(defaultValue = 0) {
    return { type: Type.Int, default: defaultValue };
  },
  /**
   * Create an float property.
   *
   * @param defaultValue The default value. If not provided, defaults to `0.0`.
   */
  float(defaultValue = 0) {
    return { type: Type.Float, default: defaultValue };
  },
  /**
   * Create an string property.
   *
   * @param defaultValue The default value. If not provided, defaults to `''`.
   */
  string(defaultValue = "") {
    return { type: Type.String, default: defaultValue };
  },
  /**
   * Create an enumeration property.
   *
   * @param values The list of values.
   * @param defaultValue The default value. Can be a string or an index into
   *     `values`. If not provided, defaults to the first element.
   */
  enum(values, defaultValue) {
    return { type: Type.Enum, values, default: defaultValue };
  },
  /** Create an {@link Object3D} reference property. */
  object() {
    return { type: Type.Object, default: null };
  },
  /** Create a {@link Mesh} reference property. */
  mesh() {
    return { type: Type.Mesh, default: null };
  },
  /** Create a {@link Texture} reference property. */
  texture() {
    return { type: Type.Texture, default: null };
  },
  /** Create a {@link Material} reference property. */
  material() {
    return { type: Type.Material, default: null };
  },
  /** Create an {@link Animation} reference property. */
  animation() {
    return { type: Type.Animation, default: null };
  },
  /** Create a {@link Skin} reference property. */
  skin() {
    return { type: Type.Skin, default: null };
  },
  /**
   * Create a color property.
   *
   * @param r The red component, in the range [0; 1].
   * @param g The green component, in the range [0; 1].
   * @param b The blue component, in the range [0; 1].
   * @param a The alpha component, in the range [0; 1].
   */
  color(r = 0, g = 0, b = 0, a = 1) {
    return { type: Type.Color, default: [r, g, b, a] };
  }
};

// node_modules/@wonderlandengine/api/dist/decorators.js
function propertyDecorator(data) {
  return function(target, propertyKey) {
    const ctor = target.constructor;
    ctor.Properties = ctor.Properties ?? {};
    ctor.Properties[propertyKey] = data;
  };
}
function enumerable() {
  return function(_, __, descriptor) {
    descriptor.enumerable = true;
  };
}
function nativeProperty() {
  return function(target, propertyKey, descriptor) {
    enumerable()(target, propertyKey, descriptor);
    propertyDecorator({ type: Type.Native })(target, propertyKey);
  };
}
var property = {};
for (const name in Property) {
  property[name] = (...args) => {
    const functor = Property[name];
    return propertyDecorator(functor(...args));
  };
}

// node_modules/@wonderlandengine/api/dist/utils/object.js
function isString(value) {
  if (value === "")
    return true;
  return value && (typeof value === "string" || value.constructor === String);
}
function isNumber(value) {
  if (value === null || value === void 0)
    return false;
  return typeof value === "number" || value.constructor === Number;
}

// node_modules/@wonderlandengine/api/dist/utils/event.js
var Emitter = class {
  /**
   * List of listeners to trigger when `notify` is called.
   *
   * @hidden
   */
  _listeners = [];
  /**
   * Register a new listener to be triggered on {@link Emitter.notify}.
   *
   * Basic usage:
   *
   * ```js
   * emitter.add((data) => {
   *     console.log('event received!');
   *     console.log(data);
   * });
   * ```
   *
   * Automatically remove the listener when an event is received:
   *
   * ```js
   * emitter.add((data) => {
   *     console.log('event received!');
   *     console.log(data);
   * }, {once: true});
   * ```
   *
   * @param listener The callback to register.
   * @param opts The listener options. For more information, please have a look
   *     at the {@link ListenerOptions} interface.
   *
   * @returns Reference to self (for method chaining)
   */
  add(listener, opts = {}) {
    const { once = false, id = void 0 } = opts;
    this._listeners.push({ id, once, callback: listener });
    return this;
  }
  /**
   * Equivalent to {@link Emitter.add}.
   *
   * @param listeners The callback(s) to register.
   * @returns Reference to self (for method chaining).
   *
   * @deprecated Please use {@link Emitter.add} instead.
   */
  push(...listeners) {
    for (const cb of listeners)
      this.add(cb);
    return this;
  }
  /**
   * Register a new listener to be triggered on {@link Emitter.notify}.
   *
   * Once notified, the listener will be automatically removed.
   *
   * The method is equivalent to calling {@link Emitter.add} with:
   *
   * ```js
   * emitter.add(listener, {once: true});
   * ```
   *
   * @param listener The callback to register.
   *
   * @returns Reference to self (for method chaining).
   */
  once(listener) {
    return this.add(listener, { once: true });
  }
  /**
   * Remove a registered listener.
   *
   * Usage with a callback:
   *
   * ```js
   * const listener = (data) => console.log(data);
   * emitter.add(listener);
   *
   * // Remove using the callback reference:
   * emitter.remove(listener);
   * ```
   *
   * Usage with an id:
   *
   * ```js
   * emitter.add((data) => console.log(data), {id: 'my-callback'});
   *
   * // Remove using the id:
   * emitter.remove('my-callback');
   * ```
   *
   * Using identifiers, you will need to ensure your value is unique to avoid
   * removing listeners from other libraries, e.g.,:
   *
   * ```js
   * emitter.add((data) => console.log(data), {id: 'non-unique'});
   * // This second listener could be added by a third-party library.
   * emitter.add((data) => console.log('Hello From Library!'), {id: 'non-unique'});
   *
   * // Ho Snap! This also removed the library listener!
   * emitter.remove('non-unique');
   * ```
   *
   * The identifier can be any type. However, remember that the comparison will be
   * by-value for primitive types (string, number), but by reference for objects.
   *
   * Example:
   *
   * ```js
   * emitter.add(() => console.log('Hello'), {id: {value: 42}});
   * emitter.add(() => console.log('World!'), {id: {value: 42}});
   * emitter.remove({value: 42}); // None of the above listeners match!
   * emitter.notify(); // Prints 'Hello' and 'World!'.
   * ```
   *
   * Here, both emitters have id `{value: 42}`, but the comparison is made by reference. Thus,
   * the `remove()` call has no effect. We can make it work by doing:
   *
   * ```js
   * const id = {value: 42};
   * emitter.add(() => console.log('Hello'), {id});
   * emitter.add(() => console.log('World!'), {id});
   * emitter.remove(id); // Same reference, it works!
   * emitter.notify(); // Doesn't print.
   * ```
   *
   * @param listener The registered callback or a value representing the `id`.
   *
   * @returns Reference to self (for method chaining)
   */
  remove(listener) {
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const target = listeners[i];
      if (target.callback === listener || target.id === listener) {
        listeners.splice(i--, 1);
      }
    }
    return this;
  }
  /**
   * Check whether the listener is registered.
   *
   * @note This method performs a linear search.
   *
   * @param listener The registered callback or a value representing the `id`.
   * @returns `true` if the handle is found, `false` otherwise.
   */
  has(listener) {
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const target = listeners[i];
      if (target.callback === listener || target.id === listener)
        return true;
    }
    return false;
  }
  /**
   * Notify listeners with the given data object.
   *
   * @note This method ensures all listeners are called even if
   * an exception is thrown. For (possibly) faster notification,
   * please use {@link Emitter.notifyUnsafe}.
   *
   * @param data The data to pass to listener when invoked.
   */
  notify(...data) {
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const listener = listeners[i];
      if (listener.once)
        listeners.splice(i--, 1);
      try {
        listener.callback(...data);
      } catch (e) {
        console.error(e);
      }
    }
  }
  /**
   * Notify listeners with the given data object.
   *
   * @note Because this method doesn't catch exceptions, some listeners
   * will be skipped on a throw. Please use {@link Emitter.notify} for safe
   * notification.
   *
   * @param data The data to pass to listener when invoked.
   */
  notifyUnsafe(...data) {
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const listener = listeners[i];
      if (listener.once)
        listeners.splice(i--, 1);
      listener.callback(...data);
    }
  }
  /**
   * Return a promise that will resolve on the next event.
   *
   * @note The promise might never resolve if no event is sent.
   *
   * @returns A promise that resolves with the data passed to
   *     {@link Emitter.notify}.
   */
  promise() {
    return new Promise((res, _) => {
      this.once((...args) => {
        if (args.length > 1) {
          res(args);
        } else {
          res(args[0]);
        }
      });
    });
  }
  /** Number of listeners. */
  get listenerCount() {
    return this._listeners.length;
  }
  /** `true` if it has no listeners, `false` otherwise. */
  get isEmpty() {
    return this.listenerCount === 0;
  }
};
var RetainEmitterUndefined = {};
var RetainEmitter = class extends Emitter {
  /** Pre-resolved data. @hidden */
  _event = RetainEmitterUndefined;
  /**
   * Emitter target used to reset the state of this emitter.
   *
   * @hidden
   */
  _reset;
  /** @override */
  add(listener, opts) {
    const immediate = opts?.immediate ?? true;
    if (this._event !== RetainEmitterUndefined && immediate) {
      listener(...this._event);
    }
    super.add(listener, opts);
    return this;
  }
  /**
   * @override
   *
   * @param listener The callback to register.
   * @param immediate If `true`, directly resolves if the emitter retains a value.
   *
   * @returns Reference to self (for method chaining).
   */
  once(listener, immediate) {
    return this.add(listener, { once: true, immediate });
  }
  /** @override */
  notify(...data) {
    this._event = data;
    super.notify(...data);
  }
  /** @override */
  notifyUnsafe(...data) {
    this._event = data;
    super.notifyUnsafe(...data);
  }
  /**
   * Reset the state of the emitter.
   *
   * Further call to {@link Emitter.add} will not automatically resolve,
   * until a new call to {@link Emitter.notify} is performed.
   *
   * @returns Reference to self (for method chaining)
   */
  reset() {
    this._event = RetainEmitterUndefined;
    return this;
  }
  /** Returns the retained data, or `undefined` if no data was retained. */
  get data() {
    return this.isDataRetained ? this._event : void 0;
  }
  /** `true` if data is retained from the last event, `false` otherwise. */
  get isDataRetained() {
    return this._event !== RetainEmitterUndefined;
  }
};

// node_modules/@wonderlandengine/api/dist/utils/fetch.js
function fetchWithProgress(path, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", path);
    xhr.responseType = "arraybuffer";
    xhr.onprogress = (progress) => {
      if (progress.lengthComputable) {
        onProgress?.(progress.loaded, progress.total);
      }
    };
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        const buffer = xhr.response;
        onProgress?.(buffer.byteLength, buffer.byteLength);
        resolve(buffer);
      } else {
        reject(xhr.statusText);
      }
    };
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

// node_modules/@wonderlandengine/api/dist/wonderland.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Collider;
(function(Collider3) {
  Collider3[Collider3["Sphere"] = 0] = "Sphere";
  Collider3[Collider3["AxisAlignedBox"] = 1] = "AxisAlignedBox";
  Collider3[Collider3["Box"] = 2] = "Box";
})(Collider || (Collider = {}));
var Alignment;
(function(Alignment3) {
  Alignment3[Alignment3["Left"] = 0] = "Left";
  Alignment3[Alignment3["Center"] = 1] = "Center";
  Alignment3[Alignment3["Right"] = 2] = "Right";
})(Alignment || (Alignment = {}));
var Justification;
(function(Justification3) {
  Justification3[Justification3["Line"] = 0] = "Line";
  Justification3[Justification3["Middle"] = 1] = "Middle";
  Justification3[Justification3["Top"] = 2] = "Top";
  Justification3[Justification3["Bottom"] = 3] = "Bottom";
})(Justification || (Justification = {}));
var TextEffect;
(function(TextEffect3) {
  TextEffect3[TextEffect3["None"] = 0] = "None";
  TextEffect3[TextEffect3["Outline"] = 1] = "Outline";
})(TextEffect || (TextEffect = {}));
var InputType;
(function(InputType3) {
  InputType3[InputType3["Head"] = 0] = "Head";
  InputType3[InputType3["EyeLeft"] = 1] = "EyeLeft";
  InputType3[InputType3["EyeRight"] = 2] = "EyeRight";
  InputType3[InputType3["ControllerLeft"] = 3] = "ControllerLeft";
  InputType3[InputType3["ControllerRight"] = 4] = "ControllerRight";
  InputType3[InputType3["RayLeft"] = 5] = "RayLeft";
  InputType3[InputType3["RayRight"] = 6] = "RayRight";
})(InputType || (InputType = {}));
var LightType;
(function(LightType3) {
  LightType3[LightType3["Point"] = 0] = "Point";
  LightType3[LightType3["Spot"] = 1] = "Spot";
  LightType3[LightType3["Sun"] = 2] = "Sun";
})(LightType || (LightType = {}));
var AnimationState;
(function(AnimationState3) {
  AnimationState3[AnimationState3["Playing"] = 0] = "Playing";
  AnimationState3[AnimationState3["Paused"] = 1] = "Paused";
  AnimationState3[AnimationState3["Stopped"] = 2] = "Stopped";
})(AnimationState || (AnimationState = {}));
var ForceMode;
(function(ForceMode3) {
  ForceMode3[ForceMode3["Force"] = 0] = "Force";
  ForceMode3[ForceMode3["Impulse"] = 1] = "Impulse";
  ForceMode3[ForceMode3["VelocityChange"] = 2] = "VelocityChange";
  ForceMode3[ForceMode3["Acceleration"] = 3] = "Acceleration";
})(ForceMode || (ForceMode = {}));
var CollisionEventType;
(function(CollisionEventType3) {
  CollisionEventType3[CollisionEventType3["Touch"] = 0] = "Touch";
  CollisionEventType3[CollisionEventType3["TouchLost"] = 1] = "TouchLost";
  CollisionEventType3[CollisionEventType3["TriggerTouch"] = 2] = "TriggerTouch";
  CollisionEventType3[CollisionEventType3["TriggerTouchLost"] = 3] = "TriggerTouchLost";
})(CollisionEventType || (CollisionEventType = {}));
var Shape;
(function(Shape3) {
  Shape3[Shape3["None"] = 0] = "None";
  Shape3[Shape3["Sphere"] = 1] = "Sphere";
  Shape3[Shape3["Capsule"] = 2] = "Capsule";
  Shape3[Shape3["Box"] = 3] = "Box";
  Shape3[Shape3["Plane"] = 4] = "Plane";
  Shape3[Shape3["ConvexMesh"] = 5] = "ConvexMesh";
  Shape3[Shape3["TriangleMesh"] = 6] = "TriangleMesh";
})(Shape || (Shape = {}));
var MeshAttribute;
(function(MeshAttribute3) {
  MeshAttribute3[MeshAttribute3["Position"] = 0] = "Position";
  MeshAttribute3[MeshAttribute3["Tangent"] = 1] = "Tangent";
  MeshAttribute3[MeshAttribute3["Normal"] = 2] = "Normal";
  MeshAttribute3[MeshAttribute3["TextureCoordinate"] = 3] = "TextureCoordinate";
  MeshAttribute3[MeshAttribute3["Color"] = 4] = "Color";
  MeshAttribute3[MeshAttribute3["JointId"] = 5] = "JointId";
  MeshAttribute3[MeshAttribute3["JointWeight"] = 6] = "JointWeight";
})(MeshAttribute || (MeshAttribute = {}));
var MaterialParamType;
(function(MaterialParamType3) {
  MaterialParamType3[MaterialParamType3["UnsignedInt"] = 0] = "UnsignedInt";
  MaterialParamType3[MaterialParamType3["Int"] = 1] = "Int";
  MaterialParamType3[MaterialParamType3["Float"] = 2] = "Float";
  MaterialParamType3[MaterialParamType3["Sampler"] = 3] = "Sampler";
  MaterialParamType3[MaterialParamType3["Font"] = 4] = "Font";
})(MaterialParamType || (MaterialParamType = {}));
function isMeshShape(shape) {
  return shape === Shape.ConvexMesh || shape === Shape.TriangleMesh;
}
var UP_VECTOR = [0, 1, 0];
var Scene = class {
  /** Called before rendering the scene */
  onPreRender = new Emitter();
  /** Called after the scene has been rendered */
  onPostRender = new Emitter();
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Ray hit pointer in WASM heap. @hidden */
  _rayHit;
  /** Ray hit. @hidden */
  _hit;
  constructor(engine2) {
    this._engine = engine2;
    this._rayHit = engine2.wasm._malloc(4 * (3 * 4 + 3 * 4 + 4 + 2) + 4);
    this._hit = new RayHit(this._engine, this._rayHit);
  }
  /**
   * Currently active view components.
   */
  get activeViews() {
    const wasm = this._engine.wasm;
    const count = wasm._wl_scene_get_active_views(this._engine.wasm._tempMem, 16);
    const views = [];
    const viewTypeIndex = wasm._typeIndexFor("view");
    for (let i = 0; i < count; ++i) {
      views.push(new ViewComponent(this._engine, viewTypeIndex, this._engine.wasm._tempMemInt[i]));
    }
    return views;
  }
  /**
   * Cast a ray through the scene and find intersecting objects.
   *
   * The resulting ray hit will contain up to **4** closest ray hits,
   * sorted by increasing distance.
   *
   * @param o Ray origin.
   * @param d Ray direction.
   * @param group Collision group to filter by: only objects that are
   *        part of given group are considered for raycast.
   *
   * @returns The scene cached {@link RayHit} instance.
   * @note The returned object is owned by the Scene instance
   *   will be reused with the next {@link Scene#rayCast} call.
   */
  rayCast(o, d, group) {
    this._engine.wasm._wl_scene_ray_cast(o[0], o[1], o[2], d[0], d[1], d[2], group, this._rayHit);
    return this._hit;
  }
  /**
   * Add an object to the scene.
   *
   * @param parent Parent object or `null`.
   * @returns A newly created object.
   */
  addObject(parent = null) {
    const parentId = parent ? parent.objectId : 0;
    const objectId = this._engine.wasm._wl_scene_add_object(parentId);
    return this._engine.wrapObject(objectId);
  }
  /**
   * Batch-add objects to the scene.
   *
   * Will provide better performance for adding multiple objects (e.g. > 16)
   * than calling {@link Scene#addObject} repeatedly in a loop.
   *
   * By providing upfront information of how many objects will be required,
   * the engine is able to batch-allocate the required memory rather than
   * convervatively grow the memory in small steps.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * @param count Number of objects to add.
   * @param parent Parent object or `null`, default `null`.
   * @param componentCountHint Hint for how many components in total will
   *      be added to the created objects afterwards, default `0`.
   * @returns Newly created objects
   */
  addObjects(count, parent = null, componentCountHint = 0) {
    const parentId = parent ? parent.objectId : 0;
    this._engine.wasm.requireTempMem(count * 2);
    const actualCount = this._engine.wasm._wl_scene_add_objects(parentId, count, componentCountHint || 0, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
    const ids = this._engine.wasm._tempMemUint16.subarray(0, actualCount);
    const wrapper = this._engine.wrapObject.bind(this._engine);
    const objects = Array.from(ids, wrapper);
    return objects;
  }
  /**
   * Pre-allocate memory for a given amount of objects and components.
   *
   * Will provide better performance for adding objects later with {@link Scene#addObject}
   * and {@link Scene#addObjects}.
   *
   * By providing upfront information of how many objects will be required,
   * the engine is able to batch-allocate the required memory rather than
   * conservatively grow the memory in small steps.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * @param objectCount Number of objects to add.
   * @param componentCountPerType Amount of components to
   *      allocate for {@link Object3D.addComponent}, e.g. `{mesh: 100, collision: 200, "my-comp": 100}`.
   * @since 0.8.10
   */
  reserveObjects(objectCount, componentCountPerType) {
    const wasm = this._engine.wasm;
    componentCountPerType = componentCountPerType || {};
    const jsManagerIndex = wasm._typeIndexFor("js");
    let countsPerTypeIndex = wasm._tempMemInt.subarray();
    countsPerTypeIndex.fill(0);
    for (const e of Object.entries(componentCountPerType)) {
      const typeIndex = wasm._typeIndexFor(e[0]);
      countsPerTypeIndex[typeIndex < 0 ? jsManagerIndex : typeIndex] += e[1];
    }
    wasm._wl_scene_reserve_objects(objectCount, wasm._tempMem);
  }
  /**
   * Set the background clear color.
   *
   * @param color new clear color (RGBA).
   * @since 0.8.5
   */
  set clearColor(color) {
    this._engine.wasm._wl_scene_set_clearColor(color[0], color[1], color[2], color[3]);
  }
  /**
   * Set whether to clear the color framebuffer before drawing.
   *
   * This function is useful if an external framework (e.g. an AR tracking
   * framework) is responsible for drawing a camera frame before Wonderland
   * Engine draws the scene on top of it.
   *
   * @param b Whether to enable color clear.
   * @since 0.9.4
   */
  set colorClearEnabled(b) {
    this._engine.wasm._wl_scene_enableColorClear(b);
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Load a scene file (.bin).
   *
   * Will replace the currently active scene with the one loaded
   * from given file. It is assumed that JavaScript components required by
   * the new scene were registered in advance.
   *
   * Once the scene is loaded successfully and initialized,
   * {@link WonderlandEngine.onSceneLoaded} is notified.
   *
   * @param filename Path to the .bin file.
   * @returns Promise that resolves when the scene was loaded.
   */
  async load(filename) {
    const wasm = this._engine.wasm;
    const buffer = await fetchWithProgress(filename, (bytes, size2) => {
      console.log(`Scene downloading: ${bytes} / ${size2}`);
      wasm._wl_set_loading_screen_progress(bytes / size2);
    });
    const size = buffer.byteLength;
    console.log(`Scene download of ${size} bytes successful.`);
    const ptr = wasm._malloc(size);
    new Uint8Array(wasm.HEAPU8.buffer, ptr, size).set(new Uint8Array(buffer));
    try {
      wasm._wl_load_scene_bin(ptr, size, wasm.tempUTF8(filename));
    } finally {
      wasm._free(ptr);
    }
    const binQueue = wasm._queuedBinFiles;
    if (binQueue.length > 0) {
      wasm._queuedBinFiles = [];
      await Promise.all(binQueue.map((path) => this.append(path)));
    }
    this._engine.onSceneLoaded.notify();
  }
  /**
   * Append a scene file.
   *
   * Loads and parses the file and its images and appends the result
   * to the currently active scene.
   *
   * Supported formats are streamable Wonderland scene files (.bin) and glTF
   * 3D scenes (.gltf, .glb).
   *
   * ```js
   * WL.scene.append(filename).then(root => {
   *     // root contains the loaded scene
   * });
   * ```
   *
   * In case the `loadGltfExtensions` option is set to true, the response
   * will be an object containing both the root of the loaded scene and
   * any glTF extensions found on nodes, meshes and the root of the file.
   *
   * ```js
   * WL.scene.append(filename, { loadGltfExtensions: true }).then(({root, extensions}) => {
   *     // root contains the loaded scene
   *     // extensions.root contains any extensions at the root of glTF document
   *     const rootExtensions = extensions.root;
   *     // extensions.mesh and extensions.node contain extensions indexed by Object id
   *     const childObject = root.children[0];
   *     const meshExtensions = root.meshExtensions[childObject.objectId];
   *     const nodeExtensions = root.nodeExtensions[childObject.objectId];
   *     // extensions.idMapping contains a mapping from glTF node index to Object id
   * });
   * ```
   *
   * @param file The .bin, .gltf or .glb file to append. Should be a URL or
   *   an `ArrayBuffer` with the file content.
   * @param options Additional options for loading.
   * @returns Promise that resolves when the scene was appended.
   */
  async append(file, options) {
    const buffer = isString(file) ? await fetchWithProgress(file) : file;
    const wasm = this._engine.wasm;
    let callback;
    const promise = new Promise((resolve, reject) => {
      callback = wasm.addFunction((objectId, extensionData, extensionDataSize) => {
        if (objectId < 0) {
          reject();
          return;
        }
        const root = objectId ? this._engine.wrapObject(objectId) : null;
        if (extensionData && extensionDataSize) {
          const marshalled = new Uint32Array(wasm.HEAPU32.buffer, extensionData, extensionDataSize / 4);
          const extensions = this._unmarshallGltfExtensions(marshalled);
          resolve({ root, extensions });
        } else {
          resolve(root);
        }
      }, "viii");
    }).finally(() => wasm.removeFunction(callback));
    const size = buffer.byteLength;
    const ptr = wasm._malloc(size);
    const data = new Uint8Array(wasm.HEAPU8.buffer, ptr, size);
    data.set(new Uint8Array(buffer));
    const MAGIC = "WLEV";
    const isBinFile = data.byteLength > MAGIC.length && data.subarray(0, MAGIC.length).every((value, i) => value === MAGIC.charCodeAt(i));
    try {
      if (isBinFile) {
        wasm._wl_append_scene_bin(ptr, size, callback);
      } else {
        const loadExtensions = options?.loadGltfExtensions ?? false;
        wasm._wl_append_scene_gltf(ptr, size, loadExtensions, callback);
      }
    } catch (e) {
      wasm.removeFunction(callback);
      throw e;
    } finally {
      wasm._free(ptr);
    }
    const result = await promise;
    const binQueue = wasm._queuedBinFiles;
    if (isBinFile && binQueue.length > 0) {
      wasm._queuedBinFiles = [];
      await Promise.all(binQueue.map((path) => this.append(path, options)));
    }
    return result;
  }
  /**
   * Unmarshalls the GltfExtensions from an Uint32Array.
   *
   * @param data Array containing the gltf extension data.
   * @returns The extensions stored in an object literal.
   *
   * @hidden
   */
  _unmarshallGltfExtensions(data) {
    const extensions = {
      root: {},
      mesh: {},
      node: {},
      idMapping: []
    };
    let index = 0;
    const readString = () => {
      const strPtr = data[index++];
      const strLen = data[index++];
      return this._engine.wasm.UTF8ViewToString(strPtr, strPtr + strLen);
    };
    const idMappingSize = data[index++];
    const idMapping = new Array(idMappingSize);
    for (let i = 0; i < idMappingSize; ++i) {
      idMapping[i] = data[index++];
    }
    extensions.idMapping = idMapping;
    const meshExtensionsSize = data[index++];
    for (let i = 0; i < meshExtensionsSize; ++i) {
      const objectId = data[index++];
      extensions.mesh[idMapping[objectId]] = JSON.parse(readString());
    }
    const nodeExtensionsSize = data[index++];
    for (let i = 0; i < nodeExtensionsSize; ++i) {
      const objectId = data[index++];
      extensions.node[idMapping[objectId]] = JSON.parse(readString());
    }
    const rootExtensionsStr = readString();
    if (rootExtensionsStr) {
      extensions.root = JSON.parse(rootExtensionsStr);
    }
    return extensions;
  }
  /**
   * Reset the scene.
   *
   * This method deletes all used and allocated objects, and components.
   */
  reset() {
    this._engine.wasm._wl_scene_reset();
  }
};
var Component = class {
  /** Manager index. @hidden */
  _manager;
  /** Instance index. @hidden */
  _id;
  /**
   * Object containing this object.
   *
   * **Note**: This is cached for faster retrieval.
   *
   * @hidden
   */
  _object;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new instance
   *
   * @param engine The engine instance.
   * @param manager Index of the manager.
   * @param id WASM component instance index.
   *
   * @hidden
   */
  constructor(engine2, manager = -1, id = -1) {
    this._engine = engine2;
    this._manager = manager;
    this._id = id;
    this._object = null;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /** The name of this component's type */
  get type() {
    const ctor = this.constructor;
    return ctor.TypeName ?? this._engine.wasm._typeNameFor(this._manager);
  }
  /** The object this component is attached to. */
  get object() {
    if (!this._object) {
      const objectId = this._engine.wasm._wl_component_get_object(this._manager, this._id);
      this._object = this._engine.wrapObject(objectId);
    }
    return this._object;
  }
  /**
   * Set whether this component is active.
   *
   * Activating/deactivating a component comes at a small cost of reordering
   * components in the respective component manager. This function therefore
   * is not a trivial assignment.
   *
   * Does nothing if the component is already activated/deactivated.
   *
   * @param active New active state.
   */
  set active(active) {
    this._engine.wasm._wl_component_setActive(this._manager, this._id, active);
  }
  /**
   * Whether this component is active
   */
  get active() {
    return this._engine.wasm._wl_component_isActive(this._manager, this._id) != 0;
  }
  /**
   * Remove this component from its objects and destroy it.
   *
   * It is best practice to set the component to `null` after,
   * to ensure it does not get used later.
   *
   * ```js
   *    c.destroy();
   *    c = null;
   * ```
   * @since 0.9.0
   */
  destroy() {
    this._engine.wasm._wl_component_remove(this._manager, this._id);
    this._manager = -1;
    this._id = -1;
  }
  /**
   * Checks equality by comparing whether the wrapped native component ids
   * and component manager types are equal.
   *
   * @param otherComponent Component to check equality with.
   * @returns Whether this component equals the given component.
   */
  equals(otherComponent) {
    if (!otherComponent)
      return false;
    return this._manager == otherComponent._manager && this._id == otherComponent._id;
  }
};
/**
 * Unique identifier for this component class.
 *
 * This is used to register, add, and retrieve components of a given type.
 */
__publicField(Component, "TypeName");
/**
 * Properties of this component class.
 *
 * Properties are public attributes that can be configured via the
 * Wonderland Editor.
 *
 * Example:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 * class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myBoolean: { type: Type.Boolean, default: false },
 *         myFloat: { type: Type.Float, default: false },
 *         myTexture: { type: Type.Texture, default: null },
 *     };
 * }
 * ```
 *
 * Properties are automatically added to each component instance, and are
 * accessible like any JS attribute:
 *
 * ```js
 * // Creates a new component and set each properties value:
 * const myComponent = object.addComponent(MyComponent, {
 *     myBoolean: true,
 *     myFloat: 42.0,
 *     myTexture: null
 * });
 *
 * // You can also override the properties on the instance:
 * myComponent.myBoolean = false;
 * myComponent.myFloat = -42.0;
 * ```
 */
__publicField(Component, "Properties");
/**
 * This was never released in an official version, we are keeping it
 * to easy transition to the new API.
 *
 * @deprecated Use {@link Component.onRegister} instead.
 * @hidden
 */
__publicField(Component, "Dependencies");
/**
 * Called when this component class is registered.
 *
 * @example
 *
 * This callback can be used to register dependencies of a component,
 * e.g., component classes that need to be registered in order to add
 * them at runtime with {@link Object3D.addComponent}, independent of whether
 * they are used in the editor.
 *
 * ```js
 * class Spawner extends Component {
 *     static TypeName = 'spawner';
 *
 *     static onRegister() {
 *         engine.registerComponent(SpawnedComponent);
 *     }
 *
 *     // You can now use addComponent with SpawnedComponent
 * }
 * ```
 *
 * @example
 *
 * This callback can be used to register different implementations of a
 * component depending on client features or API versions.
 *
 * ```js
 * // Properties need to be the same for all implementations!
 * const SharedProperties = {};
 *
 * class Anchor extends Component {
 *     static TypeName = 'spawner';
 *     static Properties = SharedProperties;
 *
 *     static onRegister() {
 *         if(navigator.xr === undefined) {
 *             /* WebXR unsupported, keep this dummy component *\/
 *             return;
 *         }
 *         /* WebXR supported! Override already registered dummy implementation
 *          * with one depending on hit-test API support *\/
 *         engine.registerComponent(window.HitTestSource === undefined ?
 *             AnchorWithoutHitTest : AnchorWithHitTest);
 *     }
 *
 *     // This one implements no functions
 * }
 * ```
 */
__publicField(Component, "onRegister");
var _CollisionComponent = class extends Component {
  /** Collision component collider */
  get collider() {
    return this._engine.wasm._wl_collision_component_get_collider(this._id);
  }
  /**
   * Set collision component collider.
   *
   * @param collider Collider of the collision component.
   */
  set collider(collider) {
    this._engine.wasm._wl_collision_component_set_collider(this._id, collider);
  }
  /**
   * Collision component extents.
   *
   * If {@link collider} returns {@link Collider.Sphere}, only the first
   * component of the returned vector is used.
   */
  get extents() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_collision_component_get_extents(this._id), 3);
  }
  /**
   * Set collision component extents.
   *
   * If {@link collider} returns {@link Collider.Sphere}, only the first
   * component of the passed vector is used.
   *
   * Example:
   *
   * ```js
   * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
   * collision.extent = [1, 2, 3];
   * ```
   *
   * @param extents Extents of the collision component, expects a
   *      3 component array.
   */
  set extents(extents) {
    this.extents.set(extents);
  }
  /**
   * Collision component group.
   *
   * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
   * or the group in {@link Scene#rayCast}.
   *
   * Colliders that have no common groups will not overlap with each other. If a collider
   * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
   *
   * Each bit represents belonging to a group, see example.
   *
   * ```js
   *    // c belongs to group 2
   *    c.group = (1 << 2);
   *
   *    // c belongs to group 0
   *    c.group = (1 << 0);
   *
   *    // c belongs to group 0 *and* 2
   *    c.group = (1 << 0) | (1 << 2);
   *
   *    (c.group & (1 << 2)) != 0; // true
   *    (c.group & (1 << 7)) != 0; // false
   * ```
   */
  get group() {
    return this._engine.wasm._wl_collision_component_get_group(this._id);
  }
  /**
   * Set collision component group.
   *
   * @param group Group mask of the collision component.
   */
  set group(group) {
    this._engine.wasm._wl_collision_component_set_group(this._id, group);
  }
  /**
   * Query overlapping objects.
   *
   * Usage:
   *
   * ```js
   * const collision = object.getComponent('collision');
   * const overlaps = collision.queryOverlaps();
   * for(const otherCollision of overlaps) {
   *     const otherObject = otherCollision.object;
   *     console.log(`Collision with object ${otherObject.objectId}`);
   * }
   * ```
   *
   * @returns Collision components overlapping this collider.
   */
  queryOverlaps() {
    const count = this._engine.wasm._wl_collision_component_query_overlaps(this._id, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
    const overlaps = new Array(count);
    for (let i = 0; i < count; ++i) {
      overlaps[i] = new _CollisionComponent(this._engine, this._manager, this._engine.wasm._tempMemUint16[i]);
    }
    return overlaps;
  }
};
var CollisionComponent = _CollisionComponent;
/** @override */
__publicField(CollisionComponent, "TypeName", "collision");
__decorate([
  nativeProperty()
], CollisionComponent.prototype, "collider", null);
__decorate([
  nativeProperty()
], CollisionComponent.prototype, "extents", null);
__decorate([
  nativeProperty()
], CollisionComponent.prototype, "group", null);
var TextComponent = class extends Component {
  /** Text component alignment. */
  get alignment() {
    return this._engine.wasm._wl_text_component_get_horizontal_alignment(this._id);
  }
  /**
   * Set text component alignment.
   *
   * @param alignment Alignment for the text component.
   */
  set alignment(alignment) {
    this._engine.wasm._wl_text_component_set_horizontal_alignment(this._id, alignment);
  }
  /** Text component justification. */
  get justification() {
    return this._engine.wasm._wl_text_component_get_vertical_alignment(this._id);
  }
  /**
   * Set text component justification.
   *
   * @param justification Justification for the text component.
   */
  set justification(justification) {
    this._engine.wasm._wl_text_component_set_vertical_alignment(this._id, justification);
  }
  /** Text component character spacing. */
  get characterSpacing() {
    return this._engine.wasm._wl_text_component_get_character_spacing(this._id);
  }
  /**
   * Set text component character spacing.
   *
   * @param spacing Character spacing for the text component.
   */
  set characterSpacing(spacing) {
    this._engine.wasm._wl_text_component_set_character_spacing(this._id, spacing);
  }
  /** Text component line spacing. */
  get lineSpacing() {
    return this._engine.wasm._wl_text_component_get_line_spacing(this._id);
  }
  /**
   * Set text component line spacing
   *
   * @param spacing Line spacing for the text component
   */
  set lineSpacing(spacing) {
    this._engine.wasm._wl_text_component_set_line_spacing(this._id, spacing);
  }
  /** Text component effect. */
  get effect() {
    return this._engine.wasm._wl_text_component_get_effect(this._id);
  }
  /**
   * Set text component effect
   *
   * @param effect Effect for the text component
   */
  set effect(effect) {
    this._engine.wasm._wl_text_component_set_effect(this._id, effect);
  }
  /** Text component text. */
  get text() {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_text_component_get_text(this._id);
    return wasm.UTF8ToString(ptr);
  }
  /**
   * Set text component text.
   *
   * @param text Text of the text component.
   */
  set text(text) {
    const wasm = this._engine.wasm;
    wasm._wl_text_component_set_text(this._id, wasm.tempUTF8(text));
  }
  /**
   * Set material to render the text with.
   *
   * @param material New material.
   */
  set material(material) {
    const matIndex = material ? material._index : 0;
    this._engine.wasm._wl_text_component_set_material(this._id, matIndex);
  }
  /** Material used to render the text. */
  get material() {
    const id = this._engine.wasm._wl_text_component_get_material(this._id);
    return id > 0 ? new Material(this._engine, id) : null;
  }
};
/** @override */
__publicField(TextComponent, "TypeName", "text");
__decorate([
  nativeProperty()
], TextComponent.prototype, "alignment", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "justification", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "characterSpacing", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "lineSpacing", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "effect", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "text", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "material", null);
var ViewComponent = class extends Component {
  /** Projection matrix. */
  get projectionMatrix() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_view_component_get_projection_matrix(this._id), 16);
  }
  /** ViewComponent near clipping plane value. */
  get near() {
    return this._engine.wasm._wl_view_component_get_near(this._id);
  }
  /**
   * Set near clipping plane distance for the view.
   *
   * If an XR session is active, the change will apply in the
   * following frame, otherwise the change is immediate.
   *
   * @param near Near depth value.
   */
  set near(near) {
    this._engine.wasm._wl_view_component_set_near(this._id, near);
  }
  /** Far clipping plane value. */
  get far() {
    return this._engine.wasm._wl_view_component_get_far(this._id);
  }
  /**
   * Set far clipping plane distance for the view.
   *
   * If an XR session is active, the change will apply in the
   * following frame, otherwise the change is immediate.
   *
   * @param far Near depth value.
   */
  set far(far) {
    this._engine.wasm._wl_view_component_set_far(this._id, far);
  }
  /**
   * Get the horizontal field of view for the view, **in degrees**.
   *
   * If an XR session is active, this returns the field of view reported by
   * the device, regardless of the fov that was set.
   */
  get fov() {
    return this._engine.wasm._wl_view_component_get_fov(this._id);
  }
  /**
   * Set the horizontal field of view for the view, **in degrees**.
   *
   * If an XR session is active, the field of view reported by the device is
   * used and this value is ignored. After the XR session ends, the new value
   * is applied.
   *
   * @param fov Horizontal field of view, **in degrees**.
   */
  set fov(fov) {
    this._engine.wasm._wl_view_component_set_fov(this._id, fov);
  }
};
/** @override */
__publicField(ViewComponent, "TypeName", "view");
__decorate([
  enumerable()
], ViewComponent.prototype, "projectionMatrix", null);
__decorate([
  nativeProperty()
], ViewComponent.prototype, "near", null);
__decorate([
  nativeProperty()
], ViewComponent.prototype, "far", null);
__decorate([
  nativeProperty()
], ViewComponent.prototype, "fov", null);
var InputComponent = class extends Component {
  /** Input component type */
  get inputType() {
    return this._engine.wasm._wl_input_component_get_type(this._id);
  }
  /**
   * Set input component type.
   *
   * @params New input component type.
   */
  set inputType(type) {
    this._engine.wasm._wl_input_component_set_type(this._id, type);
  }
  /**
   * WebXR Device API input source associated with this input component,
   * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
   */
  get xrInputSource() {
    const xrSession = this._engine.xrSession;
    if (xrSession) {
      for (let inputSource of xrSession.inputSources) {
        if (inputSource.handedness == this.handedness) {
          return inputSource;
        }
      }
    }
    return null;
  }
  /**
   * 'left', 'right' or `null` depending on the {@link InputComponent#inputType}.
   */
  get handedness() {
    const inputType = this.inputType;
    if (inputType == InputType.ControllerRight || inputType == InputType.RayRight || inputType == InputType.EyeRight)
      return "right";
    if (inputType == InputType.ControllerLeft || inputType == InputType.RayLeft || inputType == InputType.EyeLeft)
      return "left";
    return null;
  }
};
/** @override */
__publicField(InputComponent, "TypeName", "input");
__decorate([
  nativeProperty()
], InputComponent.prototype, "inputType", null);
__decorate([
  enumerable()
], InputComponent.prototype, "xrInputSource", null);
__decorate([
  enumerable()
], InputComponent.prototype, "handedness", null);
var LightComponent = class extends Component {
  getColor(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_light_component_get_color(this._id) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set light color.
   *
   * @param c New color array/vector, expected to have at least 3 elements.
   * @since 1.0.0
   */
  setColor(c) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_light_component_get_color(this._id) / 4;
    wasm.HEAPF32[ptr] = c[0];
    wasm.HEAPF32[ptr + 1] = c[1];
    wasm.HEAPF32[ptr + 2] = c[2];
  }
  /**
   * View on the light color.
   *
   * @note Prefer to use {@link getColor} in performance-critical code.
   */
  get color() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_light_component_get_color(this._id), 3);
  }
  /**
   * Set light color.
   *
   * @param c Color of the light component.
   *
   * @note Prefer to use {@link setColor} in performance-critical code.
   */
  set color(c) {
    this.color.set(c);
  }
  /** Light type. */
  get lightType() {
    return this._engine.wasm._wl_light_component_get_type(this._id);
  }
  /**
   * Set light type.
   *
   * @param lightType Type of the light component.
   */
  set lightType(t) {
    this._engine.wasm._wl_light_component_set_type(this._id, t);
  }
  /**
   * Light intensity.
   * @since 1.0.0
   */
  get intensity() {
    return this._engine.wasm._wl_light_component_get_intensity(this._id);
  }
  /**
   * Set light intensity.
   *
   * @param intensity Intensity of the light component.
   * @since 1.0.0
   */
  set intensity(intensity) {
    this._engine.wasm._wl_light_component_set_intensity(this._id, intensity);
  }
  /**
   * Outer angle for spot lights, in degrees.
   * @since 1.0.0
   */
  get outerAngle() {
    return this._engine.wasm._wl_light_component_get_outerAngle(this._id);
  }
  /**
   * Set outer angle for spot lights.
   *
   * @param angle Outer angle, in degrees.
   * @since 1.0.0
   */
  set outerAngle(angle3) {
    this._engine.wasm._wl_light_component_set_outerAngle(this._id, angle3);
  }
  /**
   * Inner angle for spot lights, in degrees.
   * @since 1.0.0
   */
  get innerAngle() {
    return this._engine.wasm._wl_light_component_get_innerAngle(this._id);
  }
  /**
   * Set inner angle for spot lights.
   *
   * @param angle Inner angle, in degrees.
   * @since 1.0.0
   */
  set innerAngle(angle3) {
    this._engine.wasm._wl_light_component_set_innerAngle(this._id, angle3);
  }
  /**
   * Whether the light casts shadows.
   * @since 1.0.0
   */
  get shadows() {
    return !!this._engine.wasm._wl_light_component_get_shadows(this._id);
  }
  /**
   * Set whether the light casts shadows.
   *
   * @param b Whether the light casts shadows.
   * @since 1.0.0
   */
  set shadows(b) {
    this._engine.wasm._wl_light_component_set_shadows(this._id, b);
  }
  /**
   * Range for shadows.
   * @since 1.0.0
   */
  get shadowRange() {
    return this._engine.wasm._wl_light_component_get_shadowRange(this._id);
  }
  /**
   * Set range for shadows.
   *
   * @param range Range for shadows.
   * @since 1.0.0
   */
  set shadowRange(range) {
    this._engine.wasm._wl_light_component_set_shadowRange(this._id, range);
  }
  /**
   * Bias value for shadows.
   * @since 1.0.0
   */
  get shadowBias() {
    return this._engine.wasm._wl_light_component_get_shadowBias(this._id);
  }
  /**
   * Set bias value for shadows.
   *
   * @param bias Bias for shadows.
   * @since 1.0.0
   */
  set shadowBias(bias) {
    this._engine.wasm._wl_light_component_set_shadowBias(this._id, bias);
  }
  /**
   * Normal bias value for shadows.
   * @since 1.0.0
   */
  get shadowNormalBias() {
    return this._engine.wasm._wl_light_component_get_shadowNormalBias(this._id);
  }
  /**
   * Set normal bias value for shadows.
   *
   * @param bias Normal bias for shadows.
   * @since 1.0.0
   */
  set shadowNormalBias(bias) {
    this._engine.wasm._wl_light_component_set_shadowNormalBias(this._id, bias);
  }
  /**
   * Texel size for shadows.
   * @since 1.0.0
   */
  get shadowTexelSize() {
    return this._engine.wasm._wl_light_component_get_shadowTexelSize(this._id);
  }
  /**
   * Set texel size for shadows.
   *
   * @param size Texel size for shadows.
   * @since 1.0.0
   */
  set shadowTexelSize(size) {
    this._engine.wasm._wl_light_component_set_shadowTexelSize(this._id, size);
  }
  /**
   * Cascade count for {@link LightType.Sun} shadows.
   * @since 1.0.0
   */
  get cascadeCount() {
    return this._engine.wasm._wl_light_component_get_cascadeCount(this._id);
  }
  /**
   * Set cascade count for {@link LightType.Sun} shadows.
   *
   * @param count Cascade count.
   * @since 1.0.0
   */
  set cascadeCount(count) {
    this._engine.wasm._wl_light_component_set_cascadeCount(this._id, count);
  }
};
/** @override */
__publicField(LightComponent, "TypeName", "light");
__decorate([
  nativeProperty()
], LightComponent.prototype, "color", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "lightType", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "intensity", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "outerAngle", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "innerAngle", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadows", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowRange", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowBias", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowNormalBias", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowTexelSize", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "cascadeCount", null);
var AnimationComponent = class extends Component {
  /**
   * Set animation to play.
   *
   * Make sure to {@link Animation#retarget} the animation to affect the
   * right objects.
   *
   * @param anim Animation to play.
   */
  set animation(anim) {
    this._engine.wasm._wl_animation_component_set_animation(this._id, anim ? anim._index : 0);
  }
  /** Animation set for this component */
  get animation() {
    const id = this._engine.wasm._wl_animation_component_get_animation(this._id);
    return id > 0 ? new Animation(this._engine, id) : null;
  }
  /**
   * Set play count. Set to `0` to loop indefinitely.
   *
   * @param playCount Number of times to repeat the animation.
   */
  set playCount(playCount) {
    this._engine.wasm._wl_animation_component_set_playCount(this._id, playCount);
  }
  /** Number of times the animation is played. */
  get playCount() {
    return this._engine.wasm._wl_animation_component_get_playCount(this._id);
  }
  /**
   * Set speed. Set to negative values to run the animation backwards.
   *
   * Setting speed has an immediate effect for the current frame's update
   * and will continue with the speed from the current point in the animation.
   *
   * @param speed New speed at which to play the animation.
   * @since 0.8.10
   */
  set speed(speed) {
    this._engine.wasm._wl_animation_component_set_speed(this._id, speed);
  }
  /**
   * Speed factor at which the animation is played.
   *
   * @since 0.8.10
   */
  get speed() {
    return this._engine.wasm._wl_animation_component_get_speed(this._id);
  }
  /** Current playing state of the animation */
  get state() {
    return this._engine.wasm._wl_animation_component_state(this._id);
  }
  /**
   * Play animation.
   *
   * If the animation is currently paused, resumes from that position. If the
   * animation is already playing, does nothing.
   *
   * To restart the animation, {@link AnimationComponent#stop} it first.
   */
  play() {
    this._engine.wasm._wl_animation_component_play(this._id);
  }
  /** Stop animation. */
  stop() {
    this._engine.wasm._wl_animation_component_stop(this._id);
  }
  /** Pause animation. */
  pause() {
    this._engine.wasm._wl_animation_component_pause(this._id);
  }
};
/** @override */
__publicField(AnimationComponent, "TypeName", "animation");
__decorate([
  nativeProperty()
], AnimationComponent.prototype, "animation", null);
__decorate([
  nativeProperty()
], AnimationComponent.prototype, "playCount", null);
__decorate([
  nativeProperty()
], AnimationComponent.prototype, "speed", null);
__decorate([
  enumerable()
], AnimationComponent.prototype, "state", null);
var MeshComponent = class extends Component {
  /**
   * Set material to render the mesh with.
   *
   * @param material Material to render the mesh with.
   */
  set material(material) {
    this._engine.wasm._wl_mesh_component_set_material(this._id, material ? material._index : 0);
  }
  /** Material used to render the mesh. */
  get material() {
    const id = this._engine.wasm._wl_mesh_component_get_material(this._id);
    return id > 0 ? new Material(this._engine, id) : null;
  }
  /** Mesh rendered by this component. */
  get mesh() {
    const id = this._engine.wasm._wl_mesh_component_get_mesh(this._id);
    return id > 0 ? new Mesh(this._engine, id) : null;
  }
  /**
   * Set mesh to rendered with this component.
   *
   * @param mesh Mesh rendered by this component.
   */
  set mesh(mesh) {
    this._engine.wasm._wl_mesh_component_set_mesh(this._id, mesh ? mesh._index : 0);
  }
  /** Skin for this mesh component. */
  get skin() {
    const id = this._engine.wasm._wl_mesh_component_get_skin(this._id);
    return id > 0 ? new Skin(this._engine, id) : null;
  }
  /**
   * Set skin to transform this mesh component.
   *
   * @param skin Skin to use for rendering skinned meshes.
   */
  set skin(skin) {
    this._engine.wasm._wl_mesh_component_set_skin(this._id, skin ? skin._index : 0);
  }
};
/** @override */
__publicField(MeshComponent, "TypeName", "mesh");
__decorate([
  nativeProperty()
], MeshComponent.prototype, "material", null);
__decorate([
  nativeProperty()
], MeshComponent.prototype, "mesh", null);
__decorate([
  nativeProperty()
], MeshComponent.prototype, "skin", null);
var LockAxis;
(function(LockAxis3) {
  LockAxis3[LockAxis3["None"] = 0] = "None";
  LockAxis3[LockAxis3["X"] = 1] = "X";
  LockAxis3[LockAxis3["Y"] = 2] = "Y";
  LockAxis3[LockAxis3["Z"] = 4] = "Z";
})(LockAxis || (LockAxis = {}));
var PhysXComponent = class extends Component {
  /**
   * Set whether this rigid body is static.
   *
   * Setting this property only takes effect once the component
   * switches from inactive to active.
   *
   * @param b Whether the rigid body should be static.
   */
  set static(b) {
    this._engine.wasm._wl_physx_component_set_static(this._id, b);
  }
  /**
   * Whether this rigid body is static.
   *
   * This property returns whether the rigid body is *effectively*
   * static. If static property was set while the rigid body was
   * active, it will not take effect until the rigid body is set
   * inactive and active again. Until the component is set inactive,
   * this getter will return whether the rigid body is actually
   * static.
   */
  get static() {
    return !!this._engine.wasm._wl_physx_component_get_static(this._id);
  }
  /**
   * Set whether this rigid body is kinematic.
   *
   * @param b Whether the rigid body should be kinematic.
   */
  set kinematic(b) {
    this._engine.wasm._wl_physx_component_set_kinematic(this._id, b);
  }
  /**
   * Whether this rigid body is kinematic.
   */
  get kinematic() {
    return !!this._engine.wasm._wl_physx_component_get_kinematic(this._id);
  }
  /**
   * Set whether this rigid body's gravity is enabled.
   *
   * @param b Whether the rigid body's gravity should be enabled.
   */
  set gravity(b) {
    this._engine.wasm._wl_physx_component_set_gravity(this._id, b);
  }
  /**
   * Whether this rigid body's gravity flag is enabled.
   */
  get gravity() {
    return !!this._engine.wasm._wl_physx_component_get_gravity(this._id);
  }
  /**
   * Set whether this rigid body's simulate flag is enabled.
   *
   * @param b Whether the rigid body's simulate flag should be enabled.
   */
  set simulate(b) {
    this._engine.wasm._wl_physx_component_set_simulate(this._id, b);
  }
  /**
   * Whether this rigid body's simulate flag is enabled.
   */
  get simulate() {
    return !!this._engine.wasm._wl_physx_component_get_simulate(this._id);
  }
  /**
   * Set whether to allow simulation of this rigid body.
   *
   * {@link allowSimulation} and {@link trigger} can not be enabled at the
   * same time. Enabling {@link allowSimulation} while {@link trigger} is enabled
   * will disable {@link trigger}.
   *
   * @param b Whether to allow simulation of this rigid body.
   */
  set allowSimulation(b) {
    this._engine.wasm._wl_physx_component_set_allowSimulation(this._id, b);
  }
  /**
   * Whether to allow simulation of this rigid body.
   */
  get allowSimulation() {
    return !!this._engine.wasm._wl_physx_component_get_allowSimulation(this._id);
  }
  /**
   * Set whether this rigid body may be queried in ray casts.
   *
   * @param b Whether this rigid body may be queried in ray casts.
   */
  set allowQuery(b) {
    this._engine.wasm._wl_physx_component_set_allowQuery(this._id, b);
  }
  /**
   * Whether this rigid body may be queried in ray casts.
   */
  get allowQuery() {
    return !!this._engine.wasm._wl_physx_component_get_allowQuery(this._id);
  }
  /**
   * Set whether this physics body is a trigger.
   *
   * {@link allowSimulation} and {@link trigger} can not be enabled at the
   * same time. Enabling trigger while {@link allowSimulation} is enabled,
   * will disable {@link allowSimulation}.
   *
   * @param b Whether this physics body is a trigger.
   */
  set trigger(b) {
    this._engine.wasm._wl_physx_component_set_trigger(this._id, b);
  }
  /**
   * Whether this physics body is a trigger.
   */
  get trigger() {
    return !!this._engine.wasm._wl_physx_component_get_trigger(this._id);
  }
  /**
   * Set the shape for collision detection.
   *
   * @param s New shape.
   * @since 0.8.5
   */
  set shape(s) {
    this._engine.wasm._wl_physx_component_set_shape(this._id, s);
  }
  /** The shape for collision detection. */
  get shape() {
    return this._engine.wasm._wl_physx_component_get_shape(this._id);
  }
  /**
   * Set additional data for the shape.
   *
   * Retrieved only from {@link PhysXComponent#shapeData}.
   * @since 0.8.10
   */
  set shapeData(d) {
    if (d == null || !isMeshShape(this.shape))
      return;
    this._engine.wasm._wl_physx_component_set_shape_data(this._id, d.index);
  }
  /**
   * Additional data for the shape.
   *
   * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
   * `{index: n}` for `TriangleMesh` and `ConvexHull`.
   *
   * This data is currently only for passing onto or creating other {@link PhysXComponent}.
   * @since 0.8.10
   */
  get shapeData() {
    if (!isMeshShape(this.shape))
      return null;
    return { index: this._engine.wasm._wl_physx_component_get_shape_data(this._id) };
  }
  /**
   * Set the shape extents for collision detection.
   *
   * @param e New extents for the shape.
   * @since 0.8.5
   */
  set extents(e) {
    this.extents.set(e);
  }
  /**
   * The shape extents for collision detection.
   */
  get extents() {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_physx_component_get_extents(this._id);
    return new Float32Array(wasm.HEAPF32.buffer, ptr, 3);
  }
  /**
   * Get staticFriction.
   */
  get staticFriction() {
    return this._engine.wasm._wl_physx_component_get_staticFriction(this._id);
  }
  /**
   * Set staticFriction.
   * @param v New staticFriction.
   */
  set staticFriction(v) {
    this._engine.wasm._wl_physx_component_set_staticFriction(this._id, v);
  }
  /**
   * Get dynamicFriction.
   */
  get dynamicFriction() {
    return this._engine.wasm._wl_physx_component_get_dynamicFriction(this._id);
  }
  /**
   * Set dynamicFriction
   * @param v New dynamicDamping.
   */
  set dynamicFriction(v) {
    this._engine.wasm._wl_physx_component_set_dynamicFriction(this._id, v);
  }
  /**
   * Get bounciness.
   * @since 0.9.0
   */
  get bounciness() {
    return this._engine.wasm._wl_physx_component_get_bounciness(this._id);
  }
  /**
   * Set bounciness.
   * @param v New bounciness.
   * @since 0.9.0
   */
  set bounciness(v) {
    this._engine.wasm._wl_physx_component_set_bounciness(this._id, v);
  }
  /**
   * Get linearDamping/
   */
  get linearDamping() {
    return this._engine.wasm._wl_physx_component_get_linearDamping(this._id);
  }
  /**
   * Set linearDamping.
   * @param v New linearDamping.
   */
  set linearDamping(v) {
    this._engine.wasm._wl_physx_component_set_linearDamping(this._id, v);
  }
  /** Get angularDamping. */
  get angularDamping() {
    return this._engine.wasm._wl_physx_component_get_angularDamping(this._id);
  }
  /**
   * Set angularDamping.
   * @param v New angularDamping.
   */
  set angularDamping(v) {
    this._engine.wasm._wl_physx_component_set_angularDamping(this._id, v);
  }
  /**
   * Set linear velocity.
   *
   * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New linear velocity.
   */
  set linearVelocity(v) {
    this._engine.wasm._wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);
  }
  /** Linear velocity or `[0, 0, 0]` if the component is not active. */
  get linearVelocity() {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_linearVelocity(this._id, wasm._tempMem);
    return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
  }
  /**
   * Set angular velocity
   *
   * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New angular velocity
   */
  set angularVelocity(v) {
    this._engine.wasm._wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);
  }
  /** Angular velocity or `[0, 0, 0]` if the component is not active. */
  get angularVelocity() {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_angularVelocity(this._id, wasm._tempMem);
    return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
  }
  /**
   * Set the components groups mask.
   *
   * @param flags New flags that need to be set.
   */
  set groupsMask(flags) {
    this._engine.wasm._wl_physx_component_set_groupsMask(this._id, flags);
  }
  /**
   * Get the components groups mask flags.
   *
   * Each bit represents membership to group, see example.
   *
   * ```js
   * // Assign c to group 2
   * c.groupsMask = (1 << 2);
   *
   * // Assign c to group 0
   * c.groupsMask  = (1 << 0);
   *
   * // Assign c to group 0 and 2
   * c.groupsMask = (1 << 0) | (1 << 2);
   *
   * (c.groupsMask & (1 << 2)) != 0; // true
   * (c.groupsMask & (1 << 7)) != 0; // false
   * ```
   */
  get groupsMask() {
    return this._engine.wasm._wl_physx_component_get_groupsMask(this._id);
  }
  /**
   * Set the components blocks mask.
   *
   * @param flags New flags that need to be set.
   */
  set blocksMask(flags) {
    this._engine.wasm._wl_physx_component_set_blocksMask(this._id, flags);
  }
  /**
   * Get the components blocks mask flags.
   *
   * Each bit represents membership to the block, see example.
   *
   * ```js
   * // Block overlap with any objects in group 2
   * c.blocksMask = (1 << 2);
   *
   * // Block overlap with any objects in group 0
   * c.blocksMask  = (1 << 0)
   *
   * // Block overlap with any objects in group 0 and 2
   * c.blocksMask = (1 << 0) | (1 << 2);
   *
   * (c.blocksMask & (1 << 2)) != 0; // true
   * (c.blocksMask & (1 << 7)) != 0; // false
   * ```
   */
  get blocksMask() {
    return this._engine.wasm._wl_physx_component_get_blocksMask(this._id);
  }
  /**
   * Set axes to lock for linear velocity.
   *
   * @param lock The Axis that needs to be set.
   *
   * Combine flags with Bitwise OR.
   * ```js
   * body.linearLockAxis = LockAxis.X | LockAxis.Y; // x and y set
   * body.linearLockAxis = LockAxis.X; // y unset
   * ```
   *
   * @note This has no effect if the component is static.
   */
  set linearLockAxis(lock) {
    this._engine.wasm._wl_physx_component_set_linearLockAxis(this._id, lock);
  }
  /**
   * Get the linear lock axes flags.
   *
   * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
   *
   * ```js
   * if(body.linearLockAxis & LockAxis.Y) {
   *     console.log("The Y flag was set!");
   * }
   * ```
   *
   * @return axes that are currently locked for linear movement.
   */
  get linearLockAxis() {
    return this._engine.wasm._wl_physx_component_get_linearLockAxis(this._id);
  }
  /**
   * Set axes to lock for angular velocity.
   *
   * @param lock The Axis that needs to be set.
   *
   * ```js
   * body.angularLockAxis = LockAxis.X | LockAxis.Y; // x and y set
   * body.angularLockAxis = LockAxis.X; // y unset
   * ```
   *
   * @note This has no effect if the component is static.
   */
  set angularLockAxis(lock) {
    this._engine.wasm._wl_physx_component_set_angularLockAxis(this._id, lock);
  }
  /**
   * Get the angular lock axes flags.
   *
   * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
   *
   * ```js
   * if(body.angularLockAxis & LockAxis.Y) {
   *     console.log("The Y flag was set!");
   * }
   * ```
   *
   * @return axes that are currently locked for angular movement.
   */
  get angularLockAxis() {
    return this._engine.wasm._wl_physx_component_get_angularLockAxis(this._id);
  }
  /**
   * Set mass.
   *
   * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
   *
   * @param m New mass.
   */
  set mass(m) {
    this._engine.wasm._wl_physx_component_set_mass(this._id, m);
  }
  /** Mass */
  get mass() {
    return this._engine.wasm._wl_physx_component_get_mass(this._id);
  }
  /**
   * Set mass space interia tensor.
   *
   * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New mass space interatia tensor.
   */
  set massSpaceInteriaTensor(v) {
    this._engine.wasm._wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);
  }
  /**
   * Apply a force.
   *
   * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
   *
   * Has no effect, if the component is not active.
   *
   * @param f Force vector.
   * @param m Force mode, see {@link ForceMode}, default `Force`.
   * @param localForce Whether the force vector is in local space, default `false`.
   * @param p Position to apply force at, default is center of mass.
   * @param local Whether position is in local space, default `false`.
   */
  addForce(f, m = ForceMode.Force, localForce = false, p, local = false) {
    const wasm = this._engine.wasm;
    if (!p) {
      wasm._wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, localForce);
      return;
    }
    wasm._wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, localForce, p[0], p[1], p[2], local);
  }
  /**
   * Apply torque.
   *
   * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
   *
   * Has no effect, if the component is not active.
   *
   * @param f Force vector.
   * @param m Force mode, see {@link ForceMode}, default `Force`.
   */
  addTorque(f, m = ForceMode.Force) {
    this._engine.wasm._wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);
  }
  /**
   * Add on collision callback.
   *
   * @param callback Function to call when this rigid body (un)collides with any other.
   *
   * ```js
   *  let rigidBody = this.object.getComponent('physx');
   *  rigidBody.onCollision(function(type, other) {
   *      // Ignore uncollides
   *      if(type == CollisionEventType.TouchLost) return;
   *
   *      // Take damage on collision with enemies
   *      if(other.object.name.startsWith('enemy-')) {
   *          this.applyDamage(10);
   *      }
   *  }.bind(this));
   * ```
   *
   * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
   */
  onCollision(callback) {
    return this.onCollisionWith(this, callback);
  }
  /**
   * Add filtered on collision callback.
   *
   * @param otherComp Component for which callbacks will
   *        be triggered. If you pass this component, the method is equivalent to.
   *        {@link PhysXComponent#onCollision}.
   * @param callback Function to call when this rigid body
   *        (un)collides with `otherComp`.
   * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
   */
  onCollisionWith(otherComp, callback) {
    const physics = this._engine.physics;
    physics._callbacks[this._id] = physics._callbacks[this._id] || [];
    physics._callbacks[this._id].push(callback);
    return this._engine.wasm._wl_physx_component_addCallback(this._id, otherComp._id || this._id);
  }
  /**
   * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
   *
   * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
   * @throws When the callback does not belong to the component.
   * @throws When the callback does not exist.
   */
  removeCollisionCallback(callbackId) {
    const physics = this._engine.physics;
    const r = this._engine.wasm._wl_physx_component_removeCallback(this._id, callbackId);
    if (r)
      physics._callbacks[this._id].splice(-r);
  }
};
/** @override */
__publicField(PhysXComponent, "TypeName", "physx");
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "static", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "kinematic", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "gravity", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "simulate", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "allowSimulation", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "allowQuery", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "trigger", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "shape", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "shapeData", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "extents", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "staticFriction", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "dynamicFriction", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "bounciness", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "linearDamping", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "angularDamping", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "linearVelocity", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "angularVelocity", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "groupsMask", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "blocksMask", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "linearLockAxis", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "angularLockAxis", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "mass", null);
var Physics = class {
  /**
   * @hidden
   *
   * **Note**: This is public to emulate a `friend` accessor.
   */
  _callbacks;
  /** Wonderland Engine instance */
  _engine;
  /** Ray Hit */
  _rayHit;
  /** Hit. */
  _hit;
  constructor(engine2) {
    this._engine = engine2;
    this._rayHit = engine2.wasm._malloc(4 * (3 * 4 + 3 * 4 + 4 + 2) + 4);
    this._hit = new RayHit(this._engine, this._rayHit);
    this._callbacks = {};
  }
  /**
   * Cast a ray through the physics scene and find intersecting objects.
   *
   * The resulting ray hit will contain **up to 4** closest ray hits,
   * sorted by increasing distance.
   *
   * @param o Ray origin.
   * @param d Ray direction.
   * @param group Collision group to filter by: only objects that are
   *        part of given group are considered for raycast.
   * @param maxDistance Maximum ray distance, default `100.0`.
   *
   * @returns The RayHit instance, belonging to this class.
   *
   * @note The returned {@link RayHit} object is owned by the Physics instance and
   *       will be reused with the next {@link Physics#rayCast} call.
   */
  rayCast(o, d, group, maxDistance = 100) {
    this._engine.wasm._wl_physx_ray_cast(o[0], o[1], o[2], d[0], d[1], d[2], group, maxDistance, this._rayHit);
    return this._hit;
  }
};
var MeshIndexType;
(function(MeshIndexType3) {
  MeshIndexType3[MeshIndexType3["UnsignedByte"] = 1] = "UnsignedByte";
  MeshIndexType3[MeshIndexType3["UnsignedShort"] = 2] = "UnsignedShort";
  MeshIndexType3[MeshIndexType3["UnsignedInt"] = 4] = "UnsignedInt";
})(MeshIndexType || (MeshIndexType = {}));
var MeshSkinningType;
(function(MeshSkinningType3) {
  MeshSkinningType3[MeshSkinningType3["None"] = 0] = "None";
  MeshSkinningType3[MeshSkinningType3["FourJoints"] = 1] = "FourJoints";
  MeshSkinningType3[MeshSkinningType3["EightJoints"] = 2] = "EightJoints";
})(MeshSkinningType || (MeshSkinningType = {}));
var Mesh = class {
  /**
   * Index of the mesh in the manager.
   *
   * @hidden
   */
  _index = -1;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new instance.
   *
   * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
   *    For more information, please have a look at the {@link MeshParameters} interface.
   */
  constructor(engine2, params) {
    this._engine = engine2 ?? WL;
    this._index = -1;
    if (isNumber(params)) {
      this._index = params;
      return;
    }
    if (!params.vertexCount)
      throw new Error("Missing parameter 'vertexCount'");
    const wasm = this._engine.wasm;
    let indexData = 0;
    let indexType = 0;
    let indexDataSize = 0;
    if (params.indexData) {
      indexType = params.indexType || MeshIndexType.UnsignedShort;
      indexDataSize = params.indexData.length * indexType;
      indexData = wasm._malloc(indexDataSize);
      switch (indexType) {
        case MeshIndexType.UnsignedByte:
          wasm.HEAPU8.set(params.indexData, indexData);
          break;
        case MeshIndexType.UnsignedShort:
          wasm.HEAPU16.set(params.indexData, indexData >> 1);
          break;
        case MeshIndexType.UnsignedInt:
          wasm.HEAPU32.set(params.indexData, indexData >> 2);
          break;
      }
    }
    const { skinningType = MeshSkinningType.None } = params;
    this._index = wasm._wl_mesh_create(indexData, indexDataSize, indexType, params.vertexCount, skinningType);
  }
  /** Number of vertices in this mesh. */
  get vertexCount() {
    return this._engine.wasm._wl_mesh_get_vertexCount(this._index);
  }
  /** Index data (read-only) or `null` if the mesh is not indexed. */
  get indexData() {
    const wasm = this._engine.wasm;
    const tempMem = wasm._tempMem;
    const ptr = wasm._wl_mesh_get_indexData(this._index, tempMem, tempMem + 4);
    if (ptr === null)
      return null;
    const indexCount = wasm.HEAPU32[tempMem / 4];
    const indexSize = wasm.HEAPU32[tempMem / 4 + 1];
    switch (indexSize) {
      case MeshIndexType.UnsignedByte:
        return new Uint8Array(wasm.HEAPU8.buffer, ptr, indexCount);
      case MeshIndexType.UnsignedShort:
        return new Uint16Array(wasm.HEAPU16.buffer, ptr, indexCount);
      case MeshIndexType.UnsignedInt:
        return new Uint32Array(wasm.HEAPU32.buffer, ptr, indexCount);
    }
    return null;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Apply changes to {@link attribute | vertex attributes}.
   *
   * Uploads the updated vertex attributes to the GPU and updates the bounding
   * sphere to match the new vertex positions.
   *
   * Since this is an expensive operation, call it only once you have performed
   * all modifications on a mesh and avoid calling if you did not perform any
   * modifications at all.
   */
  update() {
    this._engine.wasm._wl_mesh_update(this._index);
  }
  getBoundingSphere(out = new Float32Array(4)) {
    const tempMemFloat = this._engine.wasm._tempMemFloat;
    this._engine.wasm._wl_mesh_get_boundingSphere(this._index, this._engine.wasm._tempMem);
    out[0] = tempMemFloat[0];
    out[1] = tempMemFloat[1];
    out[2] = tempMemFloat[2];
    out[3] = tempMemFloat[3];
    return out;
  }
  attribute(attr) {
    if (typeof attr != "number")
      throw new TypeError("Expected number, but got " + typeof attr);
    const tempMemUint32 = this._engine.wasm._tempMemUint32;
    this._engine.wasm._wl_mesh_get_attribute(this._index, attr, this._engine.wasm._tempMem);
    if (tempMemUint32[0] == 255)
      return null;
    const arraySize = tempMemUint32[5];
    return new MeshAttributeAccessor(this._engine, {
      attribute: tempMemUint32[0],
      offset: tempMemUint32[1],
      stride: tempMemUint32[2],
      formatSize: tempMemUint32[3],
      componentCount: tempMemUint32[4],
      /* The WASM API returns `0` for a scalar value. We clamp it to 1 as we strictly use it as a multiplier for get/set operations */
      arraySize: arraySize ? arraySize : 1,
      length: this.vertexCount,
      bufferType: attr !== MeshAttribute.JointId ? Float32Array : Uint16Array
    });
  }
  /**
   * Destroy and free the meshes memory.
   *
   * It is best practice to set the mesh variable to `null` after calling
   * destroy to prevent accidental use:
   *
   * ```js
   *   mesh.destroy();
   *   mesh = null;
   * ```
   *
   * Accessing the mesh after destruction behaves like accessing an empty
   * mesh.
   *
   * @since 0.9.0
   */
  destroy() {
    this._engine.wasm._wl_mesh_destroy(this._index);
  }
  /**
   * Checks equality by comparing whether the wrapped native mesh ids are
   * equal.
   *
   * @param otherMesh Mesh to check equality with.
   * @returns Whether this mesh equals the given mesh.
   *
   * @since 1.0.0
   */
  equals(otherMesh) {
    if (!otherMesh)
      return false;
    return this._index === otherMesh._index;
  }
};
var MeshAttributeAccessor = class {
  /** Max number of elements. */
  length = 0;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Attribute index. @hidden */
  _attribute = -1;
  /** Attribute offset. @hidden */
  _offset = 0;
  /** Attribute stride. @hidden */
  _stride = 0;
  /** Format size native enum. @hidden */
  _formatSize = 0;
  /** Number of components per vertex. @hidden */
  _componentCount = 0;
  /** Number of values per vertex. @hidden */
  _arraySize = 1;
  /**
   * Class to instantiate an ArrayBuffer to get/set values.
   */
  _bufferType;
  /**
   * Function to allocate temporary WASM memory. It is cached in the accessor to avoid
   * conditionals during get/set.
   */
  _tempBufferGetter;
  /**
   * Create a new instance.
   *
   * @note Please use {@link Mesh.attribute} to create a new instance.
   *
   * @param options Contains information about how to read the data.
   * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
   *
   * @hidden
   */
  constructor(engine2, options) {
    this._engine = engine2;
    const wasm = this._engine.wasm;
    this._attribute = options.attribute;
    this._offset = options.offset;
    this._stride = options.stride;
    this._formatSize = options.formatSize;
    this._componentCount = options.componentCount;
    this._arraySize = options.arraySize;
    this._bufferType = options.bufferType;
    this.length = options.length;
    this._tempBufferGetter = this._bufferType === Float32Array ? wasm.getTempBufferF32.bind(wasm) : wasm.getTempBufferU16.bind(wasm);
  }
  /**
   * Create a new TypedArray to hold this attribute's values.
   *
   * This method is useful to create a view to hold the data to
   * pass to {@link get} and {@link set}
   *
   * Example:
   *
   * ```js
   * const vertexCount = 4;
   * const positionAttribute = mesh.attribute(MeshAttributes.Position);
   *
   * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
   * const positions = positionAttribute.createArray(vertexCount);
   * ```
   *
   * @param count The number of **vertices** expected.
   * @returns A TypedArray with the appropriate format to access the data
   */
  createArray(count = 1) {
    count = count > this.length ? this.length : count;
    return new this._bufferType(count * this._componentCount * this._arraySize);
  }
  get(index, out = this.createArray()) {
    if (out.length % this._componentCount !== 0) {
      throw new Error(`out.length, ${out.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
    }
    const dest = this._tempBufferGetter(out.length);
    const elementSize = this._bufferType.BYTES_PER_ELEMENT;
    const destSize = elementSize * out.length;
    const srcFormatSize = this._formatSize * this._arraySize;
    const destFormatSize = this._componentCount * elementSize * this._arraySize;
    this._engine.wasm._wl_mesh_get_attribute_values(this._attribute, srcFormatSize, this._offset + index * this._stride, this._stride, destFormatSize, dest.byteOffset, destSize);
    for (let i = 0; i < out.length; ++i)
      out[i] = dest[i];
    return out;
  }
  /**
   * Set attribute element.
   *
   * @param i Index
   * @param v Value to set the element to
   *
   * `v.length` needs to be a multiple of the attributes component count, see
   * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
   * filled with the next n attribute elements, which can reduce overhead
   * of this call.
   *
   * @returns Reference to self (for method chaining)
   */
  set(i, v) {
    if (v.length % this._componentCount !== 0)
      throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
    const elementSize = this._bufferType.BYTES_PER_ELEMENT;
    const srcSize = elementSize * v.length;
    const srcFormatSize = this._componentCount * elementSize * this._arraySize;
    const destFormatSize = this._formatSize * this._arraySize;
    const wasm = this._engine.wasm;
    if (v.buffer != wasm.HEAPU8.buffer) {
      const dest = this._tempBufferGetter(v.length);
      dest.set(v);
      v = dest;
    }
    wasm._wl_mesh_set_attribute_values(this._attribute, srcFormatSize, v.byteOffset, srcSize, destFormatSize, this._offset + i * this._stride, this._stride);
    return this;
  }
};
var Material = class {
  /**
   * Index of this material in the manager.
   *
   * @hidden
   */
  _index;
  /**
   * Material definition index in the scene.
   *
   * @hidden
   */
  _definition;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new Material.
   *
   * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
   * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
   */
  constructor(engine2, params) {
    this._engine = engine2;
    if (typeof params !== "number") {
      if (!params?.pipeline)
        throw new Error("Missing parameter 'pipeline'");
      const wasm = this._engine.wasm;
      const pipeline = params.pipeline;
      this._index = wasm._wl_material_create(wasm.tempUTF8(pipeline));
      if (this._index < 0)
        throw new Error(`No such pipeline '${pipeline}'`);
    } else {
      this._index = params;
    }
    this._definition = this._engine.wasm._wl_material_get_definition(this._index);
    if (!this._engine.wasm._materialDefinitions[this._definition])
      throw new Error(`Material Definition ${this._definition} not found for material with index ${this._index}`);
    return new Proxy(this, {
      get(target, prop) {
        const wasm = engine2.wasm;
        const definition = wasm._materialDefinitions[target._definition];
        const param = definition.get(prop);
        if (!param)
          return target[prop];
        if (wasm._wl_material_get_param_value(target._index, param.index, wasm._tempMem)) {
          const type = param.type;
          switch (type.type) {
            case MaterialParamType.UnsignedInt:
              return type.componentCount == 1 ? wasm._tempMemUint32[0] : new Uint32Array(wasm.HEAPU32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType.Int:
              return type.componentCount == 1 ? wasm._tempMemInt[0] : new Int32Array(wasm.HEAP32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType.Float:
              return type.componentCount == 1 ? wasm._tempMemFloat[0] : new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType.Sampler:
              return engine2.textures.wrap(wasm._tempMemInt[0]);
            default:
              throw new Error(`Invalid type ${type.type} on parameter ${param.index} for material ${target._index}`);
          }
        }
      },
      set(target, prop, value) {
        const wasm = engine2.wasm;
        const definition = wasm._materialDefinitions[target._definition];
        const param = definition.get(prop);
        if (!param) {
          target[prop] = value;
          return true;
        }
        const type = param.type;
        switch (type.type) {
          case MaterialParamType.UnsignedInt:
          case MaterialParamType.Int:
          case MaterialParamType.Sampler:
            const v = value.id ?? value;
            wasm._wl_material_set_param_value_uint(target._index, param.index, v);
            break;
          case MaterialParamType.Float:
            let count = 1;
            if (typeof value === "number") {
              wasm._tempMemFloat[0] = value;
            } else {
              count = value.length;
              for (let i = 0; i < count; ++i)
                wasm._tempMemFloat[i] = value[i];
            }
            wasm._wl_material_set_param_value_float(target._index, param.index, wasm._tempMem, count);
            break;
          case MaterialParamType.Font:
            throw new Error("Setting font properties is currently unsupported.");
        }
        return true;
      }
    });
  }
  /** @deprecated Use {@link #pipeline} instead. */
  get shader() {
    return this.pipeline;
  }
  /** Name of the pipeline used by this material. */
  get pipeline() {
    const wasm = this._engine.wasm;
    return wasm.UTF8ToString(wasm._wl_material_get_pipeline(this._index));
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Create a copy of the underlying native material.
   *
   * @returns Material clone.
   */
  clone() {
    const id = this._engine.wasm._wl_material_clone(this._index);
    return id > 0 ? new Material(this._engine, id) : null;
  }
  /**
   * Checks equality by comparing whether the wrapped native material ids are
   * equal.
   *
   * @param otherMaterial Material to check equality with.
   * @returns Whether this material equals the given material.
   *
   * @since 1.0.0
   */
  equals(otherMaterial) {
    if (!otherMaterial)
      return false;
    return this._index === otherMaterial._index;
  }
  /**
   * Wrap a native material index.
   *
   * @param engine Engine instance.
   * @param index The index.
   * @returns Material instance or `null` if index <= 0.
   *
   * @deprecated Please use `new Material()` instead.
   */
  static wrap(engine2, index) {
    return index > 0 ? new Material(engine2, index) : null;
  }
};
var temp2d = null;
var Texture = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Index in the manager. @hidden */
  _id = 0;
  /** HTML image index. @hidden */
  _imageIndex = null;
  /**
   * @param engine The engine instance
   * @param param HTML media element to create texture from or texture id to wrap.
   */
  constructor(engine2, param) {
    this._engine = engine2 ?? WL;
    const wasm = engine2.wasm;
    if (param instanceof HTMLImageElement || param instanceof HTMLVideoElement || param instanceof HTMLCanvasElement) {
      const index = wasm._images.length;
      wasm._images.push(param);
      this._imageIndex = index;
      this._id = this._engine.wasm._wl_renderer_addImage(index);
    } else {
      this._id = param;
    }
    this._engine.textures._set(this);
  }
  /** Whether this texture is valid. */
  get valid() {
    return this._id >= 0;
  }
  /** Index in this manager. */
  get id() {
    return this._id;
  }
  /** Update the texture to match the HTML element (e.g. reflect the current frame of a video). */
  update() {
    if (!this.valid || this._imageIndex === null)
      return;
    this._engine.wasm._wl_renderer_updateImage(this._id, this._imageIndex);
  }
  /** Width of the texture. */
  get width() {
    return this._engine.wasm._wl_texture_width(this._id);
  }
  /** Height of the texture. */
  get height() {
    return this._engine.wasm._wl_texture_height(this._id);
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video).
   *
   * Usage:
   *
   * ```js
   * // Copies rectangle of pixel starting from (10, 20)
   * texture.updateSubImage(10, 20, 600, 400);
   * ```
   *
   * @param x x offset
   * @param y y offset
   * @param w width
   * @param h height
   */
  updateSubImage(x, y, w, h) {
    if (!this.valid || this._imageIndex === null)
      return;
    if (!temp2d) {
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      if (!ctx) {
        throw new Error("Texture.updateSubImage(): Failed to obtain CanvasRenderingContext2D.");
      }
      temp2d = { canvas: canvas2, ctx };
    }
    const wasm = this._engine.wasm;
    const img = wasm._images[this._imageIndex];
    if (!img)
      return;
    temp2d.canvas.width = w;
    temp2d.canvas.height = h;
    temp2d.ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
    const yOffset = (img.videoHeight ?? img.height) - y - h;
    wasm._images[this._imageIndex] = temp2d.canvas;
    wasm._wl_renderer_updateImage(this._id, this._imageIndex, x, yOffset);
    wasm._images[this._imageIndex] = img;
  }
  /**
   * Destroy and free the texture's texture altas space and memory.
   *
   * It is best practice to set the texture variable to `null` after calling
   * destroy to prevent accidental use of the invalid texture:
   *
   * ```js
   *   texture.destroy();
   *   texture = null;
   * ```
   *
   * @since 0.9.0
   */
  destroy() {
    this.engine.textures._destroy(this);
    this._id = -1;
    this._imageIndex = null;
  }
  /**
   * Checks equality by comparing whether the wrapped native texture ids are
   * equal.
   *
   * @param otherTexture Texture to check equality with.
   * @returns Whether this texture equals the given texture.
   *
   * @since 1.0.0
   */
  equals(otherTexture) {
    if (!otherTexture)
      return false;
    return this._id === otherTexture._id;
  }
};
var Animation = class {
  /** Index of the mesh in the manager. @hidden */
  _index;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * @param index Index in the manager
   */
  constructor(engine2 = WL, index) {
    this._engine = engine2;
    this._index = index;
  }
  /** Duration of this animation. */
  get duration() {
    return this._engine.wasm._wl_animation_get_duration(this._index);
  }
  /** Number of tracks in this animation. */
  get trackCount() {
    return this._engine.wasm._wl_animation_get_trackCount(this._index);
  }
  /**
   * Clone this animation retargeted to a new set of objects.
   *
   * The clone shares most of the data with the original and is therefore
   * light-weight.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * If retargeting to {@link Skin}, the join names will be used to determine a mapping
   * from the previous skin to the new skin. The source skin will be retrieved from
   * the first track in the animation that targets a joint.
   *
   * @param newTargets New targets per track. Expected to have
   *      {@link Animation#trackCount} elements or to be a {@link Skin}.
   * @returns The retargeted clone of this animation.
   */
  retarget(newTargets) {
    const wasm = this._engine.wasm;
    if (newTargets instanceof Skin) {
      const animId2 = wasm._wl_animation_retargetToSkin(this._index, newTargets._index);
      return new Animation(this._engine, animId2);
    }
    if (newTargets.length != this.trackCount) {
      throw Error("Expected " + this.trackCount.toString() + " targets, but got " + newTargets.length.toString());
    }
    const ptr = wasm._malloc(2 * newTargets.length);
    for (let i = 0; i < newTargets.length; ++i) {
      wasm.HEAPU16[ptr >> 1 + i] = newTargets[i].objectId;
    }
    const animId = wasm._wl_animation_retarget(this._index, ptr);
    wasm._free(ptr);
    return new Animation(this._engine, animId);
  }
  /**
   * Checks equality by comparing whether the wrapped native animation ids
   * are equal.
   *
   * @param otherAnimation Animation to check equality with.
   * @returns Whether this animation equals the given animation.
   *
   * @since 1.0.0
   */
  equals(otherAnimation) {
    if (!otherAnimation)
      return false;
    return this._index === otherAnimation._index;
  }
};
var Object3D = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Object index in the manager.
   *
   * @hidden
   */
  _objectId = -1;
  /**
   * @param o Object id to wrap
   *
   * For performance reasons, please use {@link WonderlandEngine.wrapObject}
   */
  constructor(engine2, o) {
    this._objectId = o;
    this._engine = engine2;
  }
  /**
   * Name of the object.
   *
   * Useful for identifying objects during debugging.
   */
  get name() {
    const wasm = this._engine.wasm;
    return wasm.UTF8ToString(wasm._wl_object_name(this.objectId));
  }
  /**
   * Set the object's name.
   *
   * @param newName The new name to set.
   */
  set name(newName) {
    const wasm = this._engine.wasm;
    wasm._wl_object_set_name(this.objectId, wasm.tempUTF8(newName));
  }
  /**
   * Parent of this object or `null` if parented to root.
   */
  get parent() {
    const p = this._engine.wasm._wl_object_parent(this.objectId);
    return p === 0 ? null : this._engine.wrapObject(p);
  }
  /**
   * Children of this object.
   */
  get children() {
    const childrenCount = this._engine.wasm._wl_object_get_children_count(this.objectId);
    if (childrenCount === 0)
      return [];
    const wasm = this._engine.wasm;
    wasm.requireTempMem(childrenCount * 2);
    this._engine.wasm._wl_object_get_children(this.objectId, wasm._tempMem, wasm._tempMemSize >> 1);
    const children = new Array(childrenCount);
    for (let i = 0; i < childrenCount; ++i) {
      children[i] = this._engine.wrapObject(wasm._tempMemUint16[i]);
    }
    return children;
  }
  /**
   * Reparent object to given object.
   *
   * @note Reparenting is not trivial and might have a noticeable performance impact.
   *
   * @param newParent New parent or `null` to parent to root
   */
  set parent(newParent) {
    this._engine.wasm._wl_object_set_parent(this.objectId, newParent == null ? 0 : newParent.objectId);
  }
  /** Object index in the manager. */
  get objectId() {
    return this._objectId;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Reset local transformation (translation, rotation and scaling) to identity.
   *
   * @returns Reference to self (for method chaining).
   */
  resetTransform() {
    this._engine.wasm._wl_object_reset_translation_rotation(this.objectId);
    this._engine.wasm._wl_object_reset_scaling(this.objectId);
    return this;
  }
  /**
   * Reset local position and rotation to identity.
   *
   * @returns Reference to self (for method chaining).
   */
  resetPositionRotation() {
    this._engine.wasm._wl_object_reset_translation_rotation(this.objectId);
    return this;
  }
  /** @deprecated Please use {@link Object3D.resetPositionRotation} instead. */
  resetTranslationRotation() {
    return this.resetPositionRotation();
  }
  /**
   * Reset local rotation, keep translation.
   *
   * @note To reset both rotation and translation, prefer
   *       {@link resetTranslationRotation}.
   *
   * @returns Reference to self (for method chaining).
   */
  resetRotation() {
    this._engine.wasm._wl_object_reset_rotation(this.objectId);
    return this;
  }
  /**
   * Reset local translation, keep rotation.
   *
   * @note To reset both rotation and translation, prefer
   *       {@link resetTranslationRotation}.
   *
   * @returns Reference to self (for method chaining).
   */
  resetPosition() {
    this._engine.wasm._wl_object_reset_translation(this.objectId);
    return this;
  }
  /** @deprecated Please use {@link Object3D.resetPosition} instead. */
  resetTranslation() {
    return this.resetPosition();
  }
  /**
   * Reset local scaling to identity (``[1.0, 1.0, 1.0]``).
   *
   * @returns Reference to self (for method chaining).
   */
  resetScaling() {
    this._engine.wasm._wl_object_reset_scaling(this.objectId);
    return this;
  }
  /** @deprecated Please use {@link Object3D.translateLocal} instead. */
  translate(v) {
    return this.translateLocal(v);
  }
  /**
   * Translate object by a vector in the parent's space.
   *
   * @param v Vector to translate by.
   *
   * @returns Reference to self (for method chaining).
   */
  translateLocal(v) {
    this._engine.wasm._wl_object_translate(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /**
   * Translate object by a vector in object space.
   *
   * @param v Vector to translate by.
   *
   * @returns Reference to self (for method chaining).
   */
  translateObject(v) {
    this._engine.wasm._wl_object_translate_obj(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /**
   * Translate object by a vector in world space.
   *
   * @param v Vector to translate by.
   *
   * @returns Reference to self (for method chaining).
   */
  translateWorld(v) {
    this._engine.wasm._wl_object_translate_world(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.rotateAxisAngleDegLocal} instead. */
  rotateAxisAngleDeg(a, d) {
    this.rotateAxisAngleDegLocal(a, d);
    return this;
  }
  /**
   * Rotate around given axis by given angle (degrees) in local space.
   *
   * @param a Vector representing the rotation axis.
   * @param d Angle in degrees.
   *
   * @note If the object is translated the rotation will be around
   *     the parent. To rotate around the object origin, use
   *     {@link rotateAxisAngleDegObject}
   *
   * @see {@link rotateAxisAngleRad}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleDegLocal(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /** @deprecated Please use {@link Object3D.rotateAxisAngleRadLocal} instead. */
  rotateAxisAngleRad(a, d) {
    return this.rotateAxisAngleRadLocal(a, d);
  }
  /**
   * Rotate around given axis by given angle (radians) in local space.
   *
   * @param a Vector representing the rotation axis.
   * @param d Angle in radians.
   *
   * @note If the object is translated the rotation will be around
   *     the parent. To rotate around the object origin, use
   *     {@link rotateAxisAngleDegObject}
   *
   * @see {@link rotateAxisAngleDeg}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleRadLocal(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle_rad(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /**
   * Rotate around given axis by given angle (degrees) in object space.
   *
   * @param a Vector representing the rotation axis.
   * @param d Angle in degrees.
   *
   * Equivalent to prepending a rotation quaternion to the object's
   * local transformation.
   *
   * @see {@link rotateAxisAngleRadObject}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleDegObject(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle_obj(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /**
   * Rotate around given axis by given angle (radians) in object space
   * Equivalent to prepending a rotation quaternion to the object's
   * local transformation.
   *
   * @param a Vector representing the rotation axis
   * @param d Angle in degrees
   *
   * @see {@link rotateAxisAngleDegObject}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleRadObject(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle_rad_obj(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /** @deprecated Please use {@link Object3D.rotateLocal} instead. */
  rotate(q) {
    this.rotateLocal(q);
    return this;
  }
  /**
   * Rotate by a quaternion.
   *
   * @param q the Quaternion to rotate by.
   *
   * @returns Reference to self (for method chaining).
   */
  rotateLocal(q) {
    this._engine.wasm._wl_object_rotate_quat(this.objectId, q[0], q[1], q[2], q[3]);
    return this;
  }
  /**
   * Rotate by a quaternion in object space.
   *
   * Equivalent to prepending a rotation quaternion to the object's
   * local transformation.
   *
   * @param q the Quaternion to rotate by.
   *
   * @returns Reference to self (for method chaining).
   */
  rotateObject(q) {
    this._engine.wasm._wl_object_rotate_quat_obj(this.objectId, q[0], q[1], q[2], q[3]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.scaleLocal} instead. */
  scale(v) {
    this.scaleLocal(v);
    return this;
  }
  /**
   * Scale object by a vector in object space.
   *
   * @param v Vector to scale by.
   *
   * @returns Reference to self (for method chaining).
   */
  scaleLocal(v) {
    this._engine.wasm._wl_object_scale(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  getPositionLocal(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    wasm._wl_object_get_translation_local(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  getTranslationLocal(out = new Float32Array(3)) {
    return this.getPositionLocal(out);
  }
  getPositionWorld(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    wasm._wl_object_get_translation_world(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  getTranslationWorld(out = new Float32Array(3)) {
    return this.getPositionWorld(out);
  }
  /**
   * Set local / object space position.
   *
   * Concatenates a new translation dual quaternion onto the existing rotation.
   *
   * @param v New local position array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setPositionLocal(v) {
    this._engine.wasm._wl_object_set_translation_local(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.setPositionLocal} instead. */
  setTranslationLocal(v) {
    return this.setPositionLocal(v);
  }
  /**
   * Set world space position.
   *
   * Applies the inverse parent transform with a new translation dual quaternion
   * which is concatenated onto the existing rotation.
   *
   * @param v New world position array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setPositionWorld(v) {
    this._engine.wasm._wl_object_set_translation_world(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.setPositionWorld} instead. */
  setTranslationWorld(v) {
    return this.setPositionWorld(v);
  }
  getScalingLocal(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_scaling_local(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set local / object space scaling.
   *
   * @param v New local scaling array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setScalingLocal(v) {
    this._engine.wasm._wl_object_set_scaling_local(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  getScalingWorld(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_scaling_world(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set World space scaling.
   *
   * @param v New world scaling array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setScalingWorld(v) {
    this._engine.wasm._wl_object_set_scaling_world(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  getRotationLocal(out = new Float32Array(4)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_local(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    return out;
  }
  /**
   * Set local space rotation.
   *
   * @param v New world rotation array/vector, expected to have at least 4 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setRotationLocal(v) {
    this._engine.wasm._wl_object_set_rotation_local(this.objectId, v[0], v[1], v[2], v[3]);
    return this;
  }
  getRotationWorld(out = new Float32Array(4)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_world(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    return out;
  }
  /**
   * Set local space rotation.
   *
   * @param v New world rotation array/vector, expected to have at least 4 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setRotationWorld(v) {
    this._engine.wasm._wl_object_set_rotation_world(this.objectId, v[0], v[1], v[2], v[3]);
    return this;
  }
  getTransformLocal(out = new Float32Array(8)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_local(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    out[4] = wasm.HEAPF32[ptr + 4];
    out[5] = wasm.HEAPF32[ptr + 5];
    out[6] = wasm.HEAPF32[ptr + 6];
    out[7] = wasm.HEAPF32[ptr + 7];
    return out;
  }
  /**
   * Set local space rotation.
   *
   * @param v New local transform array, expected to have at least 8 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setTransformLocal(v) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_local(this.objectId) / 4;
    wasm.HEAPF32[ptr] = v[0];
    wasm.HEAPF32[ptr + 1] = v[1];
    wasm.HEAPF32[ptr + 2] = v[2];
    wasm.HEAPF32[ptr + 3] = v[3];
    wasm.HEAPF32[ptr + 4] = v[4];
    wasm.HEAPF32[ptr + 5] = v[5];
    wasm.HEAPF32[ptr + 6] = v[6];
    wasm.HEAPF32[ptr + 7] = v[7];
    this.setDirty();
    return this;
  }
  getTransformWorld(out = new Float32Array(8)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_world(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    out[4] = wasm.HEAPF32[ptr + 4];
    out[5] = wasm.HEAPF32[ptr + 5];
    out[6] = wasm.HEAPF32[ptr + 6];
    out[7] = wasm.HEAPF32[ptr + 7];
    return out;
  }
  /**
   * Set world space rotation.
   *
   * @param v New world transform array, expected to have at least 8 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setTransformWorld(v) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_world(this.objectId) / 4;
    wasm.HEAPF32[ptr] = v[0];
    wasm.HEAPF32[ptr + 1] = v[1];
    wasm.HEAPF32[ptr + 2] = v[2];
    wasm.HEAPF32[ptr + 3] = v[3];
    wasm.HEAPF32[ptr + 4] = v[4];
    wasm.HEAPF32[ptr + 5] = v[5];
    wasm.HEAPF32[ptr + 6] = v[6];
    wasm.HEAPF32[ptr + 7] = v[7];
    this._engine.wasm._wl_object_trans_world_to_local(this.objectId);
    return this;
  }
  /**
   * Local space transformation.
   *
   * @deprecated Please use {@link Object3D.setTransformLocal} and
   * {@link Object3D.getTransformLocal} instead.
   */
  get transformLocal() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_trans_local(this.objectId), 8);
  }
  /**
   * Set local transform.
   *
   * @param t Local space transformation.
   *
   * @since 0.8.5
   *
   * @deprecated Please use {@link Object3D.setTransformLocal} and
   * {@link Object3D.getTransformLocal} instead.
   */
  set transformLocal(t) {
    this.transformLocal.set(t);
    this.setDirty();
  }
  /**
   * Global / world space transformation.
   *
   * May recompute transformations of the hierarchy of this object,
   * if they were changed by JavaScript components this frame.
   *
   * @deprecated Please use {@link Object3D.setTransformWorld} and
   * {@link Object3D.getTransformWorld} instead.
   */
  get transformWorld() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_trans_world(this.objectId), 8);
  }
  /**
   * Set world transform.
   *
   * @param t Global / world space transformation.
   *
   * @since 0.8.5
   *
   * @deprecated Please use {@link Object3D.setTransformWorld} and
   * {@link Object3D.getTransformWorld} instead.
   */
  set transformWorld(t) {
    this.transformWorld.set(t);
    this._engine.wasm._wl_object_trans_world_to_local(this.objectId);
  }
  /**
   * Local / object space scaling.
   *
   * @deprecated Please use {@link Object3D.setScalingLocal} and
   * {@link Object3D.getScalingLocal} instead.
   */
  get scalingLocal() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_scaling_local(this.objectId), 3);
  }
  /**
   * Set local space scaling.
   *
   * @param s Local space scaling.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.setScalingLocal} and
   * {@link Object3D.getScalingLocal} instead.
   */
  set scalingLocal(s) {
    this.scalingLocal.set(s);
    this.setDirty();
  }
  /**
   * Global / world space scaling.
   *
   * May recompute transformations of the hierarchy of this object,
   * if they were changed by JavaScript components this frame.
   *
   * @deprecated Please use {@link Object3D.setScalingWorld} and
   * {@link Object3D.getScalingWorld} instead.
   */
  get scalingWorld() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_scaling_world(this.objectId), 3);
  }
  /**
   * Set world space scaling.
   *
   * @param t World space scaling.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.setScalingWorld} and
   * {@link Object3D.getScalingWorld} instead.
   */
  set scalingWorld(s) {
    this.scalingWorld.set(s);
    this._engine.wasm._wl_object_scaling_world_to_local(this.objectId);
  }
  /**
   * Local space rotation.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationLocal} and
   * {@link Object3D.setRotationLocal} instead.
   */
  get rotationLocal() {
    return this.transformLocal.subarray(0, 4);
  }
  /**
   * Global / world space rotation
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationWorld} and
   * {@link Object3D.setRotationWorld} instead.
   */
  get rotationWorld() {
    return this.transformWorld.subarray(0, 4);
  }
  /**
   * Set local space rotation.
   *
   * @param r Local space rotation
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationLocal} and
   * {@link Object3D.setRotationLocal} instead.
   */
  set rotationLocal(r) {
    this._engine.wasm._wl_object_set_rotation_local(this.objectId, r[0], r[1], r[2], r[3]);
  }
  /**
   * Set world space rotation.
   *
   * @param r Global / world space rotation.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationWorld} and
   * {@link Object3D.setRotationWorld} instead.
   */
  set rotationWorld(r) {
    this._engine.wasm._wl_object_set_rotation_world(this.objectId, r[0], r[1], r[2], r[3]);
  }
  /** @deprecated Please use {@link Object3D.getForwardWorld} instead. */
  getForward(out) {
    return this.getForwardWorld(out);
  }
  /**
   * Compute the object's forward facing world space vector.
   *
   * The forward vector in object space is along the negative z-axis, i.e.,
   * `[0, 0, -1]`.
   *
   * @param out Destination array/vector, expected to have at least 3 elements.
   * @return The `out` parameter.
   */
  getForwardWorld(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = -1;
    this.transformVectorWorld(out);
    return out;
  }
  /** @deprecated Please use {@link Object3D.getUpWorld} instead. */
  getUp(out) {
    return this.getUpWorld(out);
  }
  /**
   * Compute the object's up facing world space vector.
   *
   * @param out Destination array/vector, expected to have at least 3 elements.
   * @return The `out` parameter.
   */
  getUpWorld(out) {
    out[0] = 0;
    out[1] = 1;
    out[2] = 0;
    this.transformVectorWorld(out);
    return out;
  }
  /** @deprecated Please use {@link Object3D.getRightWorld} instead. */
  getRight(out) {
    return this.getRightWorld(out);
  }
  /**
   * Compute the object's right facing world space vector.
   *
   * @param out Destination array/vector, expected to have at least 3 elements.
   * @return The `out` parameter.
   */
  getRightWorld(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    this.transformVectorWorld(out);
    return out;
  }
  /**
   * Transform a vector by this object's world transform.
   *
   * @param out Out vector
   * @param v Vector to transform, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorWorld(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a vector by this object's local transform.
   *
   * @param out Out vector
   * @param v Vector to transform, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorLocal(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's world transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointWorld(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = p[0];
    wasm._tempMemFloat[1] = p[1];
    wasm._tempMemFloat[2] = p[2];
    wasm._wl_object_transformPointWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's local transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointLocal(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = p[0];
    wasm._tempMemFloat[1] = p[1];
    wasm._tempMemFloat[2] = p[2];
    wasm._wl_object_transformPointLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a vector by this object's inverse world transform.
   *
   * @param out Out vector.
   * @param v Vector to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorInverseWorld(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorInverseWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a vector by this object's inverse local transform.
   *
   * @param out Out vector
   * @param v Vector to transform, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorInverseLocal(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorInverseLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's inverse world transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointInverseWorld(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = p[0];
    wasm._tempMemFloat[1] = p[1];
    wasm._tempMemFloat[2] = p[2];
    wasm._wl_object_transformPointInverseWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's inverse local transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointInverseLocal(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat.set(p);
    wasm._wl_object_transformPointInverseLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform an object space dual quaternion into world space.
   *
   * @param out Out transformation.
   * @param q Local space transformation, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  toWorldSpaceTransform(out, q = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat.set(q);
    wasm._wl_object_toWorldSpaceTransform(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    out[3] = wasm._tempMemFloat[3];
    out[4] = wasm._tempMemFloat[4];
    out[5] = wasm._tempMemFloat[5];
    out[6] = wasm._tempMemFloat[6];
    out[7] = wasm._tempMemFloat[7];
    return out;
  }
  /**
   * Transform a world space dual quaternion into local space.
   *
   * @param out Out transformation
   * @param q World space transformation, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  toLocalSpaceTransform(out, q = out) {
    const p = this.parent;
    if (p) {
      p.toObjectSpaceTransform(out, q);
      return out;
    }
    if (out !== q) {
      out[0] = q[0];
      out[1] = q[1];
      out[2] = q[2];
      out[3] = q[3];
      out[4] = q[4];
      out[5] = q[5];
      out[6] = q[6];
      out[7] = q[7];
    }
    return out;
  }
  /**
   * Transform a world space dual quaternion into object space.
   *
   * @param out Out transformation.
   * @param q World space transformation, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  toObjectSpaceTransform(out, q = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat.set(q);
    wasm._wl_object_toObjectSpaceTransform(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    out[3] = wasm._tempMemFloat[3];
    out[4] = wasm._tempMemFloat[4];
    out[5] = wasm._tempMemFloat[5];
    out[6] = wasm._tempMemFloat[6];
    out[7] = wasm._tempMemFloat[7];
    return out;
  }
  /**
   * Turn towards / look at target.
   *
   * Rotates the object so that its forward vector faces towards the target
   * position. The `up` vector acts as a hint to uniquely orient the object's
   * up direction. When orienting a view component, the projected `up` vector
   * faces upwards on the viewing plane.
   *
   * @param p Target position to turn towards, in world space.
   * @param up Up vector to align object with, in world space. Default is `[0, 1, 0]`.
   *
   * @returns Reference to self (for method chaining).
   */
  lookAt(p, up = UP_VECTOR) {
    this._engine.wasm._wl_object_lookAt(this.objectId, p[0], p[1], p[2], up[0], up[1], up[2]);
    return this;
  }
  /** Destroy the object with all of its components and remove it from the scene */
  destroy() {
    this._engine.wasm._wl_scene_remove_object(this.objectId);
    this._objectId = -1;
  }
  /**
   * Mark transformation dirty.
   *
   * Causes an eventual recalculation of {@link transformWorld}, either
   * on next {@link getTranslationWorld}, {@link transformWorld} or
   * {@link scalingWorld} or the beginning of next frame, whichever
   * happens first.
   */
  setDirty() {
    this._engine.wasm._wl_object_set_dirty(this.objectId);
  }
  /**
   * Disable/enable all components of this object.
   *
   * @param b New state for the components.
   *
   * @since 0.8.5
   */
  set active(b) {
    const comps = this.getComponents();
    for (let c of comps) {
      c.active = b;
    }
  }
  getComponent(typeOrClass, index = 0) {
    const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
    const wasm = this._engine.wasm;
    const componentType = wasm._wl_get_component_manager_index(wasm.tempUTF8(type));
    if (componentType < 0) {
      const typeIndex = wasm._componentTypeIndices[type];
      if (typeIndex === void 0)
        return null;
      const jsIndex = wasm._wl_get_js_component_index(this.objectId, typeIndex, index);
      return jsIndex < 0 ? null : this._engine.wasm._components[jsIndex];
    }
    const componentId = this._engine.wasm._wl_get_component_id(this.objectId, componentType, index);
    return this._engine._wrapComponent(type, componentType, componentId);
  }
  /**
   * @param typeOrClass Type name, pass a falsey value (`undefined` or `null`) to retrieve all.
   *     It's also possible to give a class definition. In this case, the method will use the `class.TypeName` field to
   *     find the components.
   * @returns All components of given type attached to this object.
   *
   * @note As this function is non-trivial, avoid using it in `update()` repeatedly,
   *      but rather store its result in `init()` or `start()`
   * @warning This method will currently return at most 341 components.
   */
  getComponents(typeOrClass) {
    const wasm = this._engine.wasm;
    let componentType = null;
    let type = null;
    if (typeOrClass) {
      type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
      componentType = wasm._typeIndexFor(type);
    }
    const components = [];
    const maxComps = Math.floor(wasm._tempMemSize / 3 * 2);
    const componentsCount = wasm._wl_object_get_components(this.objectId, wasm._tempMem, maxComps);
    const offset2 = 2 * componentsCount;
    wasm._wl_object_get_component_types(this.objectId, wasm._tempMem + offset2, maxComps);
    const jsManagerIndex = wasm._typeIndexFor("js");
    for (let i = 0; i < componentsCount; ++i) {
      const t = wasm._tempMemUint8[i + offset2];
      const componentId = wasm._tempMemUint16[i];
      if (t == jsManagerIndex) {
        const typeIndex = wasm._wl_get_js_component_index_for_id(componentId);
        const comp = wasm._components[typeIndex];
        if (componentType === null || comp.type == type)
          components.push(comp);
        continue;
      }
      if (componentType === null) {
        const managerName = wasm._typeNameFor(t);
        components.push(this._engine._wrapComponent(managerName, t, componentId));
      } else if (t == componentType) {
        components.push(this._engine._wrapComponent(type, componentType, componentId));
      }
    }
    return components;
  }
  addComponent(typeOrClass, params) {
    const wasm = this._engine.wasm;
    const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
    const componentType = wasm._typeIndexFor(type);
    let component = null;
    let componentIndex = null;
    if (componentType < 0) {
      if (!(type in wasm._componentTypeIndices)) {
        throw new TypeError("Unknown component type '" + type + "'");
      }
      const componentId = wasm._wl_object_add_js_component(this.objectId, wasm._componentTypeIndices[type]);
      componentIndex = wasm._wl_get_js_component_index_for_id(componentId);
      component = wasm._components[componentIndex];
    } else {
      const componentId = wasm._wl_object_add_component(this.objectId, componentType);
      component = this._engine._wrapComponent(type, componentType, componentId);
    }
    if (params !== void 0) {
      const ctor = component.constructor;
      for (const key in params) {
        if (!(key in ctor.Properties))
          continue;
        component[key] = params[key];
      }
    }
    if (componentType < 0) {
      wasm._wljs_component_init(componentIndex);
    }
    if (!params || !("active" in params && !params.active)) {
      component.active = true;
    }
    return component;
  }
  /**
   * Whether given object's transformation has changed.
   */
  get changed() {
    return !!this._engine.wasm._wl_object_is_changed(this.objectId);
  }
  /**
   * Checks equality by comparing whether the wrapped native object ids are
   * equal.
   *
   * @param otherObject Object to check equality with.
   * @returns Whether this object equals the given object.
   */
  equals(otherObject) {
    if (!otherObject)
      return false;
    return this.objectId == otherObject.objectId;
  }
};
var Skin = class {
  /**
   * Index of the skin in the manager.
   * @hidden
   */
  _index;
  /** Wonderland Engine instance. @hidden */
  _engine;
  constructor(engine2, index) {
    this._engine = engine2;
    this._index = index;
  }
  /** Amount of joints in this skin. */
  get jointCount() {
    return this._engine.wasm._wl_skin_get_joint_count(this._index);
  }
  /** Joints object ids for this skin */
  get jointIds() {
    const wasm = this._engine.wasm;
    return new Uint16Array(wasm.HEAPU16.buffer, wasm._wl_skin_joint_ids(this._index), this.jointCount);
  }
  /**
   * Dual quaternions in a flat array of size 8 times {@link jointCount}.
   *
   * Inverse bind transforms of the skin.
   */
  get inverseBindTransforms() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_transforms(this._index), 8 * this.jointCount);
  }
  /**
   * Vectors in a flat array of size 3 times {@link jointCount}.
   *
   * Inverse bind scalings of the skin.
   */
  get inverseBindScalings() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_scalings(this._index), 3 * this.jointCount);
  }
  /**
   * Checks equality by comparing whether the wrapped native skin ids are
   * equal.
   *
   * @param otherSkin Skin to check equality with.
   * @returns Whether this skin equals the given skin.
   *
   * @since 1.0.0
   */
  equals(otherSkin) {
    if (!otherSkin)
      return false;
    return this._index === otherSkin._index;
  }
};
var RayHit = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Pointer to the memory heap. */
  _ptr;
  /**
   * @param ptr Pointer to the ray hits memory.
   */
  constructor(engine2, ptr) {
    if ((ptr & 3) !== 0) {
      throw new Error("Misaligned pointer: please report a bug");
    }
    this._engine = engine2;
    this._ptr = ptr;
  }
  /** Array of ray hit locations. */
  get locations() {
    let p = this._ptr;
    let l = [];
    for (let i = 0; i < this.hitCount; ++i) {
      l.push(new Float32Array(this._engine.wasm.HEAPF32.buffer, p + 12 * i, 3));
    }
    return l;
  }
  /** Array of ray hit normals (only when using {@link Physics#rayCast}. */
  get normals() {
    let p = this._ptr + 48;
    let l = [];
    for (let i = 0; i < this.hitCount; ++i) {
      l.push(new Float32Array(this._engine.wasm.HEAPF32.buffer, p + 12 * i, 3));
    }
    return l;
  }
  /**
   * Prefer these to recalculating the distance from locations.
   *
   * Distances of array hits to ray origin.
   */
  get distances() {
    const p = this._ptr + 48 * 2;
    return new Float32Array(this._engine.wasm.HEAPF32.buffer, p, this.hitCount);
  }
  /** Hit objects */
  get objects() {
    const HEAPU16 = this._engine.wasm.HEAPU16;
    const objects = [null, null, null, null];
    let p = this._ptr + (48 * 2 + 16) >> 1;
    for (let i = 0; i < this.hitCount; ++i) {
      objects[i] = this._engine.wrapObject(HEAPU16[p + i]);
    }
    return objects;
  }
  /** Number of hits (max 4) */
  get hitCount() {
    return Math.min(this._engine.wasm.HEAPU32[this._ptr / 4 + 30], 4);
  }
};
var math = class {
  /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.
   *
   * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.
   *
   * Whether a quaternion or vector3 interpolation is intended is determined by
   * length of `a`.
   *
   * @param out Array to write result to.
   * @param a First tangent/handle.
   * @param b First point or quaternion.
   * @param c Second point or quaternion.
   * @param d Second handle.
   * @param f Interpolation factor in [0; 1].
   * @returns The `out` parameter.
   *
   * @since 0.8.6
   */
  static cubicHermite(out, a, b, c, d, f, engine2 = WL) {
    const wasm = engine2.wasm;
    wasm._tempMemFloat.subarray(0).set(a);
    wasm._tempMemFloat.subarray(4).set(b);
    wasm._tempMemFloat.subarray(8).set(c);
    wasm._tempMemFloat.subarray(12).set(d);
    const isQuat = a.length == 4;
    wasm._wl_math_cubicHermite(wasm._tempMem + 4 * 16, wasm._tempMem + 4 * 0, wasm._tempMem + 4 * 4, wasm._tempMem + 4 * 8, wasm._tempMem + 4 * 12, f, isQuat);
    out[0] = wasm._tempMemFloat[16];
    out[1] = wasm._tempMemFloat[17];
    out[2] = wasm._tempMemFloat[18];
    if (isQuat)
      out[3] = wasm._tempMemFloat[19];
    return out;
  }
};
var I18N = class {
  /**
   * {@link Emitter} for language change events.
   *
   * First parameter to a listener is the old language index,
   * second parameter is the new language index.
   *
   * Usage from a within a component:
   * ```js
   * this.engine.i18n.onLanguageChanged.add((oldLanguageIndex, newLanguageIndex) => {
   *     const oldLanguage = this.engine.i18n.languageName(oldLanguageIndex);
   *     const newLanguage = this.engine.i18n.languageName(newLanguageIndex);
   *     console.log("Switched from", oldLanguage, "to", newLanguage);
   * });
   * ```
   */
  onLanguageChanged = new Emitter();
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Constructor
   */
  constructor(engine2) {
    this._engine = engine2;
  }
  /**
   * Set current language and apply translations to linked text parameters.
   *
   * @param code Language code to switch to
   */
  set language(code) {
    if (code == null)
      return;
    const wasm = this._engine.wasm;
    wasm._wl_i18n_setLanguage(wasm.tempUTF8(code));
  }
  /**
   * Get current language code.
   *
   */
  get language() {
    const wasm = this._engine.wasm;
    const code = wasm._wl_i18n_currentLanguage();
    if (code === 0)
      return null;
    return wasm.UTF8ToString(code);
  }
  /**
   * Get translated string for a term for the currently loaded language.
   *
   * @param term Term to translate
   */
  translate(term) {
    const wasm = this._engine.wasm;
    const translation = wasm._wl_i18n_translate(wasm.tempUTF8(term));
    if (translation === 0)
      return null;
    return wasm.UTF8ToString(translation);
  }
  /**
   * Get the number of languages in the project.
   *
   */
  languageCount() {
    const wasm = this._engine.wasm;
    return wasm._wl_i18n_languageCount();
  }
  /**
   * Get a language code.
   *
   * @param index Index of the language to get the code from
   */
  languageIndex(code) {
    const wasm = this._engine.wasm;
    return wasm._wl_i18n_languageIndex(wasm.tempUTF8(code));
  }
  /**
   * Get a language code.
   *
   * @param index Index of the language to get the code from
   */
  languageCode(index) {
    const wasm = this._engine.wasm;
    const code = wasm._wl_i18n_languageCode(index);
    if (code === 0)
      return null;
    return wasm.UTF8ToString(code);
  }
  /**
   * Get a language name.
   *
   * @param index Index of the language to get the name from
   */
  languageName(index) {
    const wasm = this._engine.wasm;
    const name = wasm._wl_i18n_languageName(index);
    if (name === 0)
      return null;
    return wasm.UTF8ToString(name);
  }
};
var XR = class {
  /** Wonderland WASM bridge. @hidden */
  #wasm;
  #mode;
  constructor(wasm, mode) {
    this.#wasm = wasm;
    this.#mode = mode;
  }
  /** Current WebXR session mode */
  get sessionMode() {
    return this.#mode;
  }
  /** Current WebXR session */
  get session() {
    return this.#wasm.webxr_session;
  }
  /** Current WebXR frame */
  get frame() {
    return this.#wasm.webxr_frame;
  }
  referenceSpaceForType(type) {
    return this.#wasm.webxr_refSpaces[type] ?? null;
  }
  /** Set current reference space type used for retrieving eye, head, hand and joint poses */
  set currentReferenceSpace(refSpace) {
    this.#wasm.webxr_refSpace = refSpace;
    this.#wasm.webxr_refSpaceType = null;
    for (const type of Object.keys(this.#wasm.webxr_refSpaces)) {
      if (this.#wasm.webxr_refSpaces[type] === refSpace) {
        this.#wasm.webxr_refSpaceType = type;
      }
    }
  }
  /** Current reference space type used for retrieving eye, head, hand and joint poses */
  get currentReferenceSpace() {
    return this.#wasm.webxr_refSpace;
  }
  /** Current WebXR reference space type or `null` if not a default reference space */
  get currentReferenceSpaceType() {
    return this.#wasm.webxr_refSpaceType;
  }
  /** Current WebXR base layer  */
  get baseLayer() {
    return this.#wasm.webxr_baseLayer;
  }
  /** Current WebXR framebuffer */
  get framebuffers() {
    if (!Array.isArray(this.#wasm.webxr_fbo)) {
      return [this.#wasm.GL.framebuffers[this.#wasm.webxr_fbo]];
    }
    return this.#wasm.webxr_fbo.map((id) => this.#wasm.GL.framebuffers[id]);
  }
};

// node_modules/@wonderlandengine/api/dist/texture-manager.js
var TextureManager = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Texture cache. @hidden */
  #cache = [];
  /** @hidden */
  constructor(engine2) {
    this._engine = engine2;
  }
  /**
   * Retrieve the texture with the given id.
   *
   * @param id The texture identifier.
   * @return The {@link Texture} if found, `null` otherwise.
   */
  get(id) {
    return this.#cache[id] ?? null;
  }
  /**
   * Load an image from URL as {@link Texture}.
   *
   * @param filename URL to load from.
   * @param crossOrigin Cross origin flag for the image object.
   * @returns Loaded texture.
   */
  load(filename, crossOrigin) {
    let image = new Image();
    image.crossOrigin = crossOrigin ?? image.crossOrigin;
    image.src = filename;
    return new Promise((resolve, reject) => {
      image.onload = () => {
        let texture = new Texture(this._engine, image);
        if (!texture.valid) {
          reject("Failed to add image " + image.src + " to texture atlas. Probably incompatible format.");
        }
        resolve(texture);
      };
      image.onerror = function() {
        reject("Failed to load image. Not found or no read access");
      };
    });
  }
  /**
   * Wrap a texture ID using {@link Texture}.
   *
   * @note This method performs caching and will return the same
   * instance on subsequent calls.
   *
   * @param id ID of the texture to create.
   *
   * @returns The texture.
   */
  wrap(id) {
    const texture = this.#cache[id] ?? (this.#cache[id] = new Texture(this._engine, id));
    texture["_id"] = id;
    return texture;
  }
  /** Number of textures allocated in the manager. */
  get allocatedCount() {
    return this.#cache.length;
  }
  /**
   * Number of textures in the manager.
   *
   * @note For performance reasons, avoid calling this method when possible.
   */
  get count() {
    let count = 0;
    for (const tex of this.#cache) {
      if (tex && tex.id >= 0)
        ++count;
    }
    return count;
  }
  /**
   * Set a new texture in the manager cache.
   *
   * @note This api is meant to be used internally.
   *
   * @param texture The texture to add.
   *
   * @hidden
   */
  _set(texture) {
    this.#cache[texture.id] = texture;
  }
  /**
   * Destroys the texture.
   *
   * @note This api is meant to be used internally.
   *
   * @param texture The texture to destroy.
   *
   * @hidden
   */
  _destroy(texture) {
    this._engine.wasm._wl_texture_destroy(texture.id);
    const img = texture["_imageIndex"];
    if (img !== null) {
      this._engine.wasm._images[img] = null;
    }
  }
  /**
   * Reset the manager.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _reset() {
    this.#cache.length = 0;
  }
};

// node_modules/@wonderlandengine/api/dist/engine.js
var WonderlandEngine = class {
  /**
   * {@link Emitter} for WebXR session end events.
   *
   * Usage from a within a component:
   * ```js
   * this.engine.onXRSessionEnd.add(() => console.log("XR session ended."));
   * ```
   */
  onXRSessionEnd = new Emitter();
  /**
   * {@link Emitter} for WebXR session start events.
   *
   * Usage from a within a component:
   * ```js
   * this.engine.onXRSessionStart.add((session, mode) => console.log(session, mode));
   * ```
   *
   * By default, this emitter is retained and will automatically call any callback added
   * while a session is already started:
   *
   * ```js
   * // XR session is already active.
   * this.engine.onXRSessionStart.add((session, mode) => {
   *     console.log(session, mode); // Triggered immediately.
   * });
   * ```
   */
  onXRSessionStart = new RetainEmitter();
  /**
   * {@link Emitter} for canvas / main framebuffer resize events.
   *
   * Usage from a within a component:
   * ```js
   * this.engine.onResize.add(() => {
   *     const canvas = this.engine.canvas;
   *     console.log(`New Size: ${canvas.width}, ${canvas.height}`);
   * });
   * ```
   *
   * @note The size of the canvas is in physical pixels, and is set via {@link WonderlandEngine.resize}.
   */
  onResize = new Emitter();
  /** Whether AR is supported by the browser. */
  arSupported = false;
  /** Whether VR is supported by the browser. */
  vrSupported = false;
  /**
   * {@link Emitter} for scene loaded events.
   *
   * Listeners get notified when a call to {@link Scene#load()} finishes,
   * which also happens after the main scene has replaced the loading screen.
   *
   * Usage from a within a component:
   * ```js
   * this.engine.onSceneLoaded.add(() => console.log("Scene switched!"));
   * ```
   */
  onSceneLoaded = new Emitter();
  /**
   * Current main scene.
   */
  scene = null;
  /**
   * Access to internationalization.
   */
  i18n = new I18N(this);
  /**
   * WebXR related state, `null` if no XR session is active.
   */
  xr = null;
  /* Component class instances per type to avoid GC */
  _componentCache = {};
  /* Object class instances per type to avoid GC */
  _objectCache = [];
  /**
   * WebAssembly bridge.
   *
   * @hidden
   */
  #wasm;
  /**
   * Physics manager, only available when physx is enabled in the runtime.
   *
   * @hidden
   */
  #physics = null;
  /** Texture manager. @hidden */
  #textures = new TextureManager(this);
  /**
   * Resize observer to track for canvas size changes.
   *
   * @hidden
   */
  #resizeObserver = null;
  /**
   * Create a new engine instance.
   *
   * @param wasm Wasm bridge instance
   * @param loadingScreen Loading screen .bin file data
   *
   * @hidden
   */
  constructor(wasm, loadingScreen) {
    this.#wasm = wasm;
    this.#wasm["_setEngine"](this);
    this.#wasm._loadingScreen = loadingScreen;
    this._componentCache = {};
    this._objectCache.length = 0;
    this.canvas.addEventListener("webglcontextlost", function(e) {
      console.error("Context lost:");
      console.error(e);
    }, false);
  }
  /**
   * Start the engine if it's not already running.
   *
   * When using the {@link loadRuntime} function, this method is called
   * automatically.
   */
  start() {
    this.wasm._wl_application_start();
  }
  /**
   * Register a custom JavaScript component type.
   *
   * You can register a component directly using a class inheriting from {@link Component}:
   *
   * ```js
   * import { Component, Type } from '@wonderlandengine/api';
   *
   * export class MyComponent extends Component {
   *     static TypeName = 'my-component';
   *     static Properties = {
   *         myParam: {type: Type.Float, default: 42.0},
   *     };
   *     init() {}
   *     start() {}
   *     update(dt) {}
   *     onActivate() {}
   *     onDeactivate() {}
   *     onDestroy() {}
   * });
   *
   * // Here, we assume we have an engine already instantiated.
   * // In general, the registration occurs in the `index.js` file in your
   * // final application.
   * engine.registerComponent(MyComponent);
   * ```
   *
   * {@label CLASSES}
   * @param classes Custom component(s) extending {@link Component}.
   *
   * @since 1.0.0
   */
  registerComponent(...classes) {
    for (const arg of classes) {
      this.wasm._registerComponent(arg);
    }
  }
  /**
   * Checks whether the given component is registered or not.
   *
   * @param typeOrClass A string representing the component typename (e.g., `'cursor-component'`),
   *     or a component class (e.g., `CursorComponent`).
   * @returns `true` if the component is registered, `false` otherwise.
   */
  isRegistered(typeOrClass) {
    return this.#wasm.isRegistered(isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName);
  }
  /**
   * Resize the canvas and the rendering context.
   *
   * @note The `width` and `height` parameters will be scaled by the
   * `devicePixelRatio` value. By default, the pixel ratio used is
   * [window.devicePixelRatio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
   *
   * @param width The width, in CSS pixels.
   * @param height The height, in CSS pixels.
   * @param devicePixelRatio The pixel ratio factor.
   */
  resize(width, height, devicePixelRatio = window.devicePixelRatio) {
    width = width * devicePixelRatio;
    height = height * devicePixelRatio;
    this.canvas.width = width;
    this.canvas.height = height;
    this.wasm._wl_application_resize(width, height);
    this.onResize.notify();
  }
  /**
   * Run the next frame.
   *
   * @param fixedDelta The elapsed time between this frame and the previous one.
   *
   * @note The engine automatically schedules next frames. You should only
   * use this method for testing.
   */
  nextFrame(fixedDelta) {
    this.#wasm._wl_nextFrame(fixedDelta);
  }
  /**
   * Request a XR session.
   *
   * @note Please use this call instead of directly calling `navigator.xr.requestSession()`.
   * Wonderland Engine requires to be aware that a session is started, and this
   * is done through this call.
   *
   * @param mode The XR mode.
   * @param features An array of required features, e.g., `['local-floor', 'hit-test']`.
   * @param optionalFeatures An array of optional features, e.g., `['bounded-floor', 'depth-sensing']`.
   * @returns A promise resolving with the `XRSession`, a string error message otherwise.
   */
  requestXRSession(mode, features, optionalFeatures = []) {
    if (!navigator.xr) {
      const isLocalhost = location.hostname === "localhost" || location.hostname === "127.0.0.1";
      const missingHTTPS = location.protocol !== "https:" && !isLocalhost;
      return Promise.reject(missingHTTPS ? "WebXR is only supported with HTTPS or on localhost!" : "WebXR unsupported in this browser.");
    }
    return this.#wasm.webxr_requestSession(mode, features, optionalFeatures);
  }
  /**
   * Wrap an object ID using {@link Object}.
   *
   * @note This method performs caching and will return the same
   * instance on subsequent calls.
   *
   * @param objectId ID of the object to create.
   *
   * @returns The object
   */
  wrapObject(objectId) {
    const cache = this._objectCache;
    const o = cache[objectId] || (cache[objectId] = new Object3D(this, objectId));
    o["_objectId"] = objectId;
    return o;
  }
  /* Public Getters & Setter */
  /**
   * WebAssembly bridge.
   *
   * @note Use with care. This object is used to communicate
   * with the WebAssembly code throughout the api.
   *
   * @hidden
   */
  get wasm() {
    return this.#wasm;
  }
  /** Canvas element that Wonderland Engine renders to. */
  get canvas() {
    return this.#wasm.canvas;
  }
  /**
   * Current WebXR session or `null` if no session active.
   *
   * @deprecated Use {@link XR.session} on the {@link xr}
   * object instead.
   */
  get xrSession() {
    return this.xr?.session ?? null;
  }
  /**
   * Current WebXR frame or `null` if no session active.
   *
   * @deprecated Use {@link XR.frame} on the {@link xr}
   * object instead.
   */
  get xrFrame() {
    return this.xr?.frame ?? null;
  }
  /**
   * Current WebXR base layer or `null` if no session active.
   *
   * @deprecated Use {@link XR.baseLayer} on the {@link xr}
   * object instead.
   */
  get xrBaseLayer() {
    return this.xr?.baseLayer ?? null;
  }
  /**
   * Current WebXR framebuffer or `null` if no session active.
   *
   * @deprecated Use {@link XR.framebuffers} on the
   * {@link xr} object instead.
   */
  get xrFramebuffer() {
    return this.xr?.framebuffers[0] ?? null;
  }
  /** Framebuffer scale factor. */
  get xrFramebufferScaleFactor() {
    return this.#wasm.webxr_framebufferScaleFactor;
  }
  set xrFramebufferScaleFactor(value) {
    this.#wasm.webxr_framebufferScaleFactor = value;
  }
  /** Physics manager, only available when physx is enabled in the runtime. */
  get physics() {
    return this.#physics;
  }
  /**
   * Texture managger.
   *
   * Use this to load or programmatically create new textures at runtime.
   */
  get textures() {
    return this.#textures;
  }
  /*
   * Enable or disable the mechanism to automatically resize the canvas.
   *
   * Internally, the engine uses a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver).
   * Changing the canvas css will thus automatically be tracked by the engine.
   */
  set autoResizeCanvas(flag) {
    const state = !!this.#resizeObserver;
    if (state === flag)
      return;
    if (!flag) {
      this.#resizeObserver?.unobserve(this.canvas);
      this.#resizeObserver = null;
      return;
    }
    this.#resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        if (entry.target === this.canvas) {
          this.resize(entry.contentRect.width, entry.contentRect.height);
        }
      }
    });
    this.#resizeObserver.observe(this.canvas);
  }
  /** `true` if the canvas is automatically resized by the engine. */
  get autoResizeCanvas() {
    return this.#resizeObserver !== null;
  }
  /** Retrieves the runtime version. */
  get runtimeVersion() {
    const wasm = this.#wasm;
    const v = wasm._wl_application_version(wasm._tempMem);
    return {
      major: wasm._tempMemUint16[0],
      minor: wasm._tempMemUint16[1],
      patch: wasm._tempMemUint16[2],
      rc: wasm._tempMemUint16[3]
    };
  }
  /* Internal-Only Methods */
  /**
   * Initialize the engine.
   *
   * @note Should be called after the WebAssembly is fully loaded.
   *
   * @hidden
   */
  _init() {
    this.scene = new Scene(this);
    this.#wasm._wl_set_error_callback(this.#wasm.addFunction((messagePtr) => {
      throw new Error(this.#wasm.UTF8ToString(messagePtr));
    }, "vi"));
    this.#physics = null;
    if (this.#wasm.withPhysX) {
      const physics = new Physics(this);
      this.#wasm._wl_physx_set_collision_callback(this.#wasm.addFunction((a, index, type, b) => {
        const callback = physics._callbacks[a][index];
        const component = new PhysXComponent(this, this.wasm._typeIndexFor("physx"), b);
        callback(type, component);
      }, "viiii"));
      this.#physics = physics;
    }
    this.resize(this.canvas.clientWidth, this.canvas.clientHeight);
  }
  /**
   * Reset the runtime state, including:
   *     - Component cache
   *     - Images
   *     - Callbacks
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _reset() {
    this._componentCache = {};
    this._objectCache.length = 0;
    this.#textures._reset();
    this.scene.reset();
    this.wasm.reset();
  }
  /**
   * Retrieves a component instance if it exists, or create and cache
   * a new one.
   *
   * @note This api is meant to be used internally. Please have a look at
   * {@link Object3D.addComponent} instead.
   *
   * @param type component type name
   * @param componentType Component manager index
   * @param componentId Component id in the manager
   *
   * @returns JavaScript instance wrapping the native component
   *
   * @hidden
   */
  _wrapComponent(type, componentType, componentId) {
    if (componentId < 0)
      return null;
    const c = this._componentCache[componentType] || (this._componentCache[componentType] = []);
    if (c[componentId]) {
      return c[componentId];
    }
    let component;
    if (type == "collision") {
      component = new CollisionComponent(this, componentType, componentId);
    } else if (type == "text") {
      component = new TextComponent(this, componentType, componentId);
    } else if (type == "view") {
      component = new ViewComponent(this, componentType, componentId);
    } else if (type == "mesh") {
      component = new MeshComponent(this, componentType, componentId);
    } else if (type == "input") {
      component = new InputComponent(this, componentType, componentId);
    } else if (type == "light") {
      component = new LightComponent(this, componentType, componentId);
    } else if (type == "animation") {
      component = new AnimationComponent(this, componentType, componentId);
    } else if (type == "physx") {
      component = new PhysXComponent(this, componentType, componentId);
    } else {
      const typeIndex = this.wasm._componentTypeIndices[type];
      const constructor = this.wasm._componentTypes[typeIndex];
      component = new constructor(this);
    }
    component._engine = this;
    component._manager = componentType;
    component._id = componentId;
    c[componentId] = component;
    return component;
  }
};

// node_modules/@wonderlandengine/api/dist/wasm.js
var _componentDefaults = /* @__PURE__ */ new Map([
  [Type.Bool, false],
  [Type.Int, 0],
  [Type.Float, 0],
  [Type.String, ""],
  [Type.Enum, void 0],
  [Type.Object, null],
  [Type.Mesh, null],
  [Type.Texture, null],
  [Type.Material, null],
  [Type.Animation, null],
  [Type.Skin, null],
  [Type.Color, [0, 0, 0, 1]]
]);
function _setupDefaults(ctor) {
  for (const name in ctor.Properties) {
    const p = ctor.Properties[name];
    if (p.type === Type.Enum) {
      if (p.values?.length) {
        if (typeof p.default !== "number") {
          p.default = p.values.indexOf(p.default);
        }
        if (p.default < 0 || p.default >= p.values.length) {
          p.default = 0;
        }
      } else {
        p.default = void 0;
      }
    } else {
      p.default = p.default ?? _componentDefaults.get(p.type);
    }
    ctor.prototype[name] = p.default;
  }
}
var WASM = class {
  /**
   * Emscripten worker field.
   *
   * @note This api is meant to be used internally.
   */
  worker = "";
  /**
   * Emscripten wasm field.
   *
   * @note This api is meant to be used internally.
   */
  wasm = null;
  /**
   * Emscripten canvas.
   *
   * @note This api is meant to be used internally.
   */
  canvas = null;
  /** Current WebXR  */
  /**
   * Emscripten WebXR session.
   *
   * @note This api is meant to be used internally.
   */
  webxr_session = null;
  /**
   * Emscripten WebXR request session callback.
   *
   * @note This api is meant to be used internally.
   */
  webxr_requestSession = null;
  /**
   * Emscripten WebXR frame.
   *
   * @note This api is meant to be used internally.
   */
  webxr_frame = null;
  /**
   * Emscripten current WebXR reference space.
   *
   * @note This api is meant to be used internally.
   */
  webxr_refSpace = null;
  /**
   * Emscripten WebXR reference spaces.
   *
   * @note This api is meant to be used internally.
   */
  webxr_refSpaces = null;
  /**
   * Emscripten WebXR current reference space type.
   *
   * @note This api is meant to be used internally.
   */
  webxr_refSpaceType = null;
  /**
   * Emscripten WebXR GL projection layer.
   *
   * @note This api is meant to be used internally.
   */
  webxr_baseLayer = null;
  /**
   * Emscripten WebXR framebuffer scale factor.
   *
   * @note This api is meant to be used internally.
   */
  webxr_framebufferScaleFactor = 1;
  /**
   * Emscripten WebXR framebuffer(s).
   *
   * @note This api is meant to be used internally.
   */
  /* webxr_fbo will not get overwritten if we are rendering to the
   * default framebuffer, e.g., when using WebXR emulator. */
  webxr_fbo = 0;
  /**
   * Convert a WASM memory view to a JavaScript string.
   *
   * @param ptr Pointer start
   * @param ptrEnd Pointer end
   * @returns JavaScript string
   */
  UTF8ViewToString;
  /** If `true`, logs will not spam the console on error. */
  _deactivate_component_on_error = false;
  /** Temporary memory pointer. */
  _tempMem = null;
  /** Temporary memory size. */
  _tempMemSize = 0;
  /** Temporary float memory view. */
  _tempMemFloat = null;
  /** Temporary int memory view. */
  _tempMemInt = null;
  /** Temporary uint8 memory view. */
  _tempMemUint8 = null;
  /** Temporary uint32 memory view. */
  _tempMemUint32 = null;
  /** Temporary uint16 memory view. */
  _tempMemUint16 = null;
  /** Loading screen .bin file data */
  _loadingScreen = null;
  /** List of callbacks triggered when the scene is loaded. */
  _sceneLoadedCallback = [];
  /**
   * Material definition cache. Each pipeline has its own
   * associated material definition.
   */
  _materialDefinitions = [];
  /** Image cache. */
  _images = [];
  /** Component instances. */
  _components = [];
  /** Component Type info. */
  _componentTypes = [];
  /** Index per component type name. */
  _componentTypeIndices = {};
  /** Wonderland engine instance. */
  _engine = null;
  /**
   * `true` if this runtime is using physx.
   *
   * @note This api is meant to be used internally.
   */
  _withPhysX = false;
  /** Decoder for UTF8 `ArrayBuffer` to JavaScript string. */
  _utf8Decoder = new TextDecoder("utf8");
  /** List of .bin files to delay-load. */
  _queuedBinFiles = [];
  /**
   * Create a new instance of the WebAssembly <> API bridge.
   *
   * @param threads `true` if the runtime used has threads support
   */
  constructor(threads3) {
    if (threads3) {
      this.UTF8ViewToString = (s, e) => {
        if (!s)
          return "";
        return this._utf8Decoder.decode(this.HEAPU8.slice(s, e));
      };
      return;
    }
    this.UTF8ViewToString = (s, e) => {
      if (!s)
        return "";
      return this._utf8Decoder.decode(this.HEAPU8.subarray(s, e));
    };
  }
  /**
   * Reset the cache of the library
   *
   * @note Should only be called when tearing down the runtime.
   */
  reset() {
    this._materialDefinitions = [];
    this._images = [];
    this._components = [];
    this._componentTypes = [];
    this._componentTypeIndices = {};
  }
  /**
   * Checks whether the given component is registered or not.
   *
   * @param ctor  A string representing the component typename (e.g., `'cursor-component'`).
   * @returns `true` if the component is registered, `false` otherwise.
   */
  isRegistered(type) {
    return type in this._componentTypeIndices;
  }
  /**
   * Register a legacy component in this Emscripten instance.
   *
   * @note This api is meant to be used internally.
   *
   * @param typeName The name of the component.
   * @param params An object containing the parameters (properties).
   * @param object The object's prototype.
   * @returns The registration index
   */
  _registerComponentLegacy(typeName, params, object) {
    const ctor = class CustomComponent extends Component {
    };
    ctor.TypeName = typeName;
    ctor.Properties = params;
    Object.assign(ctor.prototype, object);
    return this._registerComponent(ctor);
  }
  /**
   * Register a class component in this Emscripten instance.
   *
   * @note This api is meant to be used internally.
   *
   * @param ctor The class to register.
   * @returns The registration index.
   */
  _registerComponent(ctor) {
    if (!ctor.TypeName)
      throw new Error("no name provided for component.");
    const dependencies = ctor.Dependencies;
    if (dependencies) {
      for (const dependency of dependencies) {
        if (!this.isRegistered(dependency.TypeName)) {
          this._registerComponent(dependency);
        }
      }
    }
    _setupDefaults(ctor);
    const typeIndex = ctor.TypeName in this._componentTypeIndices ? this._componentTypeIndices[ctor.TypeName] : this._componentTypes.length;
    this._componentTypes[typeIndex] = ctor;
    this._componentTypeIndices[ctor.TypeName] = typeIndex;
    console.log("Registered component", ctor.TypeName, `(class ${ctor.name})`, "with index", typeIndex);
    if (ctor.onRegister)
      ctor.onRegister(this._engine);
    return typeIndex;
  }
  /**
   * Allocate the requested amount of temporary memory
   * in this WASM instance.
   *
   * @param size The number of bytes to allocate
   */
  allocateTempMemory(size) {
    console.log("Allocating temp mem:", size);
    this._tempMemSize = size;
    if (this._tempMem)
      this._free(this._tempMem);
    this._tempMem = this._malloc(this._tempMemSize);
    this.updateTempMemory();
  }
  /**
   * @todo: Delete this and only keep `allocateTempMemory`
   *
   * @param size Number of bytes to allocate
   */
  requireTempMem(size) {
    if (this._tempMemSize >= size)
      return;
    this.allocateTempMemory(Math.ceil(size / 1024) * 1024);
  }
  /**
   * Update the temporary memory views. This must be called whenever the
   * temporary memory address changes.
   *
   * @note This api is meant to be used internally.
   */
  updateTempMemory() {
    this._tempMemFloat = new Float32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
    this._tempMemInt = new Int32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
    this._tempMemUint32 = new Uint32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
    this._tempMemUint16 = new Uint16Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 1);
    this._tempMemUint8 = new Uint8Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize);
  }
  /**
   * Returns a uint8 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required
   * @returns A {@link TypedArray} over the WASM memory
   */
  getTempBufferU8(count) {
    this.requireTempMem(count);
    return this._tempMemUint8;
  }
  /**
   * Returns a uint16 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required
   * @returns A {@link TypedArray} over the WASM memory
   */
  getTempBufferU16(count) {
    this.requireTempMem(count * 2);
    return this._tempMemUint16;
  }
  /**
   * Returns a uint32 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required.
   * @returns A {@link TypedArray} over the WASM memory.
   */
  getTempBufferU32(count) {
    this.requireTempMem(count * 4);
    return this._tempMemUint32;
  }
  /**
   * Returns a int32 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required.
   * @returns A {@link TypedArray} over the WASM memory.
   */
  getTempBufferI32(count) {
    this.requireTempMem(count * 4);
    return this._tempMemInt;
  }
  /**
   * Returns a float32 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required.
   * @returns A {@link TypedArray} over the WASM memory.
   */
  getTempBufferF32(count) {
    this.requireTempMem(count * 4);
    return this._tempMemFloat;
  }
  /**
   * Copy the string into temporary WASM memory and retrieve the pointer.
   *
   * @note This method will compute the strlen and append a `\0`.
   *
   * @note The result should be used **directly** otherwise it might get
   * overridden by any next call modifying the temporary memory.
   *
   * @param str The string to write to temporary memory
   * @return The temporary pointer onto the WASM memory
   */
  tempUTF8(str5) {
    const strLen = this.lengthBytesUTF8(str5) + 1;
    this.requireTempMem(strLen);
    this.stringToUTF8(str5, this._tempMem, strLen);
    return this._tempMem;
  }
  /**
   * Return the index of the component type.
   *
   * @note This method uses malloc and copies the string
   * to avoid overwriting caller's temporary data.
   *
   * @param type The type
   * @return The component type index
   */
  _typeIndexFor(type) {
    const lengthBytes = this.lengthBytesUTF8(type) + 1;
    const mem = this._malloc(lengthBytes);
    this.stringToUTF8(type, mem, lengthBytes);
    const componentType = this._wl_get_component_manager_index(mem);
    this._free(mem);
    return componentType;
  }
  /**
   * Return the name of component type stored at the given index.
   *
   * @param typeIndex The type index
   * @return The name as a string
   */
  _typeNameFor(typeIndex) {
    return this.UTF8ToString(this._wl_component_manager_name(typeIndex));
  }
  /**
   * Returns `true` if the runtime supports physx or not.
   */
  get withPhysX() {
    return this._withPhysX;
  }
  /**
   * Set the engine instance holding this bridge.
   *
   * @note This api is meant to be used internally.
   *
   * @param engine The engine instance.
   */
  _setEngine(engine2) {
    this._engine = engine2;
  }
  /* WebAssembly to JS call bridge. */
  _wljs_xr_session_start(mode) {
    this._engine.xr = new XR(this, mode);
    this._engine.onXRSessionStart.notify(this.webxr_session, mode);
  }
  _wljs_xr_session_end() {
    const startEmitter = this._engine.onXRSessionStart;
    if (startEmitter instanceof RetainEmitter)
      startEmitter.reset();
    this._engine.onXRSessionEnd.notify();
    this._engine.xr = null;
  }
  _wljs_xr_disable() {
    this._engine.arSupported = false;
    this._engine.vrSupported = false;
  }
  _wljs_allocate(numComponents) {
    this._components = new Array(numComponents);
  }
  _wljs_init(withPhysX) {
    this._withPhysX = withPhysX;
    this.allocateTempMemory(1024);
  }
  _wljs_reallocate(numComponents) {
    if (numComponents > this._components.length) {
      this._components.length = numComponents;
    }
  }
  _wljs_scene_add_material_definition(definitionId) {
    const definition = /* @__PURE__ */ new Map();
    const nbParams = this._wl_material_definition_get_count(definitionId);
    for (let i = 0; i < nbParams; ++i) {
      const name = this.UTF8ToString(this._wl_material_definition_get_param_name(definitionId, i));
      const t = this._wl_material_definition_get_param_type(definitionId, i);
      definition.set(name, {
        index: i,
        type: {
          type: t & 255,
          componentCount: t >> 8 & 255,
          metaType: t >> 16 & 255
        }
      });
    }
    this._materialDefinitions[definitionId] = definition;
  }
  _wljs_set_component_param_bool(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v !== 0;
  }
  _wljs_set_component_param_int(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v;
  }
  _wljs_set_component_param_float(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v;
  }
  _wljs_set_component_param_string(c, p, pe, v, ve) {
    const param = this.UTF8ViewToString(p, pe);
    const value = this.UTF8ViewToString(v, ve);
    this._components[c][param] = value;
  }
  _wljs_set_component_param_color(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = new Float32Array([0, 8, 16, 24].map((s) => (v >>> s & 255) / 255));
  }
  _wljs_set_component_param_object(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? this._engine.wrapObject(v) : null;
  }
  _wljs_set_component_param_mesh(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Mesh(this._engine, v) : null;
  }
  _wljs_set_component_param_texture(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? this._engine.textures.wrap(v) : null;
  }
  _wljs_set_component_param_material(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Material(this._engine, v) : null;
  }
  _wljs_set_component_param_animation(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Animation(this._engine, v) : null;
  }
  _wljs_set_component_param_skin(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Skin(this._engine, v) : null;
  }
  _wljs_get_component_type_index(namePtr, nameEndPtr) {
    return this._componentTypeIndices[this.UTF8ViewToString(namePtr, nameEndPtr)];
  }
  _wljs_component_create(jsManagerIndex, index, id, type, object) {
    const ctor = this._componentTypes[type];
    const component = new ctor();
    component._engine = this._engine;
    component._manager = jsManagerIndex;
    component._id = id;
    component._object = this._engine.wrapObject(object);
    this._components[index] = component;
    return component;
  }
  _wljs_component_init(component) {
    const c = this._components[component];
    if (c.init) {
      try {
        c.init();
      } catch (e) {
        console.error(`Exception during ${c.type} init() on object ${c.object.name}`);
        console.error(e);
      }
    }
    if (c.start) {
      const oldActivate = c.onActivate;
      c.onActivate = function() {
        try {
          if (this.start)
            this.start();
        } catch (e) {
          console.error(`Exception during ${this.type} start() on object ${this.object.name}`);
          console.error(e);
        }
        this.onActivate = oldActivate;
        if (this.onActivate) {
          try {
            this.onActivate();
          } catch (e) {
            console.error(`Exception during ${this.type} onActivate() on object ${this.object.name}`);
            console.error(e);
          }
        }
      };
    }
  }
  _wljs_component_update(component, dt) {
    const c = this._components[component];
    if (!c) {
      console.warn("WL: component was undefined:", component);
      this._components[component] = new Component(this._engine);
      return;
    }
    if (!c.update)
      return;
    try {
      c.update(dt);
    } catch (e) {
      console.error(`Exception during ${c.type} update() on object ${c.object.name}`);
      console.error(e);
      if (this._deactivate_component_on_error)
        c.active = false;
    }
  }
  _wljs_component_onActivate(component) {
    const c = this._components[component];
    if (!c || !c.onActivate)
      return;
    try {
      c.onActivate();
    } catch (e) {
      console.error(`Exception during ${c.type} onActivate() on object ${c.object.name}`);
      console.error(e);
    }
  }
  _wljs_component_onDeactivate(component) {
    const c = this._components[component];
    if (!c.onDeactivate)
      return;
    try {
      c.onDeactivate();
    } catch (e) {
      console.error(`Exception during ${c.type} onDeactivate() on object ${c.object.name}`);
      console.error(e);
    }
  }
  _wljs_component_onDestroy(component) {
    const c = this._components[component];
    if (!c.onDestroy)
      return;
    try {
      c.onDestroy();
    } catch (e) {
      console.error(`Exception during ${c.type} onDestroy() on object ${c.object.name}`);
      console.error(e);
    }
  }
  _wljs_swap(a, b) {
    const componentA = this._components[a];
    this._components[a] = this._components[b];
    this._components[b] = componentA;
  }
  /* JS to WebAssembly bridge. */
  HEAP8 = null;
  HEAPU8 = null;
  HEAPU16 = null;
  HEAPU32 = null;
  HEAP32 = null;
  HEAPF32 = null;
  GL = null;
  assert = null;
  _free = null;
  _malloc = null;
  lengthBytesUTF8 = null;
  stringToUTF8 = null;
  UTF8ToString = null;
  addFunction = null;
  removeFunction = null;
  _wl_set_error_callback = null;
  _wl_application_version = null;
  _wl_application_start = null;
  _wl_application_resize = null;
  _wl_nextUpdate = null;
  _wl_nextFrame = null;
  _wl_scene_get_active_views = null;
  _wl_scene_ray_cast = null;
  _wl_scene_add_object = null;
  _wl_scene_add_objects = null;
  _wl_scene_reserve_objects = null;
  _wl_scene_set_clearColor = null;
  _wl_scene_enableColorClear = null;
  _wl_set_loading_screen_progress = null;
  _wl_load_scene_bin = null;
  _wl_append_scene_bin = null;
  _wl_append_scene_gltf = null;
  _wl_scene_reset = null;
  _wl_component_get_object = null;
  _wl_component_setActive = null;
  _wl_component_isActive = null;
  _wl_component_remove = null;
  _wl_collision_component_get_collider = null;
  _wl_collision_component_set_collider = null;
  _wl_collision_component_get_extents = null;
  _wl_collision_component_get_group = null;
  _wl_collision_component_set_group = null;
  _wl_collision_component_query_overlaps = null;
  _wl_text_component_get_horizontal_alignment = null;
  _wl_text_component_set_horizontal_alignment = null;
  _wl_text_component_get_vertical_alignment = null;
  _wl_text_component_set_vertical_alignment = null;
  _wl_text_component_get_character_spacing = null;
  _wl_text_component_set_character_spacing = null;
  _wl_text_component_get_line_spacing = null;
  _wl_text_component_set_line_spacing = null;
  _wl_text_component_get_effect = null;
  _wl_text_component_set_effect = null;
  _wl_text_component_get_text = null;
  _wl_text_component_set_text = null;
  _wl_text_component_set_material = null;
  _wl_text_component_get_material = null;
  _wl_view_component_get_projection_matrix = null;
  _wl_view_component_get_near = null;
  _wl_view_component_set_near = null;
  _wl_view_component_get_far = null;
  _wl_view_component_set_far = null;
  _wl_view_component_get_fov = null;
  _wl_view_component_set_fov = null;
  _wl_input_component_get_type = null;
  _wl_input_component_set_type = null;
  _wl_light_component_get_color = null;
  _wl_light_component_get_type = null;
  _wl_light_component_set_type = null;
  _wl_light_component_get_intensity = null;
  _wl_light_component_set_intensity = null;
  _wl_light_component_get_outerAngle = null;
  _wl_light_component_set_outerAngle = null;
  _wl_light_component_get_innerAngle = null;
  _wl_light_component_set_innerAngle = null;
  _wl_light_component_get_shadows = null;
  _wl_light_component_set_shadows = null;
  _wl_light_component_get_shadowRange = null;
  _wl_light_component_set_shadowRange = null;
  _wl_light_component_get_shadowBias = null;
  _wl_light_component_set_shadowBias = null;
  _wl_light_component_get_shadowNormalBias = null;
  _wl_light_component_set_shadowNormalBias = null;
  _wl_light_component_get_shadowTexelSize = null;
  _wl_light_component_set_shadowTexelSize = null;
  _wl_light_component_get_cascadeCount = null;
  _wl_light_component_set_cascadeCount = null;
  _wl_animation_component_get_animation = null;
  _wl_animation_component_set_animation = null;
  _wl_animation_component_get_playCount = null;
  _wl_animation_component_set_playCount = null;
  _wl_animation_component_get_speed = null;
  _wl_animation_component_set_speed = null;
  _wl_animation_component_play = null;
  _wl_animation_component_stop = null;
  _wl_animation_component_pause = null;
  _wl_animation_component_state = null;
  _wl_mesh_component_get_material = null;
  _wl_mesh_component_set_material = null;
  _wl_mesh_component_get_mesh = null;
  _wl_mesh_component_set_mesh = null;
  _wl_mesh_component_get_skin = null;
  _wl_mesh_component_set_skin = null;
  _wl_physx_component_get_static = null;
  _wl_physx_component_set_static = null;
  _wl_physx_component_get_kinematic = null;
  _wl_physx_component_set_kinematic = null;
  _wl_physx_component_get_gravity = null;
  _wl_physx_component_set_gravity = null;
  _wl_physx_component_get_simulate = null;
  _wl_physx_component_set_simulate = null;
  _wl_physx_component_get_allowSimulation = null;
  _wl_physx_component_set_allowSimulation = null;
  _wl_physx_component_get_allowQuery = null;
  _wl_physx_component_set_allowQuery = null;
  _wl_physx_component_get_trigger = null;
  _wl_physx_component_set_trigger = null;
  _wl_physx_component_get_shape = null;
  _wl_physx_component_set_shape = null;
  _wl_physx_component_get_shape_data = null;
  _wl_physx_component_set_shape_data = null;
  _wl_physx_component_get_extents = null;
  _wl_physx_component_get_staticFriction = null;
  _wl_physx_component_set_staticFriction = null;
  _wl_physx_component_get_dynamicFriction = null;
  _wl_physx_component_set_dynamicFriction = null;
  _wl_physx_component_get_bounciness = null;
  _wl_physx_component_set_bounciness = null;
  _wl_physx_component_get_linearDamping = null;
  _wl_physx_component_set_linearDamping = null;
  _wl_physx_component_get_angularDamping = null;
  _wl_physx_component_set_angularDamping = null;
  _wl_physx_component_get_linearVelocity = null;
  _wl_physx_component_set_linearVelocity = null;
  _wl_physx_component_get_angularVelocity = null;
  _wl_physx_component_set_angularVelocity = null;
  _wl_physx_component_get_groupsMask = null;
  _wl_physx_component_set_groupsMask = null;
  _wl_physx_component_get_blocksMask = null;
  _wl_physx_component_set_blocksMask = null;
  _wl_physx_component_get_linearLockAxis = null;
  _wl_physx_component_set_linearLockAxis = null;
  _wl_physx_component_get_angularLockAxis = null;
  _wl_physx_component_set_angularLockAxis = null;
  _wl_physx_component_get_mass = null;
  _wl_physx_component_set_mass = null;
  _wl_physx_component_set_massSpaceInertiaTensor = null;
  _wl_physx_component_addForce = null;
  _wl_physx_component_addForceAt = null;
  _wl_physx_component_addTorque = null;
  _wl_physx_component_addCallback = null;
  _wl_physx_component_removeCallback = null;
  _wl_physx_update_global_pose = null;
  _wl_physx_ray_cast = null;
  _wl_physx_set_collision_callback = null;
  _wl_mesh_create = null;
  _wl_mesh_get_vertexData = null;
  _wl_mesh_get_vertexCount = null;
  _wl_mesh_get_indexData = null;
  _wl_mesh_update = null;
  _wl_mesh_get_boundingSphere = null;
  _wl_mesh_get_attribute = null;
  _wl_mesh_destroy = null;
  _wl_mesh_get_attribute_values = null;
  _wl_mesh_set_attribute_values = null;
  _wl_material_create = null;
  _wl_material_get_definition = null;
  _wl_material_definition_get_count = null;
  _wl_material_definition_get_param_name = null;
  _wl_material_definition_get_param_type = null;
  _wl_material_get_pipeline = null;
  _wl_material_clone = null;
  _wl_material_get_param_index = null;
  _wl_material_get_param_type = null;
  _wl_material_get_param_value = null;
  _wl_material_set_param_value_uint = null;
  _wl_material_set_param_value_float = null;
  _wl_renderer_addImage = null;
  _wl_texture_width = null;
  _wl_texture_height = null;
  _wl_renderer_updateImage = null;
  _wl_texture_destroy = null;
  _wl_animation_get_duration = null;
  _wl_animation_get_trackCount = null;
  _wl_animation_retargetToSkin = null;
  _wl_animation_retarget = null;
  _wl_object_name = null;
  _wl_object_set_name = null;
  _wl_object_parent = null;
  _wl_object_get_children_count = null;
  _wl_object_get_children = null;
  _wl_object_set_parent = null;
  _wl_object_reset_scaling = null;
  _wl_object_reset_translation_rotation = null;
  _wl_object_reset_rotation = null;
  _wl_object_reset_translation = null;
  _wl_object_translate = null;
  _wl_object_translate_obj = null;
  _wl_object_translate_world = null;
  _wl_object_rotate_axis_angle = null;
  _wl_object_rotate_axis_angle_rad = null;
  _wl_object_rotate_axis_angle_obj = null;
  _wl_object_rotate_axis_angle_rad_obj = null;
  _wl_object_rotate_quat = null;
  _wl_object_rotate_quat_obj = null;
  _wl_object_scale = null;
  _wl_object_trans_local = null;
  _wl_object_get_translation_local = null;
  _wl_object_set_translation_local = null;
  _wl_object_get_translation_world = null;
  _wl_object_set_translation_world = null;
  _wl_object_trans_world = null;
  _wl_object_trans_world_to_local = null;
  _wl_object_scaling_local = null;
  _wl_object_scaling_world = null;
  _wl_object_set_scaling_local = null;
  _wl_object_set_scaling_world = null;
  _wl_object_scaling_world_to_local = null;
  _wl_object_set_rotation_local = null;
  _wl_object_set_rotation_world = null;
  _wl_object_transformVectorWorld = null;
  _wl_object_transformVectorLocal = null;
  _wl_object_transformPointWorld = null;
  _wl_object_transformPointLocal = null;
  _wl_object_transformVectorInverseWorld = null;
  _wl_object_transformVectorInverseLocal = null;
  _wl_object_transformPointInverseWorld = null;
  _wl_object_transformPointInverseLocal = null;
  _wl_object_toWorldSpaceTransform = null;
  _wl_object_toObjectSpaceTransform = null;
  _wl_object_lookAt = null;
  _wl_scene_remove_object = null;
  _wl_object_set_dirty = null;
  _wl_get_component_manager_index = null;
  _wl_get_js_component_index = null;
  _wl_get_js_component_index_for_id = null;
  _wl_get_component_id = null;
  _wl_object_get_components = null;
  _wl_object_get_component_types = null;
  _wl_object_add_js_component = null;
  _wl_object_add_component = null;
  _wl_object_is_changed = null;
  _wl_component_manager_name = null;
  _wl_skin_get_joint_count = null;
  _wl_skin_joint_ids = null;
  _wl_skin_inverse_bind_transforms = null;
  _wl_skin_inverse_bind_scalings = null;
  _wl_math_cubicHermite = null;
  _wl_i18n_setLanguage = null;
  _wl_i18n_currentLanguage = null;
  _wl_i18n_translate = null;
  _wl_i18n_languageCount = null;
  _wl_i18n_languageIndex = null;
  _wl_i18n_languageCode = null;
  _wl_i18n_languageName = null;
};

// node_modules/@wonderlandengine/api/dist/version.js
var APIVersion = {
  major: 1,
  minor: 0,
  patch: 0,
  rc: 0
};

// node_modules/@wonderlandengine/api/dist/index.js
function loadScript(scriptURL) {
  return new Promise((res, rej) => {
    const s = document.createElement("script");
    const node = document.body.appendChild(s);
    s.onload = () => {
      document.body.removeChild(node);
      res();
    };
    s.onerror = (e) => {
      document.body.removeChild(node);
      rej(e);
    };
    s.src = scriptURL;
  });
}
async function detectFeatures() {
  let [simdSupported, threadsSupported] = await Promise.all([simd(), threads()]);
  if (simdSupported) {
    console.log("WASM SIMD is supported");
  } else {
    console.warn("WASM SIMD is not supported");
  }
  if (threadsSupported) {
    if (self.crossOriginIsolated) {
      console.log("WASM Threads is supported");
    } else {
      console.warn("WASM Threads is supported, but the page is not crossOriginIsolated, therefore thread support is disabled.");
    }
  } else {
    console.warn("WASM Threads is not supported");
  }
  threadsSupported = threadsSupported && self.crossOriginIsolated;
  return {
    simdSupported,
    threadsSupported
  };
}
var xrSupported = {
  ar: null,
  vr: null
};
function checkXRSupport() {
  if (typeof navigator === "undefined" || !navigator.xr) {
    xrSupported.vr = false;
    xrSupported.ar = false;
    return Promise.resolve(xrSupported);
  }
  const vrPromise = xrSupported.vr !== null ? Promise.resolve() : navigator.xr.isSessionSupported("immersive-vr").then((supported) => xrSupported.vr = supported);
  const arPromise = xrSupported.ar !== null ? Promise.resolve() : navigator.xr.isSessionSupported("immersive-ar").then((supported) => xrSupported.ar = supported);
  return Promise.all([vrPromise, arPromise]).then(() => xrSupported);
}
function checkRuntimeCompatibility(version) {
  const { major, minor } = version;
  let majorDiff = major - APIVersion.major;
  let minorDiff = minor - APIVersion.minor;
  if (!majorDiff && !minorDiff)
    return;
  const error = "checkRuntimeCompatibility(): Version compatibility mismatch:\n	\u2192 API and runtime compatibility is enforced on a patch level (versions x.y.*)\n";
  const isRuntimeOlder = majorDiff < 0 || !majorDiff && minorDiff < 0;
  if (isRuntimeOlder) {
    throw new Error(`${error}	\u2192 Please use a Wonderland Engine editor version >= ${APIVersion.major}.${APIVersion.minor}.*`);
  }
  throw new Error(`${error}	\u2192 Please use a new API version >= ${version.major}.${version.minor}.*`);
}
async function loadRuntime(runtime, options = {}) {
  const xrPromise = checkXRSupport();
  const { simdSupported, threadsSupported } = await detectFeatures();
  const { simd: simd3 = simdSupported, threads: threads3 = threadsSupported, physx = false, loader = false, xrFramebufferScaleFactor = 1, loadingScreen = "WonderlandRuntime-LoadingScreen.bin", canvas: canvas2 = "canvas" } = options;
  const variant = [];
  if (loader)
    variant.push("loader");
  if (physx)
    variant.push("physx");
  if (simd3)
    variant.push("simd");
  if (threads3)
    variant.push("threads");
  const variantStr = variant.join("-");
  let filename = runtime;
  if (variantStr)
    filename = `${filename}-${variantStr}`;
  const download = function(filename2, errorMessage) {
    return fetch(filename2).then((r) => {
      if (!r.ok)
        return Promise.reject(errorMessage);
      return r.arrayBuffer();
    }).catch((_) => Promise.reject(errorMessage));
  };
  const [wasmData, loadingScreenData] = await Promise.all([
    download(`${filename}.wasm`, "Failed to fetch runtime .wasm file"),
    download(loadingScreen, "Failed to fetch loading screen file").catch((_) => null)
  ]);
  const glCanvas = document.getElementById(canvas2);
  if (!glCanvas) {
    throw new Error(`loadRuntime(): Failed to find canvas with id '${canvas2}'`);
  }
  if (!(glCanvas instanceof HTMLCanvasElement)) {
    throw new Error(`loadRuntime(): HTML element '${canvas2}' must be a canvas`);
  }
  const wasm = new WASM(threads3);
  wasm.worker = `${filename}.worker.js`;
  wasm.wasm = wasmData;
  wasm.canvas = glCanvas;
  const engine2 = new WonderlandEngine(wasm, loadingScreenData);
  if (!window._WL) {
    window._WL = { runtimes: {} };
  }
  const runtimes = window._WL.runtimes;
  const runtimeGlobalId = variantStr ? variantStr : "default";
  if (!runtimes[runtimeGlobalId]) {
    await loadScript(`${filename}.js`);
    runtimes[runtimeGlobalId] = window.instantiateWonderlandRuntime;
    window.instantiateWonderlandRuntime = void 0;
  }
  await runtimes[runtimeGlobalId](wasm);
  checkRuntimeCompatibility(engine2.runtimeVersion);
  engine2._init();
  const xr = await xrPromise;
  engine2.arSupported = xr.ar;
  engine2.vrSupported = xr.vr;
  engine2.xrFramebufferScaleFactor = xrFramebufferScaleFactor;
  engine2.autoResizeCanvas = true;
  engine2.start();
  return engine2;
}

// node_modules/@wonderlandengine/components/dist/8thwall-camera.js
var ARCamera8thwall = class extends Component {
  /* 8thwall camera pipeline module name */
  name = "wonderland-engine-8thwall-camera";
  started = false;
  view = null;
  // cache camera
  position = [0, 0, 0];
  // cache 8thwall cam position
  rotation = [0, 0, 0, -1];
  // cache 8thwall cam rotation
  glTextureRenderer = null;
  // cache XR8.GlTextureRenderer.pipelineModule
  promptForDeviceMotion() {
    return new Promise(async (resolve, reject) => {
      window.dispatchEvent(new Event("8thwall-request-user-interaction"));
      window.addEventListener("8thwall-safe-to-request-permissions", async () => {
        try {
          const motionEvent = await DeviceMotionEvent.requestPermission();
          resolve(motionEvent);
        } catch (exception) {
          reject(exception);
        }
      });
    });
  }
  async getPermissions() {
    if (DeviceMotionEvent && DeviceMotionEvent.requestPermission) {
      try {
        const result = await DeviceMotionEvent.requestPermission();
        if (result !== "granted") {
          throw new Error("MotionEvent");
        }
      } catch (exception) {
        if (exception.name === "NotAllowedError") {
          const motionEvent = await this.promptForDeviceMotion();
          if (motionEvent !== "granted") {
            throw new Error("MotionEvent");
          }
        } else {
          throw new Error("MotionEvent");
        }
      }
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
      stream.getTracks().forEach((track) => {
        track.stop();
      });
    } catch (exception) {
      throw new Error("Camera");
    }
  }
  init() {
    this.view = this.object.getComponent("view");
    this.onUpdate = this.onUpdate.bind(this);
    this.onAttach = this.onAttach.bind(this);
    this.onException = this.onException.bind(this);
    this.onCameraStatusChange = this.onCameraStatusChange.bind(this);
  }
  async start() {
    this.view = this.object.getComponent("view");
    if (!this.useCustomUIOverlays) {
      OverlaysHandler.init();
    }
    try {
      await this.getPermissions();
    } catch (error) {
      window.dispatchEvent(new CustomEvent("8thwall-permission-fail", { detail: error }));
      return;
    }
    await this.waitForXR8();
    XR8.XrController.configure({
      disableWorldTracking: false
    });
    this.glTextureRenderer = XR8.GlTextureRenderer.pipelineModule();
    XR8.addCameraPipelineModules([
      this.glTextureRenderer,
      XR8.XrController.pipelineModule(),
      this
    ]);
    const config = {
      cameraConfig: {
        direction: XR8.XrConfig.camera().BACK
      },
      canvas: Module.canvas,
      allowedDevices: XR8.XrConfig.device().ANY,
      ownRunLoop: false
    };
    XR8.run(config);
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onAttach(params) {
    this.started = true;
    this.engine.scene.colorClearEnabled = false;
    const gl = Module.ctx;
    const rot = this.object.rotationWorld;
    const pos = this.object.getTranslationWorld([]);
    this.position = Array.from(pos);
    this.rotation = Array.from(rot);
    XR8.XrController.updateCameraProjectionMatrix({
      origin: { x: pos[0], y: pos[1], z: pos[2] },
      facing: { x: rot[0], y: rot[1], z: rot[2], w: rot[3] },
      cam: {
        pixelRectWidth: Module.canvas.width,
        pixelRectHeight: Module.canvas.height,
        nearClipPlane: this.view.near,
        farClipPlane: this.view.far
      }
    });
    this.engine.scene.onPreRender.push(() => {
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      XR8.runPreRender(Date.now());
      XR8.runRender();
    });
    this.engine.scene.onPostRender.push(() => {
      XR8.runPostRender(Date.now());
    });
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onCameraStatusChange(e) {
    if (e && e.status === "failed") {
      this.onException(new Error(`Camera failed with status: ${e.status}`));
    }
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onUpdate(e) {
    if (!e.processCpuResult.reality)
      return;
    const { rotation, position, intrinsics } = e.processCpuResult.reality;
    this.rotation[0] = rotation.x;
    this.rotation[1] = rotation.y;
    this.rotation[2] = rotation.z;
    this.rotation[3] = rotation.w;
    this.position[0] = position.x;
    this.position[1] = position.y;
    this.position[2] = position.z;
    if (intrinsics) {
      const projectionMatrix = this.view.projectionMatrix;
      for (let i = 0; i < 16; i++) {
        if (Number.isFinite(intrinsics[i])) {
          projectionMatrix[i] = intrinsics[i];
        }
      }
    }
    if (position && rotation) {
      this.object.rotationWorld = this.rotation;
      this.object.setTranslationWorld(this.position);
    }
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onException(error) {
    console.error("8thwall exception:", error);
    window.dispatchEvent(new CustomEvent("8thwall-error", { detail: error }));
  }
  waitForXR8() {
    return new Promise((resolve, _rej) => {
      if (window.XR8) {
        resolve();
      } else {
        window.addEventListener("xrloaded", () => resolve());
      }
    });
  }
};
__publicField(ARCamera8thwall, "TypeName", "8thwall-camera");
__publicField(ARCamera8thwall, "Properties", {
  /** Override the WL html overlays for handling camera/motion permissions and error handling */
  useCustomUIOverlays: { type: Type.Bool, default: false }
});
var OverlaysHandler = {
  init: function() {
    this.handleRequestUserInteraction = this.handleRequestUserInteraction.bind(this);
    this.handlePermissionFail = this.handlePermissionFail.bind(this);
    this.handleError = this.handleError.bind(this);
    window.addEventListener("8thwall-request-user-interaction", this.handleRequestUserInteraction);
    window.addEventListener("8thwall-permission-fail", this.handlePermissionFail);
    window.addEventListener("8thwall-error", this.handleError);
  },
  handleRequestUserInteraction: function() {
    const overlay = this.showOverlay(requestPermissionOverlay);
    window.addEventListener("8thwall-safe-to-request-permissions", () => {
      overlay.remove();
    });
  },
  handlePermissionFail: function(_reason) {
    this.showOverlay(failedPermissionOverlay);
  },
  handleError: function(_error) {
    this.showOverlay(runtimeErrorOverlay);
  },
  showOverlay: function(htmlContent) {
    const overlay = document.createElement("div");
    overlay.innerHTML = htmlContent;
    document.body.appendChild(overlay);
    return overlay;
  }
};
var requestPermissionOverlay = `
<style>
  #request-permission-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 999;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
    font-family: sans-serif;
  }

  .request-permission-overlay_title {
    margin: 30px;
    font-size: 32px;
  }

  .request-permission-overlay_button {
    background-color: #e80086;
    font-size: 22px;
    padding: 10px 30px;
    color: #fff;
    border-radius: 15px;
    border: none;
  }
</style>

<div id="request-permission-overlay">
  <div class="request-permission-overlay_title">This app requires to use your camera and motion sensors</div>

  <button class="request-permission-overlay_button" onclick="window.dispatchEvent(new Event('8thwall-safe-to-request-permissions'))">OK</button>
</div>`;
var failedPermissionOverlay = `
<style>
  #failed-permission-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 999;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
    font-family: sans-serif;
  }

  .failed-permission-overlay_title {
    margin: 30px;
    font-size: 32px;
  }

  .failed-permission-overlay_button {
    background-color: #e80086;
    font-size: 22px;
    padding: 10px 30px;
    color: #fff;
    border-radius: 15px;
    border: none;
  }
</style>

<div id="failed-permission-overlay">
  <div class="failed-permission-overlay_title">Failed to grant permissions. Reset the the permissions and refresh the page.</div>

  <button class="failed-permission-overlay_button" onclick="window.location.reload()">Refresh the page</button>
</div>`;
var runtimeErrorOverlay = `
<style>
  #wall-error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 999;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
    font-family: sans-serif;
  }

  .wall-error-overlay_title {
    margin: 30px;
    font-size: 32px;
  }

  .wall-error-overlay_button {
    background-color: #e80086;
    font-size: 22px;
    padding: 10px 30px;
    color: #fff;
    border-radius: 15px;
    border: none;
  }
</style>

<div id="wall-error-overlay">
  <div class="wall-error-overlay_title">Error has occurred. Please reload the page</div>

  <button class="wall-error-overlay_button" onclick="window.location.reload()">Reload</button>
</div>`;

// node_modules/@wonderlandengine/components/dist/utils/webxr.js
var tempVec = new Float32Array(3);
var tempQuat = new Float32Array(4);
function setXRRigidTransformLocal(o, transform) {
  const r = transform.orientation;
  tempQuat[0] = r.x;
  tempQuat[1] = r.y;
  tempQuat[2] = r.z;
  tempQuat[3] = r.w;
  const t = transform.position;
  tempVec[0] = t.x;
  tempVec[1] = t.y;
  tempVec[2] = t.z;
  o.resetTranslationRotation();
  o.transformLocal.set(tempQuat);
  o.translate(tempVec);
}

// node_modules/@wonderlandengine/components/dist/anchor.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tempVec3 = new Float32Array(3);
var tempQuat2 = new Float32Array(4);
var _anchors, _addAnchor, addAnchor_fn, _removeAnchor, removeAnchor_fn, _getFrame, getFrame_fn, _createAnchor, createAnchor_fn, _onAddAnchor, onAddAnchor_fn, _onRestoreAnchor, onRestoreAnchor_fn, _onCreate, onCreate_fn;
var _Anchor = class extends Component {
  constructor() {
    super(...arguments);
    __privateAdd(this, _getFrame);
    __privateAdd(this, _createAnchor);
    __privateAdd(this, _onAddAnchor);
    __privateAdd(this, _onRestoreAnchor);
    __privateAdd(this, _onCreate);
    __publicField(this, "persist", false);
    /** Unique identifier to load a persistent anchor from, or empty/null if unknown */
    __publicField(this, "uuid", null);
    /** The xrAnchor, if created */
    __publicField(this, "xrAnchor", null);
    /** Emits events when the anchor is created either by being restored or newly created */
    __publicField(this, "onCreate", new Emitter());
    /** Whether the anchor is currently being tracked */
    __publicField(this, "visible", false);
    /** Emits an event when this anchor starts tracking */
    __publicField(this, "onTrackingFound", new Emitter());
    /** Emits an event when this anchor stops tracking */
    __publicField(this, "onTrackingLost", new Emitter());
    /** XRFrame to use for creating the anchor */
    __publicField(this, "xrFrame", null);
    /** XRHitTestResult to use for creating the anchor */
    __publicField(this, "xrHitResult", null);
  }
  /** Retrieve all anchors of the current scene */
  static getAllAnchors() {
    return __privateGet(_Anchor, _anchors);
  }
  /**
   * Create a new anchor
   *
   * @param o Object to attach the component to
   * @param params Parameters for the anchor component
   * @param frame XRFrame to use for anchor cration, if null, will use the current frame if available
   * @param hitResult Optional hit-test result to create the anchor with
   * @returns Promise for the newly created anchor component
   */
  static create(o, params, frame, hitResult) {
    const a = o.addComponent(_Anchor, { ...params, active: false });
    if (a === null)
      return null;
    a.xrHitResult = hitResult ?? null;
    a.xrFrame = frame ?? null;
    a.onCreate.once(() => (a.xrFrame = null, a.xrHitResult = null));
    a.active = true;
    return a.onCreate.promise();
  }
  start() {
    if (this.uuid && this.engine.xr) {
      this.persist = true;
      if (this.engine.xr.session.restorePersistentAnchor === void 0) {
        console.warn("anchor: Persistent anchors are not supported by your client. Ignoring persist property.");
      }
      this.engine.xr.session.restorePersistentAnchor(this.uuid).then(__privateMethod(this, _onRestoreAnchor, onRestoreAnchor_fn).bind(this));
    } else if (__privateMethod(this, _getFrame, getFrame_fn).call(this)) {
      __privateMethod(this, _createAnchor, createAnchor_fn).call(this).then(__privateMethod(this, _onAddAnchor, onAddAnchor_fn).bind(this));
    } else {
      throw new Error("Anchors can only be created during the XR frame in an active XR session");
    }
  }
  update() {
    if (!this.xrAnchor || !this.engine.xr)
      return;
    const pose = this.engine.xr.frame.getPose(this.xrAnchor.anchorSpace, this.engine.xr.currentReferenceSpace);
    const visible = !!pose;
    if (visible != this.visible) {
      this.visible = visible;
      (visible ? this.onTrackingFound : this.onTrackingLost).notify(this);
    }
    if (pose) {
      setXRRigidTransformLocal(this.object, pose.transform);
    }
  }
  onDestroy() {
    var _a;
    __privateMethod(_a = _Anchor, _removeAnchor, removeAnchor_fn).call(_a, this);
  }
};
var Anchor = _Anchor;
_anchors = new WeakMap();
_addAnchor = new WeakSet();
addAnchor_fn = function(anchor) {
  __privateGet(_Anchor, _anchors).push(anchor);
};
_removeAnchor = new WeakSet();
removeAnchor_fn = function(anchor) {
  const index = __privateGet(_Anchor, _anchors).indexOf(anchor);
  if (index < 0)
    return;
  __privateGet(_Anchor, _anchors).splice(index, 1);
};
_getFrame = new WeakSet();
getFrame_fn = function() {
  return this.xrFrame || this.engine.xr.frame;
};
_createAnchor = new WeakSet();
createAnchor_fn = async function() {
  if (!__privateMethod(this, _getFrame, getFrame_fn).call(this).createAnchor) {
    throw new Error("Cannot create anchor - anchors not supported, did you enable the 'anchors' WebXR feature?");
  }
  if (this.xrHitResult) {
    if (this.xrHitResult.createAnchor === void 0) {
      throw new Error("Requested anchor on XRHitTestResult, but WebXR hit-test feature is not available.");
    }
    return this.xrHitResult.createAnchor();
  } else {
    this.object.getTranslationWorld(tempVec3);
    tempQuat2.set(this.object.rotationWorld);
    const rotation = tempQuat2;
    const anchorPose = new XRRigidTransform({ x: tempVec3[0], y: tempVec3[1], z: tempVec3[2] }, { x: rotation[0], y: rotation[1], z: rotation[2], w: rotation[3] });
    return __privateMethod(this, _getFrame, getFrame_fn).call(this)?.createAnchor(anchorPose, this.engine.xr.currentReferenceSpace);
  }
};
_onAddAnchor = new WeakSet();
onAddAnchor_fn = function(anchor) {
  if (!anchor)
    return;
  if (this.persist) {
    if (anchor.requestPersistentHandle !== void 0) {
      anchor.requestPersistentHandle().then((uuid) => {
        var _a;
        this.uuid = uuid;
        __privateMethod(this, _onCreate, onCreate_fn).call(this, anchor);
        __privateMethod(_a = _Anchor, _addAnchor, addAnchor_fn).call(_a, this);
      });
      return;
    } else {
      console.warn("anchor: Persistent anchors are not supported by your client. Ignoring persist property.");
    }
  }
  __privateMethod(this, _onCreate, onCreate_fn).call(this, anchor);
};
_onRestoreAnchor = new WeakSet();
onRestoreAnchor_fn = function(anchor) {
  __privateMethod(this, _onCreate, onCreate_fn).call(this, anchor);
};
_onCreate = new WeakSet();
onCreate_fn = function(anchor) {
  this.xrAnchor = anchor;
  this.onCreate.notify(this);
};
__privateAdd(Anchor, _addAnchor);
__privateAdd(Anchor, _removeAnchor);
__publicField(Anchor, "TypeName", "anchor");
/* Static management of all anchors */
__privateAdd(Anchor, _anchors, []);
__decorate2([
  property.bool(false)
], Anchor.prototype, "persist", void 0);
__decorate2([
  property.string()
], Anchor.prototype, "uuid", void 0);

// node_modules/@wonderlandengine/components/dist/cursor-target.js
var CursorTarget = class extends Component {
  /** Emitter for events when the target is hovered */
  onHover = new Emitter();
  /** Emitter for events when the target is unhovered */
  onUnhover = new Emitter();
  /** Emitter for events when the target is clicked */
  onClick = new Emitter();
  /** Emitter for events when the cursor moves on the target */
  onMove = new Emitter();
  /** Emitter for events when the user pressed the select button on the target */
  onDown = new Emitter();
  /** Emitter for events when the user unpressed the select button on the target */
  onUp = new Emitter();
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onHover.add(f);
   */
  addHoverFunction(f) {
    this.onHover.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onHover.remove(f);
   */
  removeHoverFunction(f) {
    this.onHover.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onUnhover.add(f);
   */
  addUnHoverFunction(f) {
    this.onUnhover.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onUnhover.remove(f);
   */
  removeUnHoverFunction(f) {
    this.onUnhover.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onClick.add(f);
   */
  addClickFunction(f) {
    this.onClick.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onClick.remove(f);
   */
  removeClickFunction(f) {
    this.onClick.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onMove.add(f);
   */
  addMoveFunction(f) {
    this.onMove.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onMove.remove(f);
   */
  removeMoveFunction(f) {
    this.onMove.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onDown.add(f);
   */
  addDownFunction(f) {
    this.onDown.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onDown.remove(f);
   */
  removeDownFunction(f) {
    this.onDown.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onUp.add(f);
   */
  addUpFunction(f) {
    this.onUp.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onUp.remove(f);
   */
  removeUpFunction(f) {
    this.onUp.remove(f);
  }
};
__publicField(CursorTarget, "TypeName", "cursor-target");
__publicField(CursorTarget, "Properties", {});

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/mat3.js
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create2,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromQuat: () => fromQuat,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity,
  invert: () => invert,
  lookAt: () => lookAt,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  targetTo: () => targetTo,
  translate: () => translate,
  transpose: () => transpose
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s, c, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.hypot(x0, x1, x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.hypot(y0, y1, y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  out[3] = a[3] + b[3] * scale8;
  out[4] = a[4] + b[4] * scale8;
  out[5] = a[5] + b[5] * scale8;
  out[6] = a[6] + b[6] * scale8;
  out[7] = a[7] + b[7] * scale8;
  out[8] = a[8] + b[8] * scale8;
  out[9] = a[9] + b[9] * scale8;
  out[10] = a[10] + b[10] * scale8;
  out[11] = a[11] + b[11] * scale8;
  out[12] = a[12] + b[12] * scale8;
  out[13] = a[13] + b[13] * scale8;
  out[14] = a[14] + b[14] * scale8;
  out[15] = a[15] + b[15] * scale8;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add4,
  calculateW: () => calculateW,
  clone: () => clone4,
  conjugate: () => conjugate,
  copy: () => copy4,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues4,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity2,
  invert: () => invert2,
  len: () => len2,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul3,
  multiply: () => multiply3,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random2,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale4,
  set: () => set4,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen2,
  squaredLength: () => squaredLength3,
  str: () => str3
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues2(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len5 = x * x + y * y + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  out[2] = a[2] * len5;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale8;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale8;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset2, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset2, a.length);
    } else {
      l = a.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues3(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set3(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len5 = x * x + y * y + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x * len5;
  out[1] = y * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset2, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset2, a.length);
    } else {
      l = a.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply3(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale4(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random2(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert2(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot7 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot7 ? 1 / dot7 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str3(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone4 = clone3;
var fromValues4 = fromValues3;
var copy4 = copy3;
var set4 = set3;
var add4 = add3;
var mul3 = multiply3;
var scale4 = scale3;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len2 = length3;
var squaredLength3 = squaredLength2;
var sqrLen2 = squaredLength3;
var normalize3 = normalize2;
var exactEquals4 = exactEquals3;
var equals4 = equals3;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a, b) {
    var dot7 = dot(a, b);
    if (dot7 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot7 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot7;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/quat2.js
var quat2_exports = {};
__export(quat2_exports, {
  add: () => add5,
  clone: () => clone5,
  conjugate: () => conjugate2,
  copy: () => copy5,
  create: () => create6,
  dot: () => dot4,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  fromMat4: () => fromMat4,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation2,
  fromRotationTranslationValues: () => fromRotationTranslationValues,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues5,
  getDual: () => getDual,
  getReal: () => getReal,
  getTranslation: () => getTranslation2,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length4,
  lerp: () => lerp4,
  mul: () => mul4,
  multiply: () => multiply4,
  normalize: () => normalize4,
  rotateAroundAxis: () => rotateAroundAxis,
  rotateByQuatAppend: () => rotateByQuatAppend,
  rotateByQuatPrepend: () => rotateByQuatPrepend,
  rotateX: () => rotateX4,
  rotateY: () => rotateY4,
  rotateZ: () => rotateZ4,
  scale: () => scale5,
  set: () => set5,
  setDual: () => setDual,
  setReal: () => setReal,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength4,
  str: () => str4,
  translate: () => translate2
});
function create6() {
  var dq = new ARRAY_TYPE(8);
  if (ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}
function clone5(a) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
function fromValues5(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
function fromRotationTranslation2(out, q, t) {
  var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
function fromTranslation2(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
function fromRotation2(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function fromMat4(out, a) {
  var outer = create5();
  getRotation(outer, a);
  var t = new ARRAY_TYPE(3);
  getTranslation(t, a);
  fromRotationTranslation2(out, outer, t);
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function set5(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
var getReal = copy4;
function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
var setReal = copy4;
function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
function getTranslation2(out, a) {
  var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
function translate2(out, a, v) {
  var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
function rotateX4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateX3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateY4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateY3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateZ4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateZ3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateByQuatAppend(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
function rotateByQuatPrepend(out, q, a) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
function rotateAroundAxis(out, a, axis, rad) {
  if (Math.abs(rad) < EPSILON) {
    return copy5(out, a);
  }
  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4], ay = a[5], az = a[6], aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
function multiply4(out, a, b) {
  var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
var mul4 = multiply4;
function scale5(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
var dot4 = dot3;
function lerp4(out, a, b, t) {
  var mt = 1 - t;
  if (dot4(a, b) < 0)
    t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
function invert3(out, a) {
  var sqlen = squaredLength4(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
function conjugate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
var length4 = length3;
var len3 = length4;
var squaredLength4 = squaredLength3;
var sqrLen3 = squaredLength4;
function normalize4(out, a) {
  var magnitude = squaredLength4(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}
function str4(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
function exactEquals5(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}

// node_modules/@wonderlandengine/components/dist/hit-test-location.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HitTestLocation = class extends Component {
  tempScaling = new Float32Array(3);
  visible = false;
  xrHitTestSource = null;
  /** Reference space for creating the hit test when the session starts */
  xrReferenceSpace = null;
  /**
   * For maintaining backwards compatibility: Whether to scale the object to 0 and back.
   * @deprecated Use onHitLost and onHitFound instead.
   */
  scaleObject = true;
  /** Emits an event when the hit test switches from visible to invisible */
  onHitLost = new Emitter();
  /** Emits an event when the hit test switches from invisible to visible */
  onHitFound = new Emitter();
  onSessionStartCallback = null;
  onSessionEndCallback = null;
  start() {
    this.onSessionStartCallback = this.onXRSessionStart.bind(this);
    this.onSessionEndCallback = this.onXRSessionEnd.bind(this);
    if (this.scaleObject) {
      this.tempScaling.set(this.object.scalingLocal);
      this.object.scale([0, 0, 0]);
      this.onHitLost.add(() => {
        this.tempScaling.set(this.object.scalingLocal);
        this.object.scale([0, 0, 0]);
      });
      this.onHitFound.add(() => {
        this.object.scalingLocal.set(this.tempScaling);
        this.object.setDirty();
      });
    }
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.add(this.onSessionEndCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.remove(this.onSessionEndCallback);
  }
  update() {
    const wasVisible = this.visible;
    if (this.xrHitTestSource) {
      const frame = this.engine.xrFrame;
      if (!frame)
        return;
      let hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
      if (hitTestResults.length > 0) {
        let pose = hitTestResults[0].getPose(this.engine.xr.currentReferenceSpace);
        this.visible = !!pose;
        if (pose) {
          setXRRigidTransformLocal(this.object, pose.transform);
        }
      } else {
        this.visible = false;
      }
    }
    if (this.visible != wasVisible) {
      (this.visible ? this.onHitFound : this.onHitLost).notify(this);
    }
  }
  getHitTestResults(frame = this.engine.xr?.frame ?? null) {
    if (!frame)
      return [];
    if (!this.xrHitTestSource)
      return [];
    return frame.getHitTestResults(this.xrHitTestSource);
  }
  onXRSessionStart(session) {
    if (session.requestHitTestSource === void 0) {
      console.error("hit-test-location: hit test feature not available. Deactivating component.");
      this.active = false;
      return;
    }
    session.requestHitTestSource({
      space: this.xrReferenceSpace ?? this.engine.xr.referenceSpaceForType("viewer")
    }).then((hitTestSource) => {
      this.xrHitTestSource = hitTestSource;
    }).catch(console.error);
  }
  onXRSessionEnd() {
    if (!this.xrHitTestSource)
      return;
    this.xrHitTestSource.cancel();
    this.xrHitTestSource = null;
  }
};
__publicField(HitTestLocation, "TypeName", "hit-test-location");
__decorate3([
  property.bool(true)
], HitTestLocation.prototype, "scaleObject", void 0);

// node_modules/@wonderlandengine/components/dist/cursor.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tempVec2 = new Float32Array(3);
var CursorTargetEmitters = class {
  /** Emitter for events when the target is hovered */
  onHover = new Emitter();
  /** Emitter for events when the target is unhovered */
  onUnhover = new Emitter();
  /** Emitter for events when the target is clicked */
  onClick = new Emitter();
  /** Emitter for events when the cursor moves on the target */
  onMove = new Emitter();
  /** Emitter for events when the user pressed the select button on the target */
  onDown = new Emitter();
  /** Emitter for events when the user unpressed the select button on the target */
  onUp = new Emitter();
};
var Cursor = class extends Component {
  static onRegister(engine2) {
    engine2.registerComponent(HitTestLocation);
  }
  _collisionMask = 0;
  _onDeactivateCallbacks = [];
  _input = null;
  _origin = new Float32Array(3);
  _cursorObjScale = new Float32Array(3);
  _direction = new Float32Array(3);
  _projectionMatrix = new Float32Array(16);
  _viewComponent = null;
  _isDown = false;
  _lastIsDown = false;
  _arTouchDown = false;
  _lastPointerPos = new Float32Array(2);
  _lastCursorPosOnTarget = new Float32Array(3);
  _cursorRayScale = new Float32Array(3);
  _hitTestLocation = null;
  _hitTestObject = null;
  _onSessionStartCallback = null;
  /**
   * Whether the cursor (and cursorObject) is visible, i.e. pointing at an object
   * that matches the collision group
   */
  visible = true;
  /** Maximum distance for the cursor's ray cast */
  maxDistance = 100;
  /** Currently hovered object */
  hoveringObject = null;
  /** CursorTarget component of the currently hovered object */
  hoveringObjectTarget = null;
  /** Whether the cursor is hovering reality via hit-test */
  hoveringReality = false;
  /**
   * Global target lets you receive global cursor events on any object.
   */
  globalTarget = new CursorTargetEmitters();
  /**
   * Hit test target lets you receive cursor events for "reality", if
   * `useWebXRHitTest` is set to `true`.
   *
   * @example
   * ```js
   * cursor.hitTestTarget.onClick.add((hit, cursor) => {
   *     // User clicked on reality
   * });
   * ```
   */
  hitTestTarget = new CursorTargetEmitters();
  /** World position of the cursor */
  cursorPos = new Float32Array(3);
  /** Collision group for the ray cast. Only objects in this group will be affected by this cursor. */
  collisionGroup = 1;
  /** (optional) Object that visualizes the cursor's ray. */
  cursorRayObject = null;
  /** Axis along which to scale the `cursorRayObject`. */
  cursorRayScalingAxis = 2;
  /** (optional) Object that visualizes the cursor's hit location. */
  cursorObject = null;
  /** Handedness for VR cursors to accept trigger events only from respective controller. */
  handedness = 0;
  /** Mode for raycasting, whether to use PhysX or simple collision components */
  rayCastMode = 0;
  /** Whether to set the CSS style of the mouse cursor on desktop */
  styleCursor = true;
  /**
   * Use WebXR hit-test if available.
   *
   * Attaches a hit-test-location component to the cursorObject, which will be used
   * by the cursor to send events to the hitTestTarget with HitTestResult.
   */
  useWebXRHitTest = false;
  _onViewportResize = () => {
    if (!this._viewComponent)
      return;
    mat4_exports.invert(this._projectionMatrix, this._viewComponent.projectionMatrix);
  };
  start() {
    this._collisionMask = 1 << this.collisionGroup;
    if (this.handedness == 0) {
      const inputComp = this.object.getComponent("input");
      if (!inputComp) {
        console.warn("cursor component on object", this.object.name, 'was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness || "none";
        this._input = inputComp;
      }
    } else {
      this.handedness = ["left", "right", "none"][this.handedness - 1];
    }
    this._viewComponent = this.object.getComponent(ViewComponent);
    if (this.useWebXRHitTest) {
      this._hitTestObject = this.engine.scene.addObject(this.object);
      this._hitTestLocation = this._hitTestObject.addComponent(HitTestLocation, {
        scaleObject: false
      }) ?? null;
    }
    this._onSessionStartCallback = this.setupVREvents.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this._onSessionStartCallback);
    this.engine.onResize.add(this._onViewportResize);
    this._setCursorVisibility(true);
    if (this._viewComponent != null) {
      const canvas2 = this.engine.canvas;
      const onClick = this.onClick.bind(this);
      const onPointerMove = this.onPointerMove.bind(this);
      const onPointerDown = this.onPointerDown.bind(this);
      const onPointerUp = this.onPointerUp.bind(this);
      canvas2.addEventListener("click", onClick);
      canvas2.addEventListener("pointermove", onPointerMove);
      canvas2.addEventListener("pointerdown", onPointerDown);
      canvas2.addEventListener("pointerup", onPointerUp);
      this._onDeactivateCallbacks.push(() => {
        canvas2.removeEventListener("click", onClick);
        canvas2.removeEventListener("pointermove", onPointerMove);
        canvas2.removeEventListener("pointerdown", onPointerDown);
        canvas2.removeEventListener("pointerup", onPointerUp);
      });
    }
    this._onViewportResize();
  }
  _setCursorRayTransform(hitPosition) {
    if (!this.cursorRayObject)
      return;
    const dist2 = vec3_exports.dist(this._origin, hitPosition);
    this.cursorRayObject.setTranslationLocal([0, 0, -dist2 / 2]);
    if (this.cursorRayScalingAxis != 4) {
      this.cursorRayObject.resetScaling();
      this._cursorRayScale[this.cursorRayScalingAxis] = dist2 / 2;
      this.cursorRayObject.scale(this._cursorRayScale);
    }
  }
  _setCursorVisibility(visible) {
    if (this.visible == visible)
      return;
    this.visible = visible;
    if (!this.cursorObject)
      return;
    if (visible) {
      this.cursorObject.setScalingWorld(this._cursorObjScale);
    } else {
      this.cursorObject.getScalingLocal(this._cursorObjScale);
      this.cursorObject.scale([0, 0, 0]);
    }
  }
  update() {
    if (this.engine.xr && this._arTouchDown && this._input && this.engine.xr.session.inputSources[0].handedness === "none" && this.engine.xr.session.inputSources[0].gamepad) {
      const p = this.engine.xr.session.inputSources[0].gamepad.axes;
      this._direction[0] = p[0];
      this._direction[1] = -p[1];
      this._direction[2] = -1;
      this.applyTransformAndProjectDirection();
    } else if (this.engine.xr && this._input && this._input.xrInputSource) {
      this._direction[0] = 0;
      this._direction[1] = 0;
      this._direction[2] = -1;
      this.applyTransformToDirection();
    } else if (this._viewComponent) {
      this.updateDirection();
    }
    this.rayCast(null, this.engine.xr?.frame);
    if (this.cursorObject) {
      if (this.hoveringObject && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
        this._setCursorVisibility(true);
        this.cursorObject.setTranslationWorld(this.cursorPos);
        this._setCursorRayTransform(this.cursorPos);
      } else {
        this._setCursorVisibility(false);
      }
    }
  }
  /* Returns the hovered cursor target, if available */
  notify(event, originalEvent) {
    const target = this.hoveringObject;
    if (target) {
      const cursorTarget = this.hoveringObjectTarget;
      if (cursorTarget)
        cursorTarget[event].notify(target, this, originalEvent ?? void 0);
      this.globalTarget[event].notify(target, this, originalEvent ?? void 0);
    }
  }
  hoverBehaviour(rayHit, hitTestResult, doClick, originalEvent) {
    const hit = !this.hoveringReality && rayHit.hitCount > 0 ? rayHit.objects[0] : null;
    if (hit) {
      if (!this.hoveringObject || !this.hoveringObject.equals(hit)) {
        if (this.hoveringObject) {
          this.notify("onUnhover", originalEvent);
        }
        this.hoveringObject = hit;
        this.hoveringObjectTarget = this.hoveringObject.getComponent(CursorTarget);
        if (this.styleCursor)
          this.engine.canvas.style.cursor = "pointer";
        this.notify("onHover", originalEvent);
      }
    } else if (this.hoveringObject) {
      this.notify("onUnhover", originalEvent);
      this.hoveringObject = null;
      this.hoveringObjectTarget = null;
      if (this.styleCursor)
        this.engine.canvas.style.cursor = "default";
    }
    if (this.hoveringObject) {
      if (this._isDown !== this._lastIsDown) {
        this.notify(this._isDown ? "onDown" : "onUp", originalEvent);
      }
      if (doClick)
        this.notify("onClick", originalEvent);
    } else if (this.hoveringReality) {
      if (this._isDown !== this._lastIsDown) {
        (this._isDown ? this.hitTestTarget.onDown : this.hitTestTarget.onUp).notify(hitTestResult, this, originalEvent ?? void 0);
      }
      if (doClick)
        this.hitTestTarget.onClick.notify(hitTestResult, this, originalEvent ?? void 0);
    }
    if (hit) {
      if (this.hoveringObject) {
        this.hoveringObject.transformPointInverseWorld(tempVec2, this.cursorPos);
      } else {
        tempVec2.set(this.cursorPos);
      }
      if (!vec3_exports.equals(this._lastCursorPosOnTarget, tempVec2)) {
        this.notify("onMove", originalEvent);
        this._lastCursorPosOnTarget.set(tempVec2);
      }
    } else if (this.hoveringReality) {
      if (!vec3_exports.equals(this._lastCursorPosOnTarget, this.cursorPos)) {
        this.hitTestTarget.onMove.notify(hitTestResult, this, originalEvent ?? void 0);
        this._lastCursorPosOnTarget.set(this.cursorPos);
      }
    } else {
      this._lastCursorPosOnTarget.set(this.cursorPos);
    }
    this._lastIsDown = this._isDown;
  }
  /**
   * Setup event listeners on session object
   * @param s WebXR session
   *
   * Sets up 'select' and 'end' events.
   */
  setupVREvents(s) {
    if (!s)
      console.error("setupVREvents called without a valid session");
    const onSelect = this.onSelect.bind(this);
    s.addEventListener("select", onSelect);
    const onSelectStart = this.onSelectStart.bind(this);
    s.addEventListener("selectstart", onSelectStart);
    const onSelectEnd = this.onSelectEnd.bind(this);
    s.addEventListener("selectend", onSelectEnd);
    this._onDeactivateCallbacks.push(() => {
      if (!this.engine.xrSession)
        return;
      s.removeEventListener("select", onSelect);
      s.removeEventListener("selectstart", onSelectStart);
      s.removeEventListener("selectend", onSelectEnd);
    });
    this._onViewportResize();
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this._onSessionStartCallback);
    this.engine.onResize.remove(this._onViewportResize);
    this._setCursorVisibility(false);
    if (this.hoveringObject)
      this.notify("onUnhover", null);
    if (this.cursorRayObject)
      this.cursorRayObject.scale([0, 0, 0]);
    for (const f of this._onDeactivateCallbacks)
      f();
    this._onDeactivateCallbacks.length = 0;
  }
  onDestroy() {
    this._hitTestObject?.destroy();
  }
  /** 'select' event listener */
  onSelect(e) {
    if (e.inputSource.handedness != this.handedness)
      return;
    this.rayCast(e, e.frame, true);
  }
  /** 'selectstart' event listener */
  onSelectStart(e) {
    this._arTouchDown = true;
    if (e.inputSource.handedness == this.handedness) {
      this._isDown = true;
      this.rayCast(e, e.frame);
    }
  }
  /** 'selectend' event listener */
  onSelectEnd(e) {
    this._arTouchDown = false;
    if (e.inputSource.handedness == this.handedness) {
      this._isDown = false;
      this.rayCast(e, e.frame);
    }
  }
  /** 'pointermove' event listener */
  onPointerMove(e) {
    if (!e.isPrimary)
      return;
    this.updateMousePos(e);
    this.rayCast(e, null);
  }
  /** 'click' event listener */
  onClick(e) {
    this.updateMousePos(e);
    this.rayCast(e, null, true);
  }
  /** 'pointerdown' event listener */
  onPointerDown(e) {
    if (!e.isPrimary || e.button !== 0)
      return;
    this.updateMousePos(e);
    this._isDown = true;
    this.rayCast(e);
  }
  /** 'pointerup' event listener */
  onPointerUp(e) {
    if (!e.isPrimary || e.button !== 0)
      return;
    this.updateMousePos(e);
    this._isDown = false;
    this.rayCast(e);
  }
  /**
   * Update mouse position in non-VR mode and raycast for new position
   * @returns @ref WL.RayHit for new position.
   */
  updateMousePos(e) {
    this._lastPointerPos[0] = e.clientX;
    this._lastPointerPos[1] = e.clientY;
    this.updateDirection();
  }
  updateDirection() {
    const bounds = this.engine.canvas.getBoundingClientRect();
    const left = this._lastPointerPos[0] / bounds.width;
    const top = this._lastPointerPos[1] / bounds.height;
    this._direction[0] = left * 2 - 1;
    this._direction[1] = -top * 2 + 1;
    this._direction[2] = -1;
    this.applyTransformAndProjectDirection();
  }
  applyTransformAndProjectDirection() {
    vec3_exports.transformMat4(this._direction, this._direction, this._projectionMatrix);
    vec3_exports.normalize(this._direction, this._direction);
    this.applyTransformToDirection();
  }
  applyTransformToDirection() {
    vec3_exports.transformQuat(this._direction, this._direction, this.object.transformWorld);
    this.object.getTranslationWorld(this._origin);
  }
  rayCast(originalEvent, frame = null, doClick = false) {
    const rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(this._origin, this._direction, this._collisionMask) : this.engine.physics.rayCast(this._origin, this._direction, this._collisionMask, this.maxDistance);
    let hitResultDistance = Infinity;
    let hitTestResult = null;
    if (this._hitTestLocation?.visible) {
      this._hitTestObject.getTranslationWorld(this.cursorPos);
      hitResultDistance = vec3_exports.distance(this.object.getTranslationWorld(tempVec2), this.cursorPos);
      hitTestResult = this._hitTestLocation?.getHitTestResults(frame)[0];
    }
    let hoveringReality = false;
    if (rayHit.hitCount > 0) {
      const d = rayHit.distances[0];
      if (hitResultDistance >= d) {
        this.cursorPos.set(rayHit.locations[0]);
      } else {
        hoveringReality = true;
      }
    } else if (hitResultDistance < Infinity) {
    } else {
      this.cursorPos.fill(0);
    }
    if (hoveringReality && !this.hoveringReality) {
      this.hitTestTarget.onHover.notify(hitTestResult, this);
    } else if (!hoveringReality && this.hoveringReality) {
      this.hitTestTarget.onUnhover.notify(hitTestResult, this);
    }
    this.hoveringReality = hoveringReality;
    this.hoverBehaviour(rayHit, hitTestResult, doClick, originalEvent);
    return rayHit;
  }
};
__publicField(Cursor, "TypeName", "cursor");
/* Dependencies is deprecated, but we keep it here for compatibility
 * with 1.0.0-rc2 until 1.0.0 is released */
__publicField(Cursor, "Dependencies", [HitTestLocation]);
__decorate4([
  property.int(1)
], Cursor.prototype, "collisionGroup", void 0);
__decorate4([
  property.object()
], Cursor.prototype, "cursorRayObject", void 0);
__decorate4([
  property.enum(["x", "y", "z", "none"], "z")
], Cursor.prototype, "cursorRayScalingAxis", void 0);
__decorate4([
  property.object()
], Cursor.prototype, "cursorObject", void 0);
__decorate4([
  property.enum(["input component", "left", "right", "none"], "input component")
], Cursor.prototype, "handedness", void 0);
__decorate4([
  property.enum(["collision", "physx"], "collision")
], Cursor.prototype, "rayCastMode", void 0);
__decorate4([
  property.bool(true)
], Cursor.prototype, "styleCursor", void 0);
__decorate4([
  property.bool(false)
], Cursor.prototype, "useWebXRHitTest", void 0);

// node_modules/@wonderlandengine/components/dist/debug-object.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DebugObject = class extends Component {
  /** A second object to print the name of */
  obj = null;
  start() {
    let origin = new Float32Array(3);
    quat2_exports.getTranslation(origin, this.object.transformWorld);
    console.log("Debug object:", this.object.name);
    console.log("Other object:", this.obj?.name);
    console.log("	translation", origin);
    console.log("	transformWorld", this.object.transformWorld);
    console.log("	transformLocal", this.object.transformLocal);
  }
};
__publicField(DebugObject, "TypeName", "debug-object");
__decorate5([
  property.object()
], DebugObject.prototype, "obj", void 0);

// node_modules/@wonderlandengine/components/dist/fixed-foveation.js
var FixedFoveation = class extends Component {
  start() {
    this.onSessionStartCallback = this.setFixedFoveation.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
  }
  setFixedFoveation() {
    this.engine.xr.baseLayer.fixedFoveation = this.fixedFoveation;
  }
};
__publicField(FixedFoveation, "TypeName", "fixed-foveation");
__publicField(FixedFoveation, "Properties", {
  /** Amount to apply from 0 (none) to 1 (full) */
  fixedFoveation: { type: Type.Float, default: 0.5 }
});

// node_modules/@wonderlandengine/components/dist/hand-tracking.js
var ORDERED_JOINTS = [
  "wrist",
  "thumb-metacarpal",
  "thumb-phalanx-proximal",
  "thumb-phalanx-distal",
  "thumb-tip",
  "index-finger-metacarpal",
  "index-finger-phalanx-proximal",
  "index-finger-phalanx-intermediate",
  "index-finger-phalanx-distal",
  "index-finger-tip",
  "middle-finger-metacarpal",
  "middle-finger-phalanx-proximal",
  "middle-finger-phalanx-intermediate",
  "middle-finger-phalanx-distal",
  "middle-finger-tip",
  "ring-finger-metacarpal",
  "ring-finger-phalanx-proximal",
  "ring-finger-phalanx-intermediate",
  "ring-finger-phalanx-distal",
  "ring-finger-tip",
  "pinky-finger-metacarpal",
  "pinky-finger-phalanx-proximal",
  "pinky-finger-phalanx-intermediate",
  "pinky-finger-phalanx-distal",
  "pinky-finger-tip"
];
var invTranslation = new Float32Array(3);
var invRotation = new Float32Array(4);
var HandTracking = class extends Component {
  init() {
    this.handedness = ["left", "right"][this.handedness];
  }
  joints = {};
  session = null;
  /* Whether last update had a hand pose */
  hasPose = false;
  _childrenActive = true;
  start() {
    if (!("XRHand" in window)) {
      console.warn("WebXR Hand Tracking not supported by this browser.");
      this.active = false;
      return;
    }
    if (this.handSkin) {
      let skin = this.handSkin;
      let jointIds = skin.jointIds;
      this.joints[ORDERED_JOINTS[0]] = this.engine.wrapObject(jointIds[0]);
      for (let j = 0; j < jointIds.length; ++j) {
        let joint = this.engine.wrapObject(jointIds[j]);
        this.joints[joint.name] = joint;
      }
      return;
    }
    const jointObjects = this.engine.scene.addObjects(ORDERED_JOINTS.length, this.object.parent, ORDERED_JOINTS.length);
    for (let j = 0; j < ORDERED_JOINTS.length; ++j) {
      let joint = jointObjects[j];
      joint.addComponent(MeshComponent, {
        mesh: this.jointMesh,
        material: this.jointMaterial
      });
      this.joints[ORDERED_JOINTS[j]] = joint;
    }
  }
  update(dt) {
    if (!this.session) {
      if (this.engine.xr)
        this.setupVREvents(this.engine.xr.session);
    }
    if (!this.session)
      return;
    this.hasPose = false;
    if (this.session && this.session.inputSources) {
      for (let i = 0; i < this.session.inputSources.length; ++i) {
        const inputSource = this.session.inputSources[i];
        if (!inputSource || !inputSource.hand || inputSource.handedness != this.handedness)
          continue;
        this.hasPose = true;
        const wristSpace = inputSource.hand.get("wrist");
        if (wristSpace !== null) {
          const p = this.engine.xr.frame.getJointPose(wristSpace, this.engine.xr.currentReferenceSpace);
          if (p) {
            setXRRigidTransformLocal(this.object, p.transform);
          }
        }
        this.object.getRotationLocal(invRotation);
        quat_exports.conjugate(invRotation, invRotation);
        this.object.getTranslationLocal(invTranslation);
        for (let j = 0; j < ORDERED_JOINTS.length; ++j) {
          const jointName = ORDERED_JOINTS[j];
          const joint = this.joints[jointName];
          if (joint === null)
            continue;
          let jointPose = null;
          const jointSpace = inputSource.hand.get(jointName);
          if (jointSpace !== null) {
            jointPose = this.engine.xr.frame.getJointPose(jointSpace, this.engine.xr.currentReferenceSpace);
          }
          if (jointPose !== null) {
            if (this.handSkin) {
              joint.resetTranslationRotation();
              joint.translate([
                jointPose.transform.position.x - invTranslation[0],
                jointPose.transform.position.y - invTranslation[1],
                jointPose.transform.position.z - invTranslation[2]
              ]);
              joint.rotate(invRotation);
              joint.rotateObject([
                jointPose.transform.orientation.x,
                jointPose.transform.orientation.y,
                jointPose.transform.orientation.z,
                jointPose.transform.orientation.w
              ]);
            } else {
              setXRRigidTransformLocal(joint, jointPose.transform);
              const r = jointPose.radius || 7e-3;
              joint.setScalingLocal([r, r, r]);
            }
          }
        }
      }
    }
    if (!this.hasPose && this._childrenActive) {
      this._childrenActive = false;
      if (this.deactivateChildrenWithoutPose) {
        this.setChildrenActive(false);
      }
      if (this.controllerToDeactivate) {
        this.controllerToDeactivate.active = true;
        this.setChildrenActive(true, this.controllerToDeactivate);
      }
    } else if (this.hasPose && !this._childrenActive) {
      this._childrenActive = true;
      if (this.deactivateChildrenWithoutPose) {
        this.setChildrenActive(true);
      }
      if (this.controllerToDeactivate) {
        this.controllerToDeactivate.active = false;
        this.setChildrenActive(false, this.controllerToDeactivate);
      }
    }
  }
  setChildrenActive(active, object) {
    object = object || this.object;
    const children = object.children;
    for (const o of children) {
      o.active = active;
      this.setChildrenActive(active, o);
    }
  }
  isGrabbing() {
    const indexTipPos = [0, 0, 0];
    quat2_exports.getTranslation(indexTipPos, this.joints["index-finger-tip"].transformLocal);
    const thumbTipPos = [0, 0, 0];
    quat2_exports.getTranslation(thumbTipPos, this.joints["thumb-tip"].transformLocal);
    return vec3_exports.sqrDist(thumbTipPos, indexTipPos) < 1e-3;
  }
  setupVREvents(s) {
    this.session = s;
  }
};
__publicField(HandTracking, "TypeName", "hand-tracking");
__publicField(HandTracking, "Properties", {
  /** Handedness determining whether to receive tracking input from right or left hand */
  handedness: { type: Type.Enum, default: "left", values: ["left", "right"] },
  /** (optional) Mesh to use to visualize joints */
  jointMesh: { type: Type.Mesh, default: null },
  /** Material to use for display. Applied to either the spawned skinned mesh or the joint spheres. */
  jointMaterial: { type: Type.Material, default: null },
  /** (optional) Skin to apply tracked joint poses to. If not present, joint spheres will be used for display instead. */
  handSkin: { type: Type.Skin, default: null },
  /** Deactivate children if no pose was tracked */
  deactivateChildrenWithoutPose: { type: Type.Bool, default: true },
  /** Controller objects to activate including children if no pose is available */
  controllerToDeactivate: { type: Type.Object }
});

// node_modules/@wonderlandengine/components/dist/howler-audio-listener.js
var import_howler = __toESM(require_howler(), 1);
var HowlerAudioListener = class extends Component {
  init() {
    this.origin = new Float32Array(3);
    this.fwd = new Float32Array(3);
    this.up = new Float32Array(3);
  }
  update() {
    if (!this.spatial)
      return;
    this.object.getTranslationWorld(this.origin);
    this.object.getForward(this.fwd);
    this.object.getUp(this.up);
    Howler.pos(this.origin[0], this.origin[1], this.origin[2]);
    Howler.orientation(this.fwd[0], this.fwd[1], this.fwd[2], this.up[0], this.up[1], this.up[2]);
  }
};
__publicField(HowlerAudioListener, "TypeName", "howler-audio-listener");
__publicField(HowlerAudioListener, "Properties", {
  /** Whether audio should be spatialized/positional. */
  spatial: { type: Type.Bool, default: true }
});

// node_modules/@wonderlandengine/components/dist/howler-audio-source.js
var import_howler2 = __toESM(require_howler(), 1);
var HowlerAudioSource = class extends Component {
  start() {
    this.audio = new Howl({
      src: [this.src],
      loop: this.loop,
      volume: this.volume,
      autoplay: this.autoplay
    });
    this.lastPlayedAudioId = null;
    this.origin = new Float32Array(3);
    this.lastOrigin = new Float32Array(3);
    if (this.spatial && this.autoplay) {
      this.updatePosition();
      this.play();
    }
  }
  update() {
    if (!this.spatial || !this.lastPlayedAudioId)
      return;
    this.object.getTranslationWorld(this.origin);
    if (Math.abs(this.lastOrigin[0] - this.origin[0]) > 5e-3 || Math.abs(this.lastOrigin[1] - this.origin[1]) > 5e-3 || Math.abs(this.lastOrigin[2] - this.origin[2]) > 5e-3) {
      this.updatePosition();
    }
  }
  updatePosition() {
    this.audio.pos(this.origin[0], this.origin[1], this.origin[2], this.lastPlayedAudioId);
    this.lastOrigin.set(this.origin);
  }
  play() {
    if (this.lastPlayedAudioId)
      this.audio.stop(this.lastPlayedAudioId);
    this.lastPlayedAudioId = this.audio.play();
    if (this.spatial)
      this.updatePosition();
  }
  stop() {
    if (!this.lastPlayedAudioId)
      return;
    this.audio.stop(this.lastPlayedAudioId);
    this.lastPlayedAudioId = null;
  }
  onDeactivate() {
    this.stop();
  }
};
__publicField(HowlerAudioSource, "TypeName", "howler-audio-source");
__publicField(HowlerAudioSource, "Properties", {
  /** Volume */
  volume: { type: Type.Float, default: 1 },
  /** Whether audio should be spatialized/positional */
  spatial: { type: Type.Bool, default: true },
  /** Whether to loop the sound */
  loop: { type: Type.Bool, default: false },
  /** Whether to start playing automatically */
  autoplay: { type: Type.Bool, default: false },
  /** URL to a sound file to play */
  src: { type: Type.String, default: "" }
});

// node_modules/@wonderlandengine/components/dist/utils/utils.js
function setFirstMaterialTexture(mat, texture, customTextureProperty) {
  if (customTextureProperty !== "auto") {
    mat[customTextureProperty] = texture;
    return true;
  }
  const shader = mat.shader;
  if (shader === "Flat Opaque Textured") {
    mat.flatTexture = texture;
    return true;
  } else if (shader === "Phong Opaque Textured" || shader === "Foliage" || shader === "Phong Normalmapped" || shader === "Phong Lightmapped") {
    mat.diffuseTexture = texture;
    return true;
  } else if (shader === "Particle") {
    mat.mainTexture = texture;
    return true;
  } else if (shader === "DistanceFieldVector") {
    mat.vectorTexture = texture;
    return true;
  } else if (shader === "Background" || shader === "Sky") {
    mat.texture = texture;
    return true;
  } else if (shader === "Physical Opaque Textured") {
    mat.albedoTexture = texture;
    return true;
  }
  return false;
}

// node_modules/@wonderlandengine/components/dist/image-texture.js
var ImageTexture = class extends Component {
  start() {
    if (!this.material) {
      throw Error("image-texture: material property not set");
    }
    this.engine.textures.load(this.url, "anonymous").then((texture) => {
      const mat = this.material;
      if (!setFirstMaterialTexture(mat, texture, this.textureProperty)) {
        console.error("Shader", mat.shader, "not supported by image-texture");
      }
    }).catch(console.err);
  }
};
__publicField(ImageTexture, "TypeName", "image-texture");
__publicField(ImageTexture, "Properties", {
  /** URL to download the image from */
  url: Property.string(),
  /** Material to apply the video texture to */
  material: Property.material(),
  /** Name of the texture property to set */
  textureProperty: Property.string("auto")
});

// node_modules/@wonderlandengine/components/dist/mouse-look.js
var MouseLookComponent = class extends Component {
  init() {
    this.currentRotationY = 0;
    this.currentRotationX = 0;
    this.origin = new Float32Array(3);
    this.parentOrigin = new Float32Array(3);
    this.rotationX = 0;
    this.rotationY = 0;
  }
  start() {
    document.addEventListener("mousemove", (e) => {
      if (this.active && (this.mouseDown || !this.requireMouseDown)) {
        this.rotationY = -this.sensitity * e.movementX / 100;
        this.rotationX = -this.sensitity * e.movementY / 100;
        this.currentRotationX += this.rotationX;
        this.currentRotationY += this.rotationY;
        this.currentRotationX = Math.min(1.507, this.currentRotationX);
        this.currentRotationX = Math.max(-1.507, this.currentRotationX);
        this.object.getTranslationWorld(this.origin);
        const parent = this.object.parent;
        if (parent !== null) {
          parent.getTranslationWorld(this.parentOrigin);
          vec3_exports.sub(this.origin, this.origin, this.parentOrigin);
        }
        this.object.resetTranslationRotation();
        this.object.rotateAxisAngleRad([1, 0, 0], this.currentRotationX);
        this.object.rotateAxisAngleRad([0, 1, 0], this.currentRotationY);
        this.object.translate(this.origin);
      }
    });
    const canvas2 = this.engine.canvas;
    if (this.pointerLockOnClick) {
      canvas2.addEventListener("mousedown", () => {
        canvas2.requestPointerLock = canvas2.requestPointerLock || canvas2.mozRequestPointerLock || canvas2.webkitRequestPointerLock;
        canvas2.requestPointerLock();
      });
    }
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex == 2) {
        canvas2.addEventListener("contextmenu", (e) => {
          e.preventDefault();
        }, false);
      }
      canvas2.addEventListener("mousedown", (e) => {
        if (e.button == this.mouseButtonIndex) {
          this.mouseDown = true;
          document.body.style.cursor = "grabbing";
          if (e.button == 1) {
            e.preventDefault();
            return false;
          }
        }
      });
      canvas2.addEventListener("mouseup", (e) => {
        if (e.button == this.mouseButtonIndex) {
          this.mouseDown = false;
          document.body.style.cursor = "initial";
        }
      });
    }
  }
};
__publicField(MouseLookComponent, "TypeName", "mouse-look");
__publicField(MouseLookComponent, "Properties", {
  /** Mouse look sensitivity */
  sensitity: { type: Type.Float, default: 0.25 },
  /** Require a mouse button to be pressed to control view.
   * Otherwise view will allways follow mouse movement */
  requireMouseDown: { type: Type.Bool, default: true },
  /** If "moveOnClick" is enabled, mouse button which should
   * be held down to control view */
  mouseButtonIndex: { type: Type.Int },
  /** Enables pointer lock on "mousedown" event on canvas */
  pointerLockOnClick: { type: Type.Bool, default: false }
});

// node_modules/@wonderlandengine/components/dist/player-height.js
var PlayerHeight = class extends Component {
  start() {
    this.object.resetTranslationRotation();
    this.object.translate([0, this.height, 0]);
    this.onSessionStartCallback = this.onXRSessionStart.bind(this);
    this.onSessionEndCallback = this.onXRSessionEnd.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.add(this.onSessionEndCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.remove(this.onSessionEndCallback);
  }
  onXRSessionStart() {
    if (!["local", "viewer"].includes(this.engine.xr.currentReferenceSpace)) {
      this.object.resetTranslationRotation();
    }
  }
  onXRSessionEnd() {
    if (!["local", "viewer"].includes(this.engine.xr.currentReferenceSpace)) {
      this.object.resetTranslationRotation();
      this.object.translate([0, this.height, 0]);
    }
  }
};
__publicField(PlayerHeight, "TypeName", "player-height");
__publicField(PlayerHeight, "Properties", {
  height: { type: Type.Float, default: 1.75 }
});

// node_modules/@wonderlandengine/components/dist/target-framerate.js
var TargetFramerate = class extends Component {
  start() {
    this.onSessionStartCallback = this.setTargetFramerate.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
  }
  setTargetFramerate(s) {
    if (s.supportedFrameRates && s.updateTargetFrameRate) {
      const a = this.engine.xr.session.supportedFrameRates;
      a.sort((a2, b) => Math.abs(a2 - this.framerate) - Math.abs(b - this.framerate));
      this.engine.xr.session.updateTargetFrameRate(a[0]);
    }
  }
};
__publicField(TargetFramerate, "TypeName", "target-framerate");
__publicField(TargetFramerate, "Properties", {
  framerate: { type: Type.Float, default: 90 }
});

// node_modules/@wonderlandengine/components/dist/teleport.js
var TeleportComponent = class extends Component {
  init() {
    this._prevThumbstickAxis = new Float32Array(2);
    this._tempVec = new Float32Array(3);
    this._tempVec0 = new Float32Array(3);
    this._currentIndicatorRotation = 0;
    this.input = this.object.getComponent("input");
    if (!this.input) {
      console.error(this.object.name, "generic-teleport-component.js: input component is required on the object");
      return;
    }
    if (!this.teleportIndicatorMeshObject) {
      console.error(this.object.name, "generic-teleport-component.js: Teleport indicator mesh is missing");
      return;
    }
    if (!this.camRoot) {
      console.error(this.object.name, "generic-teleport-component.js: camRoot not set");
      return;
    }
    this.isIndicating = false;
    this.indicatorHidden = true;
    this.hitSpot = new Float32Array(3);
    this._hasHit = false;
    this._extraRotation = 0;
    this._currentStickAxes = new Float32Array(2);
  }
  start() {
    if (this.cam) {
      this.isMouseIndicating = false;
      canvas.addEventListener("mousedown", this.onMouseDown.bind(this));
      canvas.addEventListener("mouseup", this.onMouseUp.bind(this));
    }
    if (this.handedness == 0) {
      const inputComp = this.object.getComponent("input");
      if (!inputComp) {
        console.warn("teleport component on object", this.object.name, 'was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness;
        this.input = inputComp;
      }
    } else {
      this.handedness = ["left", "right"][this.handedness - 1];
    }
    this.onSessionStartCallback = this.setupVREvents.bind(this);
    this.teleportIndicatorMeshObject.active = false;
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
  }
  /* Get current camera Y rotation */
  _getCamRotation() {
    this.eyeLeft.getForward(this._tempVec);
    this._tempVec[1] = 0;
    vec3_exports.normalize(this._tempVec, this._tempVec);
    return Math.atan2(this._tempVec[0], this._tempVec[2]);
  }
  update() {
    let inputLength = 0;
    if (this.gamepad && this.gamepad.axes) {
      this._currentStickAxes[0] = this.gamepad.axes[2];
      this._currentStickAxes[1] = this.gamepad.axes[3];
      inputLength = Math.abs(this._currentStickAxes[0]) + Math.abs(this._currentStickAxes[1]);
    }
    if (!this.isIndicating && this._prevThumbstickAxis[1] >= this.thumbstickActivationThreshhold && this._currentStickAxes[1] < this.thumbstickActivationThreshhold) {
      this.isIndicating = true;
    } else if (this.isIndicating && inputLength < this.thumbstickDeactivationThreshhold) {
      this.isIndicating = false;
      this.teleportIndicatorMeshObject.active = false;
      if (this._hasHit) {
        this._teleportPlayer(this.hitSpot, this._extraRotation);
      }
    }
    if (this.isIndicating && this.teleportIndicatorMeshObject && this.input) {
      const origin = this._tempVec0;
      this.object.getPositionWorld(origin);
      const direction2 = this.object.getForwardWorld(this._tempVec);
      let rayHit = this.rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(origin, direction2, 1 << this.floorGroup) : this.engine.physics.rayCast(origin, direction2, 1 << this.floorGroup, this.maxDistance);
      if (rayHit.hitCount > 0) {
        this.indicatorHidden = false;
        this._extraRotation = Math.PI + Math.atan2(this._currentStickAxes[0], this._currentStickAxes[1]);
        this._currentIndicatorRotation = this._getCamRotation() + (this._extraRotation - Math.PI);
        this.teleportIndicatorMeshObject.resetPositionRotation();
        this.teleportIndicatorMeshObject.rotateAxisAngleRad([0, 1, 0], this._currentIndicatorRotation);
        this.teleportIndicatorMeshObject.translate(rayHit.locations[0]);
        this.teleportIndicatorMeshObject.translate([
          0,
          this.indicatorYOffset,
          0
        ]);
        this.teleportIndicatorMeshObject.active = true;
        this.hitSpot.set(rayHit.locations[0]);
        this._hasHit = true;
      } else {
        if (!this.indicatorHidden) {
          this.teleportIndicatorMeshObject.active = false;
          this.indicatorHidden = true;
        }
        this._hasHit = false;
      }
    } else if (this.teleportIndicatorMeshObject && this.isMouseIndicating) {
      this.onMousePressed();
    }
    this._prevThumbstickAxis.set(this._currentStickAxes);
  }
  setupVREvents(s) {
    this.session = s;
    s.addEventListener("end", function() {
      this.gamepad = null;
      this.session = null;
    }.bind(this));
    if (s.inputSources && s.inputSources.length) {
      for (let i = 0; i < s.inputSources.length; i++) {
        let inputSource = s.inputSources[i];
        if (inputSource.handedness == this.handedness) {
          this.gamepad = inputSource.gamepad;
        }
      }
    }
    s.addEventListener("inputsourceschange", function(e) {
      if (e.added && e.added.length) {
        for (let i = 0; i < e.added.length; i++) {
          let inputSource = e.added[i];
          if (inputSource.handedness == this.handedness) {
            this.gamepad = inputSource.gamepad;
          }
        }
      }
    }.bind(this));
  }
  onMouseDown() {
    this.isMouseIndicating = true;
  }
  onMouseUp() {
    this.isMouseIndicating = false;
    this.teleportIndicatorMeshObject.active = false;
    if (this._hasHit) {
      this._teleportPlayer(this.hitSpot, 0);
    }
  }
  onMousePressed() {
    let origin = [0, 0, 0];
    this.cam.getPositionWorld(origin);
    const direction2 = this.cam.getForward(this._tempVec);
    let rayHit = this.rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(origin, direction2, 1 << this.floorGroup) : this.engine.physics.rayCast(origin, direction2, 1 << this.floorGroup, this.maxDistance);
    if (rayHit.hitCount > 0) {
      this.indicatorHidden = false;
      direction2[1] = 0;
      vec3_exports.normalize(direction2, direction2);
      this._currentIndicatorRotation = -Math.sign(direction2[2]) * Math.acos(direction2[0]) - Math.PI * 0.5;
      this.teleportIndicatorMeshObject.resetPositionRotation();
      this.teleportIndicatorMeshObject.rotateAxisAngleRad([0, 1, 0], this._currentIndicatorRotation);
      this.teleportIndicatorMeshObject.translate(rayHit.locations[0]);
      this.teleportIndicatorMeshObject.active = true;
      this.hitSpot = rayHit.locations[0];
      this._hasHit = true;
    } else {
      if (!this.indicatorHidden) {
        this.teleportIndicatorMeshObject.active = false;
        this.indicatorHidden = true;
      }
      this._hasHit = false;
    }
  }
  _teleportPlayer(newPosition, rotationToAdd) {
    this.camRoot.rotateAxisAngleRad([0, 1, 0], rotationToAdd);
    const p = this._tempVec;
    const p1 = this._tempVec0;
    if (this.session) {
      this.eyeLeft.getPositionWorld(p);
      this.eyeRight.getPositionWorld(p1);
      vec3_exports.add(p, p, p1);
      vec3_exports.scale(p, p, 0.5);
    } else {
      this.cam.getPositionWorld(p);
    }
    this.camRoot.getPositionWorld(p1);
    vec3_exports.sub(p, p1, p);
    p[0] += newPosition[0];
    p[1] = newPosition[1];
    p[2] += newPosition[2];
    this.camRoot.setPositionWorld(p);
  }
};
__publicField(TeleportComponent, "TypeName", "teleport");
__publicField(TeleportComponent, "Properties", {
  /** Object that will be placed as indiciation forwhere the player will teleport to. */
  teleportIndicatorMeshObject: { type: Type.Object },
  /** Root of the player, the object that will be positioned on teleportation. */
  camRoot: { type: Type.Object },
  /** Non-vr camera for use outside of VR */
  cam: { type: Type.Object },
  /** Left eye for use in VR*/
  eyeLeft: { type: Type.Object },
  /** Right eye for use in VR*/
  eyeRight: { type: Type.Object },
  /** Handedness for VR cursors to accept trigger events only from respective controller. */
  handedness: {
    type: Type.Enum,
    values: ["input component", "left", "right", "none"],
    default: "input component"
  },
  /** Collision group of valid "floor" objects that can be teleported on */
  floorGroup: { type: Type.Int, default: 1 },
  /** How far the thumbstick needs to be pushed to have the teleport target indicator show up */
  thumbstickActivationThreshhold: { type: Type.Float, default: -0.7 },
  /** How far the thumbstick needs to be released to execute the teleport */
  thumbstickDeactivationThreshhold: { type: Type.Float, default: 0.3 },
  /** Offset to apply to the indicator object, e.g. to avoid it from Z-fighting with the floor */
  indicatorYOffset: { type: Type.Float, default: 0.01 },
  /** Mode for raycasting, whether to use PhysX or simple collision components */
  rayCastMode: {
    type: Type.Enum,
    values: ["collision", "physx"],
    default: "collision"
  },
  /** Max distance for PhysX raycast */
  maxDistance: { type: Type.Float, default: 100 }
});

// node_modules/@wonderlandengine/components/dist/trail.js
var direction = vec3_exports.create();
var offset = vec3_exports.create();
var normal = vec3_exports.create();
var Trail = class extends Component {
  init() {
    this.points = new Array(this.segments + 1);
    for (let i = 0; i < this.points.length; ++i) {
      this.points[i] = vec3_exports.create();
    }
    this.currentPointOffset = 0;
    this.up = [0, 1, 0];
    this.timeTillNext = this.interval;
  }
  start() {
    this.trailContainer = this.engine.scene.addObject();
    this.meshComp = this.trailContainer.addComponent("mesh");
    this.meshComp.material = this.material;
    const vertexCount = 2 * this.points.length;
    this.indexData = new Uint32Array(6 * this.segments);
    for (let i = 0, v = 0; i < vertexCount - 2; i += 2, v += 6) {
      this.indexData.subarray(v, v + 6).set([i + 1, i + 0, i + 2, i + 2, i + 3, i + 1]);
    }
    this.mesh = new Mesh(this.engine, {
      vertexCount,
      indexData: this.indexData,
      indexType: MeshIndexType.UnsignedInt
    });
    this.meshComp.mesh = this.mesh;
  }
  updateVertices() {
    const positions = this.mesh.attribute(MeshAttribute.Position);
    const texCoords = this.mesh.attribute(MeshAttribute.TextureCoordinate);
    const normals = this.mesh.attribute(MeshAttribute.Normal);
    vec3_exports.set(direction, 0, 0, 0);
    for (let i = 0; i < this.points.length; ++i) {
      const curr = this.points[(this.currentPointIndex + i + 1) % this.points.length];
      const next = this.points[(this.currentPointIndex + i + 2) % this.points.length];
      if (i !== this.points.length - 1) {
        vec3_exports.sub(direction, next, curr);
      }
      vec3_exports.cross(offset, this.up, direction);
      vec3_exports.normalize(offset, offset);
      const timeFraction = 1 - this.timeTillNext / this.interval;
      const fraction = (i - timeFraction) / this.segments;
      vec3_exports.scale(offset, offset, (this.taper ? fraction : 1) * this.width / 2);
      positions.set(i * 2, [
        curr[0] - offset[0],
        curr[1] - offset[1],
        curr[2] - offset[2]
      ]);
      positions.set(i * 2 + 1, [
        curr[0] + offset[0],
        curr[1] + offset[1],
        curr[2] + offset[2]
      ]);
      if (normals) {
        vec3_exports.cross(normal, direction, offset);
        vec3_exports.normalize(normal, normal);
        normals.set(i * 2, normal);
        normals.set(i * 2 + 1, normal);
      }
      if (texCoords) {
        texCoords.set(i * 2, [0, fraction]);
        texCoords.set(i * 2 + 1, [1, fraction]);
      }
    }
    this.mesh.update();
  }
  resetTrail() {
    this.object.getTranslationWorld(this.points[0]);
    for (let i = 1; i < this.points.length; ++i) {
      vec3_exports.copy(this.points[i], this.points[0]);
    }
    this.currentPointIndex = 0;
    this.timeTillNext = this.interval;
  }
  update(dt) {
    this.timeTillNext -= dt;
    if (dt > this.resetThreshold) {
      this.resetTrail();
    }
    if (this.timeTillNext < 0) {
      this.currentPointIndex = (this.currentPointIndex + 1) % this.points.length;
      this.timeTillNext = this.timeTillNext % this.interval + this.interval;
    }
    this.object.getTranslationWorld(this.points[this.currentPointIndex]);
    this.updateVertices();
  }
  onActivate() {
    this.resetTrail();
  }
  onDestroy() {
    this.trailContainer.destroy();
    this.mesh.destroy();
  }
};
__publicField(Trail, "TypeName", "trail");
__publicField(Trail, "Properties", {
  /** The material to apply to the trail mesh */
  material: { type: Type.Material },
  /** The number of segments in the trail mesh */
  segments: { type: Type.Int, default: 50 },
  /** The time interval before recording a new point */
  interval: { type: Type.Float, default: 0.1 },
  /** The width of the trail (in world space) */
  width: { type: Type.Float, default: 1 },
  /** Whether or not the trail should taper off */
  taper: { type: Type.Bool, default: true },
  /**
   * The maximum delta time in seconds, above which the trail resets.
   * This prevents the trail from jumping around when updates happen
   * infrequently (e.g. when the tab doesn't have focus).
   */
  resetThreshold: { type: Type.Float, default: 0.5 }
});

// node_modules/@wonderlandengine/components/dist/two-joint-ik-solver.js
Math.clamp = function(v, a, b) {
  return Math.max(a, Math.min(v, b));
};
var twoJointIK = function() {
  let ta = new Float32Array(3);
  let ca = new Float32Array(3);
  let ba = new Float32Array(3);
  let ab = new Float32Array(3);
  let cb = new Float32Array(3);
  let axis0 = new Float32Array(3);
  let axis1 = new Float32Array(3);
  let temp = new Float32Array(4);
  let r0 = new Float32Array(4);
  let r1 = new Float32Array(4);
  let r2 = new Float32Array(4);
  return function(a_lr, b_lr, a, b, c, t, eps, a_gr, b_gr, helper) {
    vec3_exports.sub(ba, b, a);
    const lab = vec3_exports.length(ba);
    vec3_exports.sub(ta, b, c);
    const lcb = vec3_exports.length(ta);
    vec3_exports.sub(ta, t, a);
    const lat = Math.clamp(vec3_exports.length(ta), eps, lab + lcb - eps);
    vec3_exports.sub(ca, c, a);
    vec3_exports.sub(ab, a, b);
    vec3_exports.sub(cb, c, b);
    vec3_exports.normalize(ca, ca);
    vec3_exports.normalize(ba, ba);
    vec3_exports.normalize(ab, ab);
    vec3_exports.normalize(cb, cb);
    vec3_exports.normalize(ta, ta);
    const ac_ab_0 = Math.acos(Math.clamp(vec3_exports.dot(ca, ba), -1, 1));
    const ba_bc_0 = Math.acos(Math.clamp(vec3_exports.dot(ab, cb), -1, 1));
    const ac_at_0 = Math.acos(Math.clamp(vec3_exports.dot(ca, ta), -1, 1));
    const ac_ab_1 = Math.acos(Math.clamp((lcb * lcb - lab * lab - lat * lat) / (-2 * lab * lat), -1, 1));
    const ba_bc_1 = Math.acos(Math.clamp((lat * lat - lab * lab - lcb * lcb) / (-2 * lab * lcb), -1, 1));
    vec3_exports.sub(ca, c, a);
    vec3_exports.sub(ba, b, a);
    vec3_exports.sub(ta, t, a);
    vec3_exports.cross(axis0, ca, ba);
    vec3_exports.cross(axis1, ca, ta);
    if (helper) {
      vec3_exports.sub(ba, helper, b);
      vec3_exports.transformQuat(ba, [0, 0, -1], b_gr);
    } else {
      vec3_exports.sub(ba, b, a);
    }
    const l = vec3_exports.length(axis0);
    if (l == 0) {
      axis0.set([1, 0, 0]);
    } else {
      vec3_exports.scale(axis0, axis0, 1 / l);
    }
    vec3_exports.normalize(axis1, axis1);
    quat_exports.conjugate(a_gr, a_gr);
    quat_exports.setAxisAngle(r0, vec3_exports.transformQuat(temp, axis0, a_gr), ac_ab_1 - ac_ab_0);
    quat_exports.setAxisAngle(r2, vec3_exports.transformQuat(temp, axis1, a_gr), ac_at_0);
    quat_exports.mul(a_lr, a_lr, quat_exports.mul(temp, r0, r2));
    quat_exports.normalize(a_lr, a_lr);
    quat_exports.conjugate(b_gr, b_gr);
    quat_exports.setAxisAngle(r1, vec3_exports.transformQuat(temp, axis0, b_gr), ba_bc_1 - ba_bc_0);
    quat_exports.mul(b_lr, b_lr, r1);
    quat_exports.normalize(b_lr, b_lr);
  };
}();
var TwoJointIkSolver = class extends Component {
  init() {
    this.pos = new Float32Array(3 * 7);
    this.p = [
      this.pos.subarray(0, 3),
      this.pos.subarray(3, 6),
      this.pos.subarray(6, 9),
      this.pos.subarray(9, 12),
      this.pos.subarray(12, 15),
      this.pos.subarray(15, 18),
      this.pos.subarray(18, 21)
    ];
  }
  update() {
    const p = this.p;
    this.root.getTranslationWorld(p[0]);
    this.middle.getTranslationWorld(p[1]);
    this.end.getTranslationWorld(p[2]);
    this.target.getTranslationWorld(p[3]);
    const tla = p[4];
    const tlb = p[5];
    this.root.getTranslationLocal(tla);
    this.middle.getTranslationLocal(tlb);
    if (this.helper)
      this.helper.getTranslationWorld(p[6]);
    twoJointIK(this.root.transformLocal, this.middle.transformLocal, p[0], p[1], p[2], p[3], 0.01, this.root.transformWorld.subarray(0, 4), this.middle.transformWorld.subarray(0, 4), this.helper ? p[6] : null);
    this.root.setTranslationLocal(tla);
    this.middle.setTranslationLocal(tlb);
    this.root.setDirty();
    this.middle.setDirty();
  }
};
__publicField(TwoJointIkSolver, "TypeName", "two-joint-ik-solver");
__publicField(TwoJointIkSolver, "Properties", {
  /** Root bone, never moves */
  root: { type: Type.Object },
  /** Bone attached to the root */
  middle: { type: Type.Object },
  /** Bone attached to the middle */
  end: { type: Type.Object },
  /** Target the joins should reach for */
  target: { type: Type.Object },
  /** Helper object to use to determine joint rotation axis */
  helper: { type: Type.Object }
});

// node_modules/@wonderlandengine/components/dist/video-texture.js
var VideoTexture = class extends Component {
  init() {
    if (!this.material) {
      throw Error("video-texture: material property not set");
    }
    this.loaded = false;
    this.frameUpdateRequested = true;
  }
  start() {
    this.video = document.createElement("video");
    this.video.src = this.url;
    this.video.crossOrigin = "anonymous";
    this.video.playsInline = true;
    this.video.loop = this.loop;
    this.video.muted = this.muted;
    this.video.addEventListener("playing", () => {
      this.loaded = true;
    });
    if (this.autoplay) {
      const playAfterUserGesture = () => {
        this.video.play();
        window.removeEventListener("click", playAfterUserGesture);
        window.removeEventListener("touchstart", playAfterUserGesture);
      };
      window.addEventListener("click", playAfterUserGesture);
      window.addEventListener("touchstart", playAfterUserGesture);
    }
  }
  applyTexture() {
    const mat = this.material;
    const shader = mat.shader;
    const texture = this.texture = new Texture(this.engine, this.video);
    if (!setFirstMaterialTexture(mat, texture, this.textureProperty)) {
      console.error("Shader", shader, "not supported by video-texture");
    }
    if ("requestVideoFrameCallback" in this.video) {
      this.video.requestVideoFrameCallback(this.updateVideo.bind(this));
    } else {
      this.video.addEventListener("timeupdate", () => {
        this.frameUpdateRequested = true;
      });
    }
  }
  update(dt) {
    if (this.loaded && this.frameUpdateRequested) {
      if (this.texture) {
        this.texture.update();
      } else {
        this.applyTexture();
      }
      this.frameUpdateRequested = false;
    }
  }
  updateVideo() {
    this.frameUpdateRequested = true;
    this.video.requestVideoFrameCallback(this.updateVideo.bind(this));
  }
};
__publicField(VideoTexture, "TypeName", "video-texture");
__publicField(VideoTexture, "Properties", {
  /** URL to download video from */
  url: Property.string(),
  /** Material to apply the video texture to */
  material: Property.material(),
  /** Whether to loop the video */
  loop: Property.bool(true),
  /** Whether to automatically start playing the video */
  autoplay: Property.bool(true),
  /** Whether to mute sound */
  muted: Property.bool(true),
  /** Name of the texture property to set */
  textureProperty: Property.string("auto")
});

// node_modules/@wonderlandengine/components/dist/vr-mode-active-switch.js
var VrModeActiveSwitch = class extends Component {
  start() {
    this.components = [];
    this.getComponents(this.object);
    this.onXRSessionEnd();
    this.onSessionStartCallback = this.onXRSessionStart.bind(this);
    this.onSessionEndCallback = this.onXRSessionEnd.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.add(this.onSessionEndCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.remove(this.onSessionEndCallback);
  }
  getComponents(obj) {
    const comps = obj.getComponents().filter((c) => c.type !== "vr-mode-active-switch");
    this.components = this.components.concat(comps);
    if (this.affectChildren) {
      let children = obj.children;
      for (let i = 0; i < children.length; ++i) {
        this.getComponents(children[i]);
      }
    }
  }
  setComponentsActive(active) {
    const comps = this.components;
    for (let i = 0; i < comps.length; ++i) {
      comps[i].active = active;
    }
  }
  onXRSessionStart() {
    this.setComponentsActive(this.activateComponents == 0);
  }
  onXRSessionEnd() {
    this.setComponentsActive(this.activateComponents != 0);
  }
};
__publicField(VrModeActiveSwitch, "TypeName", "vr-mode-active-switch");
__publicField(VrModeActiveSwitch, "Properties", {
  /** When components should be active: In VR or when not in VR */
  activateComponents: {
    type: Type.Enum,
    values: ["in VR", "in non-VR"],
    default: "in VR"
  },
  /** Whether child object's components should be affected */
  affectChildren: { type: Type.Bool, default: true }
});

// node_modules/@wonderlandengine/components/dist/plane-detection.js
var import_earcut = __toESM(require_earcut(), 1);
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tempVec32 = new Float32Array(3);
function extentsFromContour(out, points) {
  if (points.length == 0)
    return out;
  let absMaxX = Math.abs(points[0].x);
  let absMaxZ = Math.abs(points[0].z);
  for (let i = 1; i < points.length; ++i) {
    absMaxX = Math.max(absMaxX, Math.abs(points[i].x));
    absMaxZ = Math.max(absMaxZ, Math.abs(points[i].z));
  }
  out[0] = absMaxX;
  out[1] = 0;
  out[2] = absMaxZ;
}
function planeMeshFromContour(engine2, points, meshToUpdate = null) {
  const vertexCount = points.length;
  const vertices = new Float32Array(vertexCount * 2);
  for (let i = 0, d = 0; i < vertexCount; ++i, d += 2) {
    vertices[d] = points[i].x;
    vertices[d + 1] = points[i].z;
  }
  const triangles = (0, import_earcut.default)(vertices);
  const mesh = meshToUpdate || new Mesh(engine2, {
    vertexCount,
    /* Assumption here that we will never have more than 256 points
     * in the detected plane meshes! */
    indexType: MeshIndexType.UnsignedByte,
    indexData: triangles
  });
  if (mesh.vertexCount !== vertexCount) {
    console.warn("vertexCount of meshToUpdate did not match required vertexCount");
    return mesh;
  }
  const positions = mesh.attribute(MeshAttribute.Position);
  const textureCoords = mesh.attribute(MeshAttribute.TextureCoordinate);
  const normals = mesh.attribute(MeshAttribute.Normal);
  tempVec32[1] = 0;
  for (let i = 0, s = 0; i < vertexCount; ++i, s += 2) {
    tempVec32[0] = vertices[s];
    tempVec32[2] = vertices[s + 1];
    positions.set(i, tempVec32);
  }
  textureCoords?.set(0, vertices);
  if (normals) {
    tempVec32[0] = 0;
    tempVec32[1] = 1;
    tempVec32[2] = 0;
    for (let i = 0; i < vertexCount; ++i) {
      normals.set(i, tempVec32);
    }
  }
  if (meshToUpdate)
    mesh.update();
  return mesh;
}
var _planeLost, planeLost_fn, _planeFound, planeFound_fn, _planeUpdate, planeUpdate_fn, _planeUpdatePose, planeUpdatePose_fn;
var PlaneDetection = class extends Component {
  constructor() {
    super(...arguments);
    __privateAdd(this, _planeLost);
    __privateAdd(this, _planeFound);
    __privateAdd(this, _planeUpdate);
    __privateAdd(this, _planeUpdatePose);
    /**
     * Material to assign to created plane meshes or `null` if meshes should not be created.
     */
    __publicField(this, "planeMaterial", null);
    /**
     * Collision mask to assign to newly created collision components or a negative value if
     * collision components should not be created.
     */
    __publicField(this, "collisionMask", -1);
    /** Map of all planes and their last updated timestamps */
    __publicField(this, "planes", /* @__PURE__ */ new Map());
    /** Objects generated for each XRPlane */
    __publicField(this, "planeObjects", /* @__PURE__ */ new Map());
    /** Called when a plane starts tracking */
    __publicField(this, "onPlaneFound", new Emitter());
    /** Called when a plane stops tracking */
    __publicField(this, "onPlaneLost", new Emitter());
  }
  update() {
    if (!this.engine.xr?.frame)
      return;
    if (this.engine.xr.frame.detectedPlanes === void 0) {
      console.error("plane-detection: WebXR feature not available.");
      this.active = false;
      return;
    }
    const detectedPlanes = this.engine.xr.frame.detectedPlanes;
    for (const [plane, _] of this.planes) {
      if (!detectedPlanes.has(plane)) {
        __privateMethod(this, _planeLost, planeLost_fn).call(this, plane);
      }
    }
    detectedPlanes.forEach((plane) => {
      if (this.planes.has(plane)) {
        if (plane.lastChangedTime > this.planes.get(plane)) {
          __privateMethod(this, _planeUpdate, planeUpdate_fn).call(this, plane);
        }
      } else {
        __privateMethod(this, _planeFound, planeFound_fn).call(this, plane);
      }
      __privateMethod(this, _planeUpdatePose, planeUpdatePose_fn).call(this, plane);
    });
  }
};
_planeLost = new WeakSet();
planeLost_fn = function(plane) {
  this.planes.delete(plane);
  const o = this.planeObjects.get(plane);
  this.onPlaneLost.notify(plane, o);
  if (o.objectId > 0)
    o.destroy();
};
_planeFound = new WeakSet();
planeFound_fn = function(plane) {
  this.planes.set(plane, plane.lastChangedTime);
  const o = this.engine.scene.addObject(this.object);
  this.planeObjects.set(plane, o);
  if (this.planeMaterial) {
    o.addComponent(MeshComponent, {
      mesh: planeMeshFromContour(this.engine, plane.polygon),
      material: this.planeMaterial
    });
  }
  if (this.collisionMask >= 0) {
    extentsFromContour(tempVec32, plane.polygon);
    tempVec32[1] = 0.025;
    o.addComponent(CollisionComponent, {
      group: this.collisionMask,
      collider: Collider.Box,
      extents: tempVec32
    });
  }
  this.onPlaneFound.notify(plane, o);
};
_planeUpdate = new WeakSet();
planeUpdate_fn = function(plane) {
  this.planes.set(plane, plane.lastChangedTime);
  const planeMesh = this.planeObjects.get(plane).getComponent(MeshComponent);
  if (!planeMesh)
    return;
  planeMeshFromContour(this.engine, plane.polygon, planeMesh.mesh);
};
_planeUpdatePose = new WeakSet();
planeUpdatePose_fn = function(plane) {
  const o = this.planeObjects.get(plane);
  const pose = this.engine.xr.frame.getPose(plane.planeSpace, this.engine.xr.currentReferenceSpace);
  if (!pose) {
    o.active = false;
    return;
  }
  setXRRigidTransformLocal(o, pose.transform);
};
__publicField(PlaneDetection, "TypeName", "plane-detection");
__decorate6([
  property.material()
], PlaneDetection.prototype, "planeMaterial", void 0);
__decorate6([
  property.int()
], PlaneDetection.prototype, "collisionMask", void 0);

// node_modules/@wonderlandengine/components/dist/vrm.js
var VRM_ROLL_AXES = {
  X: [1, 0, 0],
  Y: [0, 1, 0],
  Z: [0, 0, 1]
};
var VRM_AIM_AXES = {
  PositiveX: [1, 0, 0],
  NegativeX: [-1, 0, 0],
  PositiveY: [0, 1, 0],
  NegativeY: [0, -1, 0],
  PositiveZ: [0, 0, 1],
  NegativeZ: [0, 0, -1]
};
var Vrm = class extends Component {
  /** Meta information about the VRM model */
  meta = null;
  /** The humanoid bones of the VRM model */
  bones = {
    /* Torso */
    hips: null,
    spine: null,
    chest: null,
    upperChest: null,
    neck: null,
    /* Head */
    head: null,
    leftEye: null,
    rightEye: null,
    jaw: null,
    /* Legs */
    leftUpperLeg: null,
    leftLowerLeg: null,
    leftFoot: null,
    leftToes: null,
    rightUpperLeg: null,
    rightLowerLeg: null,
    rightFoot: null,
    rightToes: null,
    /* Arms */
    leftShoulder: null,
    leftUpperArm: null,
    leftLowerArm: null,
    leftHand: null,
    rightShoulder: null,
    rightUpperArm: null,
    rightLowerArm: null,
    rightHand: null,
    /* Fingers */
    leftThumbMetacarpal: null,
    leftThumbProximal: null,
    leftThumbDistal: null,
    leftIndexProximal: null,
    leftIndexIntermediate: null,
    leftIndexDistal: null,
    leftMiddleProximal: null,
    leftMiddleIntermediate: null,
    leftMiddleDistal: null,
    leftRingProximal: null,
    leftRingIntermediate: null,
    leftRingDistal: null,
    leftLittleProximal: null,
    leftLittleIntermediate: null,
    leftLittleDistal: null,
    rightThumbMetacarpal: null,
    rightThumbProximal: null,
    rightThumbDistal: null,
    rightIndexProximal: null,
    rightIndexIntermediate: null,
    rightIndexDistal: null,
    rightMiddleProximal: null,
    rightMiddleIntermediate: null,
    rightMiddleDistal: null,
    rightRingProximal: null,
    rightRingIntermediate: null,
    rightRingDistal: null,
    rightLittleProximal: null,
    rightLittleIntermediate: null,
    rightLittleDistal: null
  };
  /** Rotations of the bones in the rest pose (T-pose) */
  restPose = {};
  /* All node constraints, ordered to deal with dependencies */
  _nodeConstraints = [];
  /* VRMC_springBone chains */
  _springChains = [];
  /* Spherical colliders for spring bones */
  _sphereColliders = [];
  /* Capsule shaped colliders for spring bones */
  _capsuleColliders = [];
  /* Indicates which meshes are rendered in first/third person views */
  _firstPersonAnnotations = [];
  /* Contains details for (bone type) lookAt behaviour */
  _lookAt = null;
  /* Whether or not the VRM component has been initialized with `initializeVrm` */
  _initialized = false;
  init() {
    this._tempV3 = vec3_exports.create();
    this._tempV3A = vec3_exports.create();
    this._tempV3B = vec3_exports.create();
    this._tempQuat = quat_exports.create();
    this._tempQuatA = quat_exports.create();
    this._tempQuatB = quat_exports.create();
    this._tempMat4A = mat4_exports.create();
    this._tempQuat2 = quat2_exports.create();
    this._tailToShape = vec3_exports.create();
    this._headToTail = vec3_exports.create();
    this._inertia = vec3_exports.create();
    this._stiffness = vec3_exports.create();
    this._external = vec3_exports.create();
    this._rightVector = vec3_exports.set(vec3_exports.create(), 1, 0, 0);
    this._upVector = vec3_exports.set(vec3_exports.create(), 0, 1, 0);
    this._forwardVector = vec3_exports.set(vec3_exports.create(), 0, 0, 1);
    this._identityQuat = quat_exports.identity(quat_exports.create());
    this._rad2deg = 180 / Math.PI;
  }
  start() {
    if (!this.src) {
      console.error("vrm: src property not set");
      return;
    }
    this.engine.scene.append(this.src, { loadGltfExtensions: true }).then(({ root, extensions }) => {
      root.children.forEach((child) => child.parent = this.object);
      this._initializeVrm(extensions);
      root.destroy();
    });
  }
  /**
   * Parses the VRM glTF extensions and initializes the vrm component.
   * @param {GLTFExtensions} extensions The glTF extensions for the VRM model
   */
  _initializeVrm(extensions) {
    if (this._initialized) {
      throw Error("VRM component has already been initialized");
    }
    const VRMC_vrm = extensions.root["VRMC_vrm"];
    if (!VRMC_vrm) {
      throw Error("Missing VRM extensions");
    }
    if (VRMC_vrm.specVersion !== "1.0") {
      throw Error(`Unsupported VRM version, only 1.0 is supported, but encountered '${VRMC_vrm.specVersion}'`);
    }
    this.meta = VRMC_vrm.meta;
    this._parseHumanoid(VRMC_vrm.humanoid, extensions);
    if (VRMC_vrm.firstPerson) {
      this._parseFirstPerson(VRMC_vrm.firstPerson, extensions);
    }
    if (VRMC_vrm.lookAt) {
      this._parseLookAt(VRMC_vrm.lookAt);
    }
    this._findAndParseNodeConstraints(extensions);
    const springBone = extensions.root["VRMC_springBone"];
    if (springBone) {
      this._parseAndInitializeSpringBones(springBone, extensions);
    }
    this._initialized = true;
  }
  _parseHumanoid(humanoid, extensions) {
    for (const boneName in humanoid.humanBones) {
      if (!(boneName in this.bones)) {
        console.warn(`Unrecognized bone '${boneName}'`);
        continue;
      }
      const node = humanoid.humanBones[boneName].node;
      const objectId = extensions.idMapping[node];
      this.bones[boneName] = this.engine.wrapObject(objectId);
      this.restPose[boneName] = quat_exports.copy(quat_exports.create(), this.bones[boneName].rotationLocal);
    }
  }
  _parseFirstPerson(firstPerson, extensions) {
    for (const meshAnnotation of firstPerson.meshAnnotations) {
      const annotation = {
        node: this.engine.wrapObject(extensions.idMapping[meshAnnotation.node]),
        firstPerson: true,
        thirdPerson: true
      };
      switch (meshAnnotation.type) {
        case "firstPersonOnly":
          annotation.thirdPerson = false;
          break;
        case "thirdPersonOnly":
          annotation.firstPerson = false;
          break;
        case "both":
          break;
        case "auto":
          console.warn("First person mesh annotation type 'auto' is not supported, treating as 'both'!");
          break;
        default:
          console.error(`Invalid mesh annotation type '${meshAnnotation.type}'`);
          break;
      }
      this._firstPersonAnnotations.push(annotation);
    }
  }
  _parseLookAt(lookAt2) {
    if (lookAt2.type !== "bone") {
      console.warn(`Unsupported lookAt type '${lookAt2.type}', only 'bone' is supported`);
      return;
    }
    const parseRangeMap = (rangeMap) => {
      return {
        inputMaxValue: rangeMap.inputMaxValue,
        outputScale: rangeMap.outputScale
      };
    };
    this._lookAt = {
      offsetFromHeadBone: lookAt2.offsetFromHeadBone || [0, 0, 0],
      horizontalInner: parseRangeMap(lookAt2.rangeMapHorizontalInner),
      horizontalOuter: parseRangeMap(lookAt2.rangeMapHorizontalOuter),
      verticalDown: parseRangeMap(lookAt2.rangeMapVerticalDown),
      verticalUp: parseRangeMap(lookAt2.rangeMapVerticalUp)
    };
  }
  _findAndParseNodeConstraints(extensions) {
    const traverse = (object) => {
      const nodeExtensions = extensions.node[object.objectId];
      if (nodeExtensions && "VRMC_node_constraint" in nodeExtensions) {
        const nodeConstraintExtension = nodeExtensions["VRMC_node_constraint"];
        const constraint = nodeConstraintExtension.constraint;
        let type, axis;
        if ("roll" in constraint) {
          type = "roll";
          axis = VRM_ROLL_AXES[constraint.roll.rollAxis];
        } else if ("aim" in constraint) {
          type = "aim";
          axis = VRM_AIM_AXES[constraint.aim.aimAxis];
        } else if ("rotation" in constraint) {
          type = "rotation";
        }
        if (type) {
          const source = this.engine.wrapObject(extensions.idMapping[constraint[type].source]);
          this._nodeConstraints.push({
            type,
            source,
            destination: object,
            axis,
            weight: constraint[type].weight,
            /* Rest pose */
            destinationRestLocalRotation: quat_exports.copy(quat_exports.create(), object.rotationLocal),
            sourceRestLocalRotation: quat_exports.copy(quat_exports.create(), source.rotationLocal),
            sourceRestLocalRotationInv: quat_exports.invert(quat_exports.create(), source.rotationLocal)
          });
        } else {
          console.warn("Unrecognized or invalid VRMC_node_constraint, ignoring it");
        }
      }
      for (const child of object.children) {
        traverse(child);
      }
    };
    traverse(this.object);
  }
  _parseAndInitializeSpringBones(springBone, extensions) {
    const colliders = (springBone.colliders || []).map((collider, i) => {
      const shapeType = "capsule" in collider.shape ? "capsule" : "sphere";
      return {
        id: i,
        object: this.engine.wrapObject(extensions.idMapping[collider.node]),
        shape: {
          isCapsule: shapeType === "capsule",
          radius: collider.shape[shapeType].radius,
          offset: collider.shape[shapeType].offset,
          tail: collider.shape[shapeType].tail
        },
        cache: {
          head: vec3_exports.create(),
          tail: vec3_exports.create()
        }
      };
    });
    this._sphereColliders = colliders.filter((c) => !c.shape.isCapsule);
    this._capsuleColliders = colliders.filter((c) => c.shape.isCapsule);
    const colliderGroups = (springBone.colliderGroups || []).map((group) => ({
      name: group.name,
      colliders: group.colliders.map((c) => colliders[c])
    }));
    for (const spring of springBone.springs) {
      const joints = [];
      for (const joint of spring.joints) {
        const springJoint = {
          hitRadius: 0,
          stiffness: 1,
          gravityPower: 0,
          gravityDir: [0, -1, 0],
          dragForce: 0.5,
          node: null,
          state: null
        };
        Object.assign(springJoint, joint);
        springJoint.node = this.engine.wrapObject(extensions.idMapping[springJoint.node]);
        joints.push(springJoint);
      }
      const springChainColliders = (spring.colliderGroups || []).flatMap((cg) => colliderGroups[cg].colliders);
      this._springChains.push({
        name: spring.name,
        center: spring.center ? this.engine.wrapObject(extensions.idMapping[spring.center]) : null,
        joints,
        sphereColliders: springChainColliders.filter((c) => !c.shape.isCapsule),
        capsuleColliders: springChainColliders.filter((c) => c.shape.isCapsule)
      });
    }
    for (const springChain of this._springChains) {
      for (let i = 0; i < springChain.joints.length - 1; ++i) {
        const springBoneJoint = springChain.joints[i];
        const childSpringBoneJoint = springChain.joints[i + 1];
        const springBonePosition = springBoneJoint.node.getTranslationWorld(vec3_exports.create());
        const childSpringBonePosition = childSpringBoneJoint.node.getTranslationWorld(vec3_exports.create());
        const boneDirection = vec3_exports.subtract(this._tempV3A, springBonePosition, childSpringBonePosition);
        const state = {
          prevTail: childSpringBonePosition,
          currentTail: vec3_exports.copy(vec3_exports.create(), childSpringBonePosition),
          initialLocalRotation: quat_exports.copy(quat_exports.create(), springBoneJoint.node.rotationLocal),
          initialLocalTransformInvert: quat2_exports.invert(quat2_exports.create(), springBoneJoint.node.transformLocal),
          boneAxis: vec3_exports.normalize(vec3_exports.create(), childSpringBoneJoint.node.getTranslationLocal(this._tempV3)),
          /* Ensure bone length is at least 1cm to avoid jittery behaviour from zero-length bones */
          boneLength: Math.max(0.01, vec3_exports.length(boneDirection)),
          /* Tail positions in center space, if needed */
          prevTailCenter: null,
          currentTailCenter: null
        };
        if (springChain.center) {
          state.prevTailCenter = springChain.center.transformPointInverseWorld(vec3_exports.create(), childSpringBonePosition);
          state.currentTailCenter = vec3_exports.copy(vec3_exports.create(), childSpringBonePosition);
        }
        springBoneJoint.state = state;
      }
    }
  }
  update(dt) {
    if (!this._initialized) {
      return;
    }
    this._resolveLookAt();
    this._resolveConstraints();
    this._updateSpringBones(dt);
  }
  _rangeMap(rangeMap, input) {
    const maxValue = rangeMap.inputMaxValue;
    const outputScale = rangeMap.outputScale;
    return Math.min(input, maxValue) / maxValue * outputScale;
  }
  _resolveLookAt() {
    if (!this._lookAt || !this.lookAtTarget) {
      return;
    }
    const lookAtSource = this.bones.head.transformPointWorld(this._tempV3A, this._lookAt.offsetFromHeadBone);
    const lookAtTarget = this.lookAtTarget.getTranslationWorld(this._tempV3B);
    const lookAtDirection = vec3_exports.sub(this._tempV3A, lookAtTarget, lookAtSource);
    vec3_exports.normalize(lookAtDirection, lookAtDirection);
    this.bones.head.parent.transformVectorInverseWorld(lookAtDirection);
    const z = vec3_exports.dot(lookAtDirection, this._forwardVector);
    const x = vec3_exports.dot(lookAtDirection, this._rightVector);
    const yaw = Math.atan2(x, z) * this._rad2deg;
    const xz = Math.sqrt(x * x + z * z);
    const y = vec3_exports.dot(lookAtDirection, this._upVector);
    let pitch = Math.atan2(-y, xz) * this._rad2deg;
    if (pitch > 0) {
      pitch = this._rangeMap(this._lookAt.verticalDown, pitch);
    } else {
      pitch = -this._rangeMap(this._lookAt.verticalUp, -pitch);
    }
    if (this.bones.leftEye) {
      let yawLeft = yaw;
      if (yawLeft > 0) {
        yawLeft = this._rangeMap(this._lookAt.horizontalInner, yawLeft);
      } else {
        yawLeft = -this._rangeMap(this._lookAt.horizontalOuter, -yawLeft);
      }
      const eyeRotation = quat_exports.fromEuler(this._tempQuatA, pitch, yawLeft, 0);
      this.bones.leftEye.rotationLocal = quat_exports.multiply(eyeRotation, this.restPose.leftEye, eyeRotation);
    }
    if (this.bones.rightEye) {
      let yawRight = yaw;
      if (yawRight > 0) {
        yawRight = this._rangeMap(this._lookAt.horizontalOuter, yawRight);
      } else {
        yawRight = -this._rangeMap(this._lookAt.horizontalInner, -yawRight);
      }
      const eyeRotation = quat_exports.fromEuler(this._tempQuatA, pitch, yawRight, 0);
      this.bones.rightEye.rotationLocal = quat_exports.multiply(eyeRotation, this.restPose.rightEye, eyeRotation);
    }
  }
  _resolveConstraints() {
    for (const nodeConstraint of this._nodeConstraints) {
      this._resolveConstraint(nodeConstraint);
    }
  }
  _resolveConstraint(nodeConstraint) {
    const dstRestQuat = nodeConstraint.destinationRestLocalRotation;
    const srcRestQuatInv = nodeConstraint.sourceRestLocalRotationInv;
    const targetQuat = quat_exports.identity(this._tempQuatA);
    switch (nodeConstraint.type) {
      case "roll":
        {
          const deltaSrcQuat = quat_exports.multiply(this._tempQuatA, srcRestQuatInv, nodeConstraint.source.rotationLocal);
          const deltaSrcQuatInParent = quat_exports.multiply(this._tempQuatA, nodeConstraint.sourceRestLocalRotation, deltaSrcQuat);
          quat_exports.mul(deltaSrcQuatInParent, deltaSrcQuatInParent, srcRestQuatInv);
          const dstRestQuatInv = quat_exports.invert(this._tempQuatB, dstRestQuat);
          const deltaSrcQuatInDst = quat_exports.multiply(this._tempQuatB, dstRestQuatInv, deltaSrcQuatInParent);
          quat_exports.multiply(deltaSrcQuatInDst, deltaSrcQuatInDst, dstRestQuat);
          const toVec = vec3_exports.transformQuat(this._tempV3A, nodeConstraint.axis, deltaSrcQuatInDst);
          const fromToQuat = quat_exports.rotationTo(this._tempQuatA, nodeConstraint.axis, toVec);
          quat_exports.mul(targetQuat, dstRestQuat, quat_exports.invert(this._tempQuat, fromToQuat));
          quat_exports.mul(targetQuat, targetQuat, deltaSrcQuatInDst);
        }
        break;
      case "aim":
        {
          const dstParentWorldQuat = nodeConstraint.destination.parent.rotationWorld;
          const fromVec = vec3_exports.transformQuat(this._tempV3A, nodeConstraint.axis, dstRestQuat);
          vec3_exports.transformQuat(fromVec, fromVec, dstParentWorldQuat);
          const toVec = nodeConstraint.source.getTranslationWorld(this._tempV3B);
          vec3_exports.sub(toVec, toVec, nodeConstraint.destination.getTranslationWorld(this._tempV3));
          vec3_exports.normalize(toVec, toVec);
          const fromToQuat = quat_exports.rotationTo(this._tempQuatA, fromVec, toVec);
          quat_exports.mul(targetQuat, quat_exports.invert(this._tempQuat, dstParentWorldQuat), fromToQuat);
          quat_exports.mul(targetQuat, targetQuat, dstParentWorldQuat);
          quat_exports.mul(targetQuat, targetQuat, dstRestQuat);
        }
        break;
      case "rotation":
        {
          const srcDeltaQuat = quat_exports.mul(targetQuat, srcRestQuatInv, nodeConstraint.source.rotationLocal);
          quat_exports.mul(targetQuat, dstRestQuat, srcDeltaQuat);
        }
        break;
    }
    quat_exports.slerp(targetQuat, dstRestQuat, targetQuat, nodeConstraint.weight);
    nodeConstraint.destination.rotationLocal = targetQuat;
  }
  _updateSpringBones(dt) {
    this._sphereColliders.forEach(({ object, shape, cache }) => {
      const offset2 = vec3_exports.copy(cache.head, shape.offset);
      object.transformVectorWorld(offset2);
      vec3_exports.add(cache.head, object.getTranslationWorld(this._tempV3), offset2);
    });
    this._capsuleColliders.forEach(({ object, shape, cache }) => {
      const shapeCenter = object.getTranslationWorld(this._tempV3A);
      const headOffset = vec3_exports.copy(cache.head, shape.offset);
      object.transformVectorWorld(headOffset);
      vec3_exports.add(cache.head, shapeCenter, headOffset);
      const tailOffset = vec3_exports.copy(cache.tail, shape.tail);
      object.transformVectorWorld(tailOffset);
      vec3_exports.add(cache.tail, shapeCenter, tailOffset);
    });
    this._springChains.forEach((springChain) => {
      for (let i = 0; i < springChain.joints.length - 1; ++i) {
        const joint = springChain.joints[i];
        const parentWorldRotation = joint.node.parent ? joint.node.parent.rotationWorld : this._identityQuat;
        const inertia = this._inertia;
        if (springChain.center) {
          vec3_exports.sub(inertia, joint.state.currentTailCenter, joint.state.prevTailCenter);
          springChain.center.transformVectorWorld(inertia);
        } else {
          vec3_exports.sub(inertia, joint.state.currentTail, joint.state.prevTail);
        }
        vec3_exports.scale(inertia, inertia, 1 - joint.dragForce);
        const stiffness = vec3_exports.copy(this._stiffness, joint.state.boneAxis);
        vec3_exports.transformQuat(stiffness, stiffness, joint.state.initialLocalRotation);
        vec3_exports.transformQuat(stiffness, stiffness, parentWorldRotation);
        vec3_exports.scale(stiffness, stiffness, dt * joint.stiffness);
        const external = vec3_exports.scale(this._external, joint.gravityDir, dt * joint.gravityPower);
        const nextTail = vec3_exports.copy(this._tempV3A, joint.state.currentTail);
        vec3_exports.add(nextTail, nextTail, inertia);
        vec3_exports.add(nextTail, nextTail, stiffness);
        vec3_exports.add(nextTail, nextTail, external);
        const worldPosition = joint.node.getTranslationWorld(this._tempV3B);
        vec3_exports.sub(nextTail, nextTail, worldPosition);
        vec3_exports.normalize(nextTail, nextTail);
        vec3_exports.scaleAndAdd(nextTail, worldPosition, nextTail, joint.state.boneLength);
        for (const { shape, cache } of springChain.sphereColliders) {
          let tailToShape = this._tailToShape;
          const sphereCenter = cache.head;
          tailToShape = vec3_exports.sub(tailToShape, nextTail, sphereCenter);
          const radius = shape.radius + joint.hitRadius;
          const dist2 = vec3_exports.length(tailToShape) - radius;
          if (dist2 < 0) {
            vec3_exports.normalize(tailToShape, tailToShape);
            vec3_exports.scaleAndAdd(nextTail, nextTail, tailToShape, -dist2);
            vec3_exports.sub(nextTail, nextTail, worldPosition);
            vec3_exports.normalize(nextTail, nextTail);
            vec3_exports.scaleAndAdd(nextTail, worldPosition, nextTail, joint.state.boneLength);
          }
        }
        for (const { shape, cache } of springChain.capsuleColliders) {
          let tailToShape = this._tailToShape;
          const head = cache.head;
          const tail = cache.tail;
          tailToShape = vec3_exports.sub(tailToShape, nextTail, head);
          const headToTail = vec3_exports.sub(this._headToTail, tail, head);
          const dot7 = vec3_exports.dot(headToTail, tailToShape);
          if (vec3_exports.squaredLength(headToTail) <= dot7) {
            vec3_exports.sub(tailToShape, nextTail, tail);
          } else if (dot7 > 0) {
            vec3_exports.scale(headToTail, headToTail, dot7 / vec3_exports.squaredLength(headToTail));
            vec3_exports.sub(tailToShape, tailToShape, headToTail);
          }
          const radius = shape.radius + joint.hitRadius;
          const dist2 = vec3_exports.length(tailToShape) - radius;
          if (dist2 < 0) {
            vec3_exports.normalize(tailToShape, tailToShape);
            vec3_exports.scaleAndAdd(nextTail, nextTail, tailToShape, -dist2);
            vec3_exports.sub(nextTail, nextTail, worldPosition);
            vec3_exports.normalize(nextTail, nextTail);
            vec3_exports.scaleAndAdd(nextTail, worldPosition, nextTail, joint.state.boneLength);
          }
        }
        vec3_exports.copy(joint.state.prevTail, joint.state.currentTail);
        vec3_exports.copy(joint.state.currentTail, nextTail);
        if (springChain.center) {
          vec3_exports.copy(joint.state.prevTailCenter, joint.state.currentTailCenter);
          vec3_exports.copy(joint.state.currentTailCenter, nextTail);
          springChain.center.transformPointInverseWorld(joint.state.currentTailCenter);
        }
        joint.node.parent.transformPointInverseWorld(nextTail);
        const nextTailDualQuat = quat2_exports.fromTranslation(this._tempQuat2, nextTail);
        quat2_exports.multiply(nextTailDualQuat, joint.state.initialLocalTransformInvert, nextTailDualQuat);
        quat2_exports.getTranslation(nextTail, nextTailDualQuat);
        vec3_exports.normalize(nextTail, nextTail);
        const jointRotation = quat_exports.rotationTo(this._tempQuatA, joint.state.boneAxis, nextTail);
        joint.node.rotationLocal = quat_exports.mul(this._tempQuatA, joint.state.initialLocalRotation, jointRotation);
      }
    });
  }
  /**
   * @param {boolean} firstPerson Whether the model should render for first person or third person views
   */
  set firstPerson(firstPerson) {
    this._firstPersonAnnotations.forEach((annotation) => {
      const visible = firstPerson == annotation.firstPerson || firstPerson != annotation.thirdPerson;
      annotation.node.getComponents("mesh").forEach((mesh) => {
        mesh.active = visible;
      });
    });
  }
};
__publicField(Vrm, "TypeName", "vrm");
__publicField(Vrm, "Properties", {
  /** URL to a VRM file to load */
  src: { type: Type.String },
  /** Object the VRM is looking at */
  lookAtTarget: { type: Type.Object }
});

// node_modules/@wonderlandengine/components/dist/wasd-controls.js
var WasdControlsComponent = class extends Component {
  init() {
    this.up = false;
    this.right = false;
    this.down = false;
    this.left = false;
    window.addEventListener("keydown", this.press.bind(this));
    window.addEventListener("keyup", this.release.bind(this));
  }
  start() {
    this.headObject = this.headObject || this.object;
  }
  update() {
    let direction2 = [0, 0, 0];
    if (this.up)
      direction2[2] -= 1;
    if (this.down)
      direction2[2] += 1;
    if (this.left)
      direction2[0] -= 1;
    if (this.right)
      direction2[0] += 1;
    vec3_exports.normalize(direction2, direction2);
    direction2[0] *= this.speed;
    direction2[2] *= this.speed;
    vec3_exports.transformQuat(direction2, direction2, this.headObject.transformWorld);
    this.object.translate(direction2);
  }
  press(e) {
    if (e.keyCode === 38 || e.keyCode === 87 || e.keyCode === 90) {
      this.up = true;
    } else if (e.keyCode === 39 || e.keyCode === 68) {
      this.right = true;
    } else if (e.keyCode === 40 || e.keyCode === 83) {
      this.down = true;
    } else if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
      this.left = true;
    }
  }
  release(e) {
    if (e.keyCode === 38 || e.keyCode === 87 || e.keyCode === 90) {
      this.up = false;
    } else if (e.keyCode === 39 || e.keyCode === 68) {
      this.right = false;
    } else if (e.keyCode === 40 || e.keyCode === 83) {
      this.down = false;
    } else if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
      this.left = false;
    }
  }
};
__publicField(WasdControlsComponent, "TypeName", "wasd-controls");
__publicField(WasdControlsComponent, "Properties", {
  /** Movement speed in m/s. */
  speed: { type: Type.Float, default: 0.1 },
  /** Object of which the orientation is used to determine forward direction */
  headObject: { type: Type.Object }
});

// ../node_modules/@wonderlandengine/api/dist/property.js
var Type2;
(function(Type3) {
  Type3[Type3["Native"] = 1] = "Native";
  Type3[Type3["Bool"] = 2] = "Bool";
  Type3[Type3["Int"] = 4] = "Int";
  Type3[Type3["Float"] = 8] = "Float";
  Type3[Type3["String"] = 16] = "String";
  Type3[Type3["Enum"] = 32] = "Enum";
  Type3[Type3["Object"] = 64] = "Object";
  Type3[Type3["Mesh"] = 128] = "Mesh";
  Type3[Type3["Texture"] = 256] = "Texture";
  Type3[Type3["Material"] = 512] = "Material";
  Type3[Type3["Animation"] = 1024] = "Animation";
  Type3[Type3["Skin"] = 2048] = "Skin";
  Type3[Type3["Color"] = 4096] = "Color";
})(Type2 || (Type2 = {}));
var Property2 = {
  /**
   * Create an boolean property.
   *
   * @param defaultValue The default value. If not provided, defaults to `false`.
   */
  bool(defaultValue = false) {
    return { type: Type2.Bool, default: defaultValue };
  },
  /**
   * Create an integer property.
   *
   * @param defaultValue The default value. If not provided, defaults to `0`.
   */
  int(defaultValue = 0) {
    return { type: Type2.Int, default: defaultValue };
  },
  /**
   * Create an float property.
   *
   * @param defaultValue The default value. If not provided, defaults to `0.0`.
   */
  float(defaultValue = 0) {
    return { type: Type2.Float, default: defaultValue };
  },
  /**
   * Create an string property.
   *
   * @param defaultValue The default value. If not provided, defaults to `''`.
   */
  string(defaultValue = "") {
    return { type: Type2.String, default: defaultValue };
  },
  /**
   * Create an enumeration property.
   *
   * @param values The list of values.
   * @param defaultValue The default value. Can be a string or an index into
   *     `values`. If not provided, defaults to the first element.
   */
  enum(values, defaultValue) {
    return { type: Type2.Enum, values, default: defaultValue };
  },
  /** Create an {@link Object3D} reference property. */
  object() {
    return { type: Type2.Object, default: null };
  },
  /** Create a {@link Mesh} reference property. */
  mesh() {
    return { type: Type2.Mesh, default: null };
  },
  /** Create a {@link Texture} reference property. */
  texture() {
    return { type: Type2.Texture, default: null };
  },
  /** Create a {@link Material} reference property. */
  material() {
    return { type: Type2.Material, default: null };
  },
  /** Create an {@link Animation} reference property. */
  animation() {
    return { type: Type2.Animation, default: null };
  },
  /** Create a {@link Skin} reference property. */
  skin() {
    return { type: Type2.Skin, default: null };
  },
  /**
   * Create a color property.
   *
   * @param r The red component, in the range [0; 1].
   * @param g The green component, in the range [0; 1].
   * @param b The blue component, in the range [0; 1].
   * @param a The alpha component, in the range [0; 1].
   */
  color(r = 0, g = 0, b = 0, a = 1) {
    return { type: Type2.Color, default: [r, g, b, a] };
  }
};

// ../node_modules/@wonderlandengine/api/dist/decorators.js
function propertyDecorator2(data) {
  return function(target, propertyKey) {
    const ctor = target.constructor;
    ctor.Properties = ctor.Properties ?? {};
    ctor.Properties[propertyKey] = data;
  };
}
function enumerable2() {
  return function(_, __, descriptor) {
    descriptor.enumerable = true;
  };
}
function nativeProperty2() {
  return function(target, propertyKey, descriptor) {
    enumerable2()(target, propertyKey, descriptor);
    propertyDecorator2({ type: Type2.Native })(target, propertyKey);
  };
}
var property2 = {};
for (const name in Property2) {
  property2[name] = (...args) => {
    const functor = Property2[name];
    return propertyDecorator2(functor(...args));
  };
}

// ../node_modules/@wonderlandengine/api/dist/utils/object.js
function isNumber2(value) {
  if (value === null || value === void 0)
    return false;
  return typeof value === "number" || value.constructor === Number;
}

// ../node_modules/@wonderlandengine/api/dist/wonderland.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Collider2;
(function(Collider3) {
  Collider3[Collider3["Sphere"] = 0] = "Sphere";
  Collider3[Collider3["AxisAlignedBox"] = 1] = "AxisAlignedBox";
  Collider3[Collider3["Box"] = 2] = "Box";
})(Collider2 || (Collider2 = {}));
var Alignment2;
(function(Alignment3) {
  Alignment3[Alignment3["Left"] = 0] = "Left";
  Alignment3[Alignment3["Center"] = 1] = "Center";
  Alignment3[Alignment3["Right"] = 2] = "Right";
})(Alignment2 || (Alignment2 = {}));
var Justification2;
(function(Justification3) {
  Justification3[Justification3["Line"] = 0] = "Line";
  Justification3[Justification3["Middle"] = 1] = "Middle";
  Justification3[Justification3["Top"] = 2] = "Top";
  Justification3[Justification3["Bottom"] = 3] = "Bottom";
})(Justification2 || (Justification2 = {}));
var TextEffect2;
(function(TextEffect3) {
  TextEffect3[TextEffect3["None"] = 0] = "None";
  TextEffect3[TextEffect3["Outline"] = 1] = "Outline";
})(TextEffect2 || (TextEffect2 = {}));
var InputType2;
(function(InputType3) {
  InputType3[InputType3["Head"] = 0] = "Head";
  InputType3[InputType3["EyeLeft"] = 1] = "EyeLeft";
  InputType3[InputType3["EyeRight"] = 2] = "EyeRight";
  InputType3[InputType3["ControllerLeft"] = 3] = "ControllerLeft";
  InputType3[InputType3["ControllerRight"] = 4] = "ControllerRight";
  InputType3[InputType3["RayLeft"] = 5] = "RayLeft";
  InputType3[InputType3["RayRight"] = 6] = "RayRight";
})(InputType2 || (InputType2 = {}));
var LightType2;
(function(LightType3) {
  LightType3[LightType3["Point"] = 0] = "Point";
  LightType3[LightType3["Spot"] = 1] = "Spot";
  LightType3[LightType3["Sun"] = 2] = "Sun";
})(LightType2 || (LightType2 = {}));
var AnimationState2;
(function(AnimationState3) {
  AnimationState3[AnimationState3["Playing"] = 0] = "Playing";
  AnimationState3[AnimationState3["Paused"] = 1] = "Paused";
  AnimationState3[AnimationState3["Stopped"] = 2] = "Stopped";
})(AnimationState2 || (AnimationState2 = {}));
var ForceMode2;
(function(ForceMode3) {
  ForceMode3[ForceMode3["Force"] = 0] = "Force";
  ForceMode3[ForceMode3["Impulse"] = 1] = "Impulse";
  ForceMode3[ForceMode3["VelocityChange"] = 2] = "VelocityChange";
  ForceMode3[ForceMode3["Acceleration"] = 3] = "Acceleration";
})(ForceMode2 || (ForceMode2 = {}));
var CollisionEventType2;
(function(CollisionEventType3) {
  CollisionEventType3[CollisionEventType3["Touch"] = 0] = "Touch";
  CollisionEventType3[CollisionEventType3["TouchLost"] = 1] = "TouchLost";
  CollisionEventType3[CollisionEventType3["TriggerTouch"] = 2] = "TriggerTouch";
  CollisionEventType3[CollisionEventType3["TriggerTouchLost"] = 3] = "TriggerTouchLost";
})(CollisionEventType2 || (CollisionEventType2 = {}));
var Shape2;
(function(Shape3) {
  Shape3[Shape3["None"] = 0] = "None";
  Shape3[Shape3["Sphere"] = 1] = "Sphere";
  Shape3[Shape3["Capsule"] = 2] = "Capsule";
  Shape3[Shape3["Box"] = 3] = "Box";
  Shape3[Shape3["Plane"] = 4] = "Plane";
  Shape3[Shape3["ConvexMesh"] = 5] = "ConvexMesh";
  Shape3[Shape3["TriangleMesh"] = 6] = "TriangleMesh";
})(Shape2 || (Shape2 = {}));
var MeshAttribute2;
(function(MeshAttribute3) {
  MeshAttribute3[MeshAttribute3["Position"] = 0] = "Position";
  MeshAttribute3[MeshAttribute3["Tangent"] = 1] = "Tangent";
  MeshAttribute3[MeshAttribute3["Normal"] = 2] = "Normal";
  MeshAttribute3[MeshAttribute3["TextureCoordinate"] = 3] = "TextureCoordinate";
  MeshAttribute3[MeshAttribute3["Color"] = 4] = "Color";
  MeshAttribute3[MeshAttribute3["JointId"] = 5] = "JointId";
  MeshAttribute3[MeshAttribute3["JointWeight"] = 6] = "JointWeight";
})(MeshAttribute2 || (MeshAttribute2 = {}));
var MaterialParamType2;
(function(MaterialParamType3) {
  MaterialParamType3[MaterialParamType3["UnsignedInt"] = 0] = "UnsignedInt";
  MaterialParamType3[MaterialParamType3["Int"] = 1] = "Int";
  MaterialParamType3[MaterialParamType3["Float"] = 2] = "Float";
  MaterialParamType3[MaterialParamType3["Sampler"] = 3] = "Sampler";
  MaterialParamType3[MaterialParamType3["Font"] = 4] = "Font";
})(MaterialParamType2 || (MaterialParamType2 = {}));
function isMeshShape2(shape) {
  return shape === Shape2.ConvexMesh || shape === Shape2.TriangleMesh;
}
var Component2 = class {
  /** Manager index. @hidden */
  _manager;
  /** Instance index. @hidden */
  _id;
  /**
   * Object containing this object.
   *
   * **Note**: This is cached for faster retrieval.
   *
   * @hidden
   */
  _object;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new instance
   *
   * @param engine The engine instance.
   * @param manager Index of the manager.
   * @param id WASM component instance index.
   *
   * @hidden
   */
  constructor(engine2, manager = -1, id = -1) {
    this._engine = engine2;
    this._manager = manager;
    this._id = id;
    this._object = null;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /** The name of this component's type */
  get type() {
    const ctor = this.constructor;
    return ctor.TypeName ?? this._engine.wasm._typeNameFor(this._manager);
  }
  /** The object this component is attached to. */
  get object() {
    if (!this._object) {
      const objectId = this._engine.wasm._wl_component_get_object(this._manager, this._id);
      this._object = this._engine.wrapObject(objectId);
    }
    return this._object;
  }
  /**
   * Set whether this component is active.
   *
   * Activating/deactivating a component comes at a small cost of reordering
   * components in the respective component manager. This function therefore
   * is not a trivial assignment.
   *
   * Does nothing if the component is already activated/deactivated.
   *
   * @param active New active state.
   */
  set active(active) {
    this._engine.wasm._wl_component_setActive(this._manager, this._id, active);
  }
  /**
   * Whether this component is active
   */
  get active() {
    return this._engine.wasm._wl_component_isActive(this._manager, this._id) != 0;
  }
  /**
   * Remove this component from its objects and destroy it.
   *
   * It is best practice to set the component to `null` after,
   * to ensure it does not get used later.
   *
   * ```js
   *    c.destroy();
   *    c = null;
   * ```
   * @since 0.9.0
   */
  destroy() {
    this._engine.wasm._wl_component_remove(this._manager, this._id);
    this._manager = -1;
    this._id = -1;
  }
  /**
   * Checks equality by comparing whether the wrapped native component ids
   * and component manager types are equal.
   *
   * @param otherComponent Component to check equality with.
   * @returns Whether this component equals the given component.
   */
  equals(otherComponent) {
    if (!otherComponent)
      return false;
    return this._manager == otherComponent._manager && this._id == otherComponent._id;
  }
};
/**
 * Unique identifier for this component class.
 *
 * This is used to register, add, and retrieve components of a given type.
 */
__publicField(Component2, "TypeName");
/**
 * Properties of this component class.
 *
 * Properties are public attributes that can be configured via the
 * Wonderland Editor.
 *
 * Example:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 * class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myBoolean: { type: Type.Boolean, default: false },
 *         myFloat: { type: Type.Float, default: false },
 *         myTexture: { type: Type.Texture, default: null },
 *     };
 * }
 * ```
 *
 * Properties are automatically added to each component instance, and are
 * accessible like any JS attribute:
 *
 * ```js
 * // Creates a new component and set each properties value:
 * const myComponent = object.addComponent(MyComponent, {
 *     myBoolean: true,
 *     myFloat: 42.0,
 *     myTexture: null
 * });
 *
 * // You can also override the properties on the instance:
 * myComponent.myBoolean = false;
 * myComponent.myFloat = -42.0;
 * ```
 */
__publicField(Component2, "Properties");
/**
 * This was never released in an official version, we are keeping it
 * to easy transition to the new API.
 *
 * @deprecated Use {@link Component.onRegister} instead.
 * @hidden
 */
__publicField(Component2, "Dependencies");
/**
 * Called when this component class is registered.
 *
 * @example
 *
 * This callback can be used to register dependencies of a component,
 * e.g., component classes that need to be registered in order to add
 * them at runtime with {@link Object3D.addComponent}, independent of whether
 * they are used in the editor.
 *
 * ```js
 * class Spawner extends Component {
 *     static TypeName = 'spawner';
 *
 *     static onRegister() {
 *         engine.registerComponent(SpawnedComponent);
 *     }
 *
 *     // You can now use addComponent with SpawnedComponent
 * }
 * ```
 *
 * @example
 *
 * This callback can be used to register different implementations of a
 * component depending on client features or API versions.
 *
 * ```js
 * // Properties need to be the same for all implementations!
 * const SharedProperties = {};
 *
 * class Anchor extends Component {
 *     static TypeName = 'spawner';
 *     static Properties = SharedProperties;
 *
 *     static onRegister() {
 *         if(navigator.xr === undefined) {
 *             /* WebXR unsupported, keep this dummy component *\/
 *             return;
 *         }
 *         /* WebXR supported! Override already registered dummy implementation
 *          * with one depending on hit-test API support *\/
 *         engine.registerComponent(window.HitTestSource === undefined ?
 *             AnchorWithoutHitTest : AnchorWithHitTest);
 *     }
 *
 *     // This one implements no functions
 * }
 * ```
 */
__publicField(Component2, "onRegister");
var _CollisionComponent2 = class extends Component2 {
  /** Collision component collider */
  get collider() {
    return this._engine.wasm._wl_collision_component_get_collider(this._id);
  }
  /**
   * Set collision component collider.
   *
   * @param collider Collider of the collision component.
   */
  set collider(collider) {
    this._engine.wasm._wl_collision_component_set_collider(this._id, collider);
  }
  /**
   * Collision component extents.
   *
   * If {@link collider} returns {@link Collider.Sphere}, only the first
   * component of the returned vector is used.
   */
  get extents() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_collision_component_get_extents(this._id), 3);
  }
  /**
   * Set collision component extents.
   *
   * If {@link collider} returns {@link Collider.Sphere}, only the first
   * component of the passed vector is used.
   *
   * Example:
   *
   * ```js
   * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
   * collision.extent = [1, 2, 3];
   * ```
   *
   * @param extents Extents of the collision component, expects a
   *      3 component array.
   */
  set extents(extents) {
    this.extents.set(extents);
  }
  /**
   * Collision component group.
   *
   * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
   * or the group in {@link Scene#rayCast}.
   *
   * Colliders that have no common groups will not overlap with each other. If a collider
   * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
   *
   * Each bit represents belonging to a group, see example.
   *
   * ```js
   *    // c belongs to group 2
   *    c.group = (1 << 2);
   *
   *    // c belongs to group 0
   *    c.group = (1 << 0);
   *
   *    // c belongs to group 0 *and* 2
   *    c.group = (1 << 0) | (1 << 2);
   *
   *    (c.group & (1 << 2)) != 0; // true
   *    (c.group & (1 << 7)) != 0; // false
   * ```
   */
  get group() {
    return this._engine.wasm._wl_collision_component_get_group(this._id);
  }
  /**
   * Set collision component group.
   *
   * @param group Group mask of the collision component.
   */
  set group(group) {
    this._engine.wasm._wl_collision_component_set_group(this._id, group);
  }
  /**
   * Query overlapping objects.
   *
   * Usage:
   *
   * ```js
   * const collision = object.getComponent('collision');
   * const overlaps = collision.queryOverlaps();
   * for(const otherCollision of overlaps) {
   *     const otherObject = otherCollision.object;
   *     console.log(`Collision with object ${otherObject.objectId}`);
   * }
   * ```
   *
   * @returns Collision components overlapping this collider.
   */
  queryOverlaps() {
    const count = this._engine.wasm._wl_collision_component_query_overlaps(this._id, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
    const overlaps = new Array(count);
    for (let i = 0; i < count; ++i) {
      overlaps[i] = new _CollisionComponent2(this._engine, this._manager, this._engine.wasm._tempMemUint16[i]);
    }
    return overlaps;
  }
};
var CollisionComponent2 = _CollisionComponent2;
/** @override */
__publicField(CollisionComponent2, "TypeName", "collision");
__decorate7([
  nativeProperty2()
], CollisionComponent2.prototype, "collider", null);
__decorate7([
  nativeProperty2()
], CollisionComponent2.prototype, "extents", null);
__decorate7([
  nativeProperty2()
], CollisionComponent2.prototype, "group", null);
var TextComponent2 = class extends Component2 {
  /** Text component alignment. */
  get alignment() {
    return this._engine.wasm._wl_text_component_get_horizontal_alignment(this._id);
  }
  /**
   * Set text component alignment.
   *
   * @param alignment Alignment for the text component.
   */
  set alignment(alignment) {
    this._engine.wasm._wl_text_component_set_horizontal_alignment(this._id, alignment);
  }
  /** Text component justification. */
  get justification() {
    return this._engine.wasm._wl_text_component_get_vertical_alignment(this._id);
  }
  /**
   * Set text component justification.
   *
   * @param justification Justification for the text component.
   */
  set justification(justification) {
    this._engine.wasm._wl_text_component_set_vertical_alignment(this._id, justification);
  }
  /** Text component character spacing. */
  get characterSpacing() {
    return this._engine.wasm._wl_text_component_get_character_spacing(this._id);
  }
  /**
   * Set text component character spacing.
   *
   * @param spacing Character spacing for the text component.
   */
  set characterSpacing(spacing) {
    this._engine.wasm._wl_text_component_set_character_spacing(this._id, spacing);
  }
  /** Text component line spacing. */
  get lineSpacing() {
    return this._engine.wasm._wl_text_component_get_line_spacing(this._id);
  }
  /**
   * Set text component line spacing
   *
   * @param spacing Line spacing for the text component
   */
  set lineSpacing(spacing) {
    this._engine.wasm._wl_text_component_set_line_spacing(this._id, spacing);
  }
  /** Text component effect. */
  get effect() {
    return this._engine.wasm._wl_text_component_get_effect(this._id);
  }
  /**
   * Set text component effect
   *
   * @param effect Effect for the text component
   */
  set effect(effect) {
    this._engine.wasm._wl_text_component_set_effect(this._id, effect);
  }
  /** Text component text. */
  get text() {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_text_component_get_text(this._id);
    return wasm.UTF8ToString(ptr);
  }
  /**
   * Set text component text.
   *
   * @param text Text of the text component.
   */
  set text(text) {
    const wasm = this._engine.wasm;
    wasm._wl_text_component_set_text(this._id, wasm.tempUTF8(text));
  }
  /**
   * Set material to render the text with.
   *
   * @param material New material.
   */
  set material(material) {
    const matIndex = material ? material._index : 0;
    this._engine.wasm._wl_text_component_set_material(this._id, matIndex);
  }
  /** Material used to render the text. */
  get material() {
    const id = this._engine.wasm._wl_text_component_get_material(this._id);
    return id > 0 ? new Material2(this._engine, id) : null;
  }
};
/** @override */
__publicField(TextComponent2, "TypeName", "text");
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "alignment", null);
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "justification", null);
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "characterSpacing", null);
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "lineSpacing", null);
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "effect", null);
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "text", null);
__decorate7([
  nativeProperty2()
], TextComponent2.prototype, "material", null);
var ViewComponent2 = class extends Component2 {
  /** Projection matrix. */
  get projectionMatrix() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_view_component_get_projection_matrix(this._id), 16);
  }
  /** ViewComponent near clipping plane value. */
  get near() {
    return this._engine.wasm._wl_view_component_get_near(this._id);
  }
  /**
   * Set near clipping plane distance for the view.
   *
   * If an XR session is active, the change will apply in the
   * following frame, otherwise the change is immediate.
   *
   * @param near Near depth value.
   */
  set near(near) {
    this._engine.wasm._wl_view_component_set_near(this._id, near);
  }
  /** Far clipping plane value. */
  get far() {
    return this._engine.wasm._wl_view_component_get_far(this._id);
  }
  /**
   * Set far clipping plane distance for the view.
   *
   * If an XR session is active, the change will apply in the
   * following frame, otherwise the change is immediate.
   *
   * @param far Near depth value.
   */
  set far(far) {
    this._engine.wasm._wl_view_component_set_far(this._id, far);
  }
  /**
   * Get the horizontal field of view for the view, **in degrees**.
   *
   * If an XR session is active, this returns the field of view reported by
   * the device, regardless of the fov that was set.
   */
  get fov() {
    return this._engine.wasm._wl_view_component_get_fov(this._id);
  }
  /**
   * Set the horizontal field of view for the view, **in degrees**.
   *
   * If an XR session is active, the field of view reported by the device is
   * used and this value is ignored. After the XR session ends, the new value
   * is applied.
   *
   * @param fov Horizontal field of view, **in degrees**.
   */
  set fov(fov) {
    this._engine.wasm._wl_view_component_set_fov(this._id, fov);
  }
};
/** @override */
__publicField(ViewComponent2, "TypeName", "view");
__decorate7([
  enumerable2()
], ViewComponent2.prototype, "projectionMatrix", null);
__decorate7([
  nativeProperty2()
], ViewComponent2.prototype, "near", null);
__decorate7([
  nativeProperty2()
], ViewComponent2.prototype, "far", null);
__decorate7([
  nativeProperty2()
], ViewComponent2.prototype, "fov", null);
var InputComponent2 = class extends Component2 {
  /** Input component type */
  get inputType() {
    return this._engine.wasm._wl_input_component_get_type(this._id);
  }
  /**
   * Set input component type.
   *
   * @params New input component type.
   */
  set inputType(type) {
    this._engine.wasm._wl_input_component_set_type(this._id, type);
  }
  /**
   * WebXR Device API input source associated with this input component,
   * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
   */
  get xrInputSource() {
    const xrSession = this._engine.xrSession;
    if (xrSession) {
      for (let inputSource of xrSession.inputSources) {
        if (inputSource.handedness == this.handedness) {
          return inputSource;
        }
      }
    }
    return null;
  }
  /**
   * 'left', 'right' or `null` depending on the {@link InputComponent#inputType}.
   */
  get handedness() {
    const inputType = this.inputType;
    if (inputType == InputType2.ControllerRight || inputType == InputType2.RayRight || inputType == InputType2.EyeRight)
      return "right";
    if (inputType == InputType2.ControllerLeft || inputType == InputType2.RayLeft || inputType == InputType2.EyeLeft)
      return "left";
    return null;
  }
};
/** @override */
__publicField(InputComponent2, "TypeName", "input");
__decorate7([
  nativeProperty2()
], InputComponent2.prototype, "inputType", null);
__decorate7([
  enumerable2()
], InputComponent2.prototype, "xrInputSource", null);
__decorate7([
  enumerable2()
], InputComponent2.prototype, "handedness", null);
var LightComponent2 = class extends Component2 {
  getColor(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_light_component_get_color(this._id) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set light color.
   *
   * @param c New color array/vector, expected to have at least 3 elements.
   * @since 1.0.0
   */
  setColor(c) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_light_component_get_color(this._id) / 4;
    wasm.HEAPF32[ptr] = c[0];
    wasm.HEAPF32[ptr + 1] = c[1];
    wasm.HEAPF32[ptr + 2] = c[2];
  }
  /**
   * View on the light color.
   *
   * @note Prefer to use {@link getColor} in performance-critical code.
   */
  get color() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_light_component_get_color(this._id), 3);
  }
  /**
   * Set light color.
   *
   * @param c Color of the light component.
   *
   * @note Prefer to use {@link setColor} in performance-critical code.
   */
  set color(c) {
    this.color.set(c);
  }
  /** Light type. */
  get lightType() {
    return this._engine.wasm._wl_light_component_get_type(this._id);
  }
  /**
   * Set light type.
   *
   * @param lightType Type of the light component.
   */
  set lightType(t) {
    this._engine.wasm._wl_light_component_set_type(this._id, t);
  }
  /**
   * Light intensity.
   * @since 1.0.0
   */
  get intensity() {
    return this._engine.wasm._wl_light_component_get_intensity(this._id);
  }
  /**
   * Set light intensity.
   *
   * @param intensity Intensity of the light component.
   * @since 1.0.0
   */
  set intensity(intensity) {
    this._engine.wasm._wl_light_component_set_intensity(this._id, intensity);
  }
  /**
   * Outer angle for spot lights, in degrees.
   * @since 1.0.0
   */
  get outerAngle() {
    return this._engine.wasm._wl_light_component_get_outerAngle(this._id);
  }
  /**
   * Set outer angle for spot lights.
   *
   * @param angle Outer angle, in degrees.
   * @since 1.0.0
   */
  set outerAngle(angle3) {
    this._engine.wasm._wl_light_component_set_outerAngle(this._id, angle3);
  }
  /**
   * Inner angle for spot lights, in degrees.
   * @since 1.0.0
   */
  get innerAngle() {
    return this._engine.wasm._wl_light_component_get_innerAngle(this._id);
  }
  /**
   * Set inner angle for spot lights.
   *
   * @param angle Inner angle, in degrees.
   * @since 1.0.0
   */
  set innerAngle(angle3) {
    this._engine.wasm._wl_light_component_set_innerAngle(this._id, angle3);
  }
  /**
   * Whether the light casts shadows.
   * @since 1.0.0
   */
  get shadows() {
    return !!this._engine.wasm._wl_light_component_get_shadows(this._id);
  }
  /**
   * Set whether the light casts shadows.
   *
   * @param b Whether the light casts shadows.
   * @since 1.0.0
   */
  set shadows(b) {
    this._engine.wasm._wl_light_component_set_shadows(this._id, b);
  }
  /**
   * Range for shadows.
   * @since 1.0.0
   */
  get shadowRange() {
    return this._engine.wasm._wl_light_component_get_shadowRange(this._id);
  }
  /**
   * Set range for shadows.
   *
   * @param range Range for shadows.
   * @since 1.0.0
   */
  set shadowRange(range) {
    this._engine.wasm._wl_light_component_set_shadowRange(this._id, range);
  }
  /**
   * Bias value for shadows.
   * @since 1.0.0
   */
  get shadowBias() {
    return this._engine.wasm._wl_light_component_get_shadowBias(this._id);
  }
  /**
   * Set bias value for shadows.
   *
   * @param bias Bias for shadows.
   * @since 1.0.0
   */
  set shadowBias(bias) {
    this._engine.wasm._wl_light_component_set_shadowBias(this._id, bias);
  }
  /**
   * Normal bias value for shadows.
   * @since 1.0.0
   */
  get shadowNormalBias() {
    return this._engine.wasm._wl_light_component_get_shadowNormalBias(this._id);
  }
  /**
   * Set normal bias value for shadows.
   *
   * @param bias Normal bias for shadows.
   * @since 1.0.0
   */
  set shadowNormalBias(bias) {
    this._engine.wasm._wl_light_component_set_shadowNormalBias(this._id, bias);
  }
  /**
   * Texel size for shadows.
   * @since 1.0.0
   */
  get shadowTexelSize() {
    return this._engine.wasm._wl_light_component_get_shadowTexelSize(this._id);
  }
  /**
   * Set texel size for shadows.
   *
   * @param size Texel size for shadows.
   * @since 1.0.0
   */
  set shadowTexelSize(size) {
    this._engine.wasm._wl_light_component_set_shadowTexelSize(this._id, size);
  }
  /**
   * Cascade count for {@link LightType.Sun} shadows.
   * @since 1.0.0
   */
  get cascadeCount() {
    return this._engine.wasm._wl_light_component_get_cascadeCount(this._id);
  }
  /**
   * Set cascade count for {@link LightType.Sun} shadows.
   *
   * @param count Cascade count.
   * @since 1.0.0
   */
  set cascadeCount(count) {
    this._engine.wasm._wl_light_component_set_cascadeCount(this._id, count);
  }
};
/** @override */
__publicField(LightComponent2, "TypeName", "light");
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "color", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "lightType", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "intensity", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "outerAngle", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "innerAngle", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "shadows", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "shadowRange", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "shadowBias", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "shadowNormalBias", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "shadowTexelSize", null);
__decorate7([
  nativeProperty2()
], LightComponent2.prototype, "cascadeCount", null);
var AnimationComponent2 = class extends Component2 {
  /**
   * Set animation to play.
   *
   * Make sure to {@link Animation#retarget} the animation to affect the
   * right objects.
   *
   * @param anim Animation to play.
   */
  set animation(anim) {
    this._engine.wasm._wl_animation_component_set_animation(this._id, anim ? anim._index : 0);
  }
  /** Animation set for this component */
  get animation() {
    const id = this._engine.wasm._wl_animation_component_get_animation(this._id);
    return id > 0 ? new Animation2(this._engine, id) : null;
  }
  /**
   * Set play count. Set to `0` to loop indefinitely.
   *
   * @param playCount Number of times to repeat the animation.
   */
  set playCount(playCount) {
    this._engine.wasm._wl_animation_component_set_playCount(this._id, playCount);
  }
  /** Number of times the animation is played. */
  get playCount() {
    return this._engine.wasm._wl_animation_component_get_playCount(this._id);
  }
  /**
   * Set speed. Set to negative values to run the animation backwards.
   *
   * Setting speed has an immediate effect for the current frame's update
   * and will continue with the speed from the current point in the animation.
   *
   * @param speed New speed at which to play the animation.
   * @since 0.8.10
   */
  set speed(speed) {
    this._engine.wasm._wl_animation_component_set_speed(this._id, speed);
  }
  /**
   * Speed factor at which the animation is played.
   *
   * @since 0.8.10
   */
  get speed() {
    return this._engine.wasm._wl_animation_component_get_speed(this._id);
  }
  /** Current playing state of the animation */
  get state() {
    return this._engine.wasm._wl_animation_component_state(this._id);
  }
  /**
   * Play animation.
   *
   * If the animation is currently paused, resumes from that position. If the
   * animation is already playing, does nothing.
   *
   * To restart the animation, {@link AnimationComponent#stop} it first.
   */
  play() {
    this._engine.wasm._wl_animation_component_play(this._id);
  }
  /** Stop animation. */
  stop() {
    this._engine.wasm._wl_animation_component_stop(this._id);
  }
  /** Pause animation. */
  pause() {
    this._engine.wasm._wl_animation_component_pause(this._id);
  }
};
/** @override */
__publicField(AnimationComponent2, "TypeName", "animation");
__decorate7([
  nativeProperty2()
], AnimationComponent2.prototype, "animation", null);
__decorate7([
  nativeProperty2()
], AnimationComponent2.prototype, "playCount", null);
__decorate7([
  nativeProperty2()
], AnimationComponent2.prototype, "speed", null);
__decorate7([
  enumerable2()
], AnimationComponent2.prototype, "state", null);
var MeshComponent2 = class extends Component2 {
  /**
   * Set material to render the mesh with.
   *
   * @param material Material to render the mesh with.
   */
  set material(material) {
    this._engine.wasm._wl_mesh_component_set_material(this._id, material ? material._index : 0);
  }
  /** Material used to render the mesh. */
  get material() {
    const id = this._engine.wasm._wl_mesh_component_get_material(this._id);
    return id > 0 ? new Material2(this._engine, id) : null;
  }
  /** Mesh rendered by this component. */
  get mesh() {
    const id = this._engine.wasm._wl_mesh_component_get_mesh(this._id);
    return id > 0 ? new Mesh2(this._engine, id) : null;
  }
  /**
   * Set mesh to rendered with this component.
   *
   * @param mesh Mesh rendered by this component.
   */
  set mesh(mesh) {
    this._engine.wasm._wl_mesh_component_set_mesh(this._id, mesh ? mesh._index : 0);
  }
  /** Skin for this mesh component. */
  get skin() {
    const id = this._engine.wasm._wl_mesh_component_get_skin(this._id);
    return id > 0 ? new Skin2(this._engine, id) : null;
  }
  /**
   * Set skin to transform this mesh component.
   *
   * @param skin Skin to use for rendering skinned meshes.
   */
  set skin(skin) {
    this._engine.wasm._wl_mesh_component_set_skin(this._id, skin ? skin._index : 0);
  }
};
/** @override */
__publicField(MeshComponent2, "TypeName", "mesh");
__decorate7([
  nativeProperty2()
], MeshComponent2.prototype, "material", null);
__decorate7([
  nativeProperty2()
], MeshComponent2.prototype, "mesh", null);
__decorate7([
  nativeProperty2()
], MeshComponent2.prototype, "skin", null);
var LockAxis2;
(function(LockAxis3) {
  LockAxis3[LockAxis3["None"] = 0] = "None";
  LockAxis3[LockAxis3["X"] = 1] = "X";
  LockAxis3[LockAxis3["Y"] = 2] = "Y";
  LockAxis3[LockAxis3["Z"] = 4] = "Z";
})(LockAxis2 || (LockAxis2 = {}));
var PhysXComponent2 = class extends Component2 {
  /**
   * Set whether this rigid body is static.
   *
   * Setting this property only takes effect once the component
   * switches from inactive to active.
   *
   * @param b Whether the rigid body should be static.
   */
  set static(b) {
    this._engine.wasm._wl_physx_component_set_static(this._id, b);
  }
  /**
   * Whether this rigid body is static.
   *
   * This property returns whether the rigid body is *effectively*
   * static. If static property was set while the rigid body was
   * active, it will not take effect until the rigid body is set
   * inactive and active again. Until the component is set inactive,
   * this getter will return whether the rigid body is actually
   * static.
   */
  get static() {
    return !!this._engine.wasm._wl_physx_component_get_static(this._id);
  }
  /**
   * Set whether this rigid body is kinematic.
   *
   * @param b Whether the rigid body should be kinematic.
   */
  set kinematic(b) {
    this._engine.wasm._wl_physx_component_set_kinematic(this._id, b);
  }
  /**
   * Whether this rigid body is kinematic.
   */
  get kinematic() {
    return !!this._engine.wasm._wl_physx_component_get_kinematic(this._id);
  }
  /**
   * Set whether this rigid body's gravity is enabled.
   *
   * @param b Whether the rigid body's gravity should be enabled.
   */
  set gravity(b) {
    this._engine.wasm._wl_physx_component_set_gravity(this._id, b);
  }
  /**
   * Whether this rigid body's gravity flag is enabled.
   */
  get gravity() {
    return !!this._engine.wasm._wl_physx_component_get_gravity(this._id);
  }
  /**
   * Set whether this rigid body's simulate flag is enabled.
   *
   * @param b Whether the rigid body's simulate flag should be enabled.
   */
  set simulate(b) {
    this._engine.wasm._wl_physx_component_set_simulate(this._id, b);
  }
  /**
   * Whether this rigid body's simulate flag is enabled.
   */
  get simulate() {
    return !!this._engine.wasm._wl_physx_component_get_simulate(this._id);
  }
  /**
   * Set whether to allow simulation of this rigid body.
   *
   * {@link allowSimulation} and {@link trigger} can not be enabled at the
   * same time. Enabling {@link allowSimulation} while {@link trigger} is enabled
   * will disable {@link trigger}.
   *
   * @param b Whether to allow simulation of this rigid body.
   */
  set allowSimulation(b) {
    this._engine.wasm._wl_physx_component_set_allowSimulation(this._id, b);
  }
  /**
   * Whether to allow simulation of this rigid body.
   */
  get allowSimulation() {
    return !!this._engine.wasm._wl_physx_component_get_allowSimulation(this._id);
  }
  /**
   * Set whether this rigid body may be queried in ray casts.
   *
   * @param b Whether this rigid body may be queried in ray casts.
   */
  set allowQuery(b) {
    this._engine.wasm._wl_physx_component_set_allowQuery(this._id, b);
  }
  /**
   * Whether this rigid body may be queried in ray casts.
   */
  get allowQuery() {
    return !!this._engine.wasm._wl_physx_component_get_allowQuery(this._id);
  }
  /**
   * Set whether this physics body is a trigger.
   *
   * {@link allowSimulation} and {@link trigger} can not be enabled at the
   * same time. Enabling trigger while {@link allowSimulation} is enabled,
   * will disable {@link allowSimulation}.
   *
   * @param b Whether this physics body is a trigger.
   */
  set trigger(b) {
    this._engine.wasm._wl_physx_component_set_trigger(this._id, b);
  }
  /**
   * Whether this physics body is a trigger.
   */
  get trigger() {
    return !!this._engine.wasm._wl_physx_component_get_trigger(this._id);
  }
  /**
   * Set the shape for collision detection.
   *
   * @param s New shape.
   * @since 0.8.5
   */
  set shape(s) {
    this._engine.wasm._wl_physx_component_set_shape(this._id, s);
  }
  /** The shape for collision detection. */
  get shape() {
    return this._engine.wasm._wl_physx_component_get_shape(this._id);
  }
  /**
   * Set additional data for the shape.
   *
   * Retrieved only from {@link PhysXComponent#shapeData}.
   * @since 0.8.10
   */
  set shapeData(d) {
    if (d == null || !isMeshShape2(this.shape))
      return;
    this._engine.wasm._wl_physx_component_set_shape_data(this._id, d.index);
  }
  /**
   * Additional data for the shape.
   *
   * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
   * `{index: n}` for `TriangleMesh` and `ConvexHull`.
   *
   * This data is currently only for passing onto or creating other {@link PhysXComponent}.
   * @since 0.8.10
   */
  get shapeData() {
    if (!isMeshShape2(this.shape))
      return null;
    return { index: this._engine.wasm._wl_physx_component_get_shape_data(this._id) };
  }
  /**
   * Set the shape extents for collision detection.
   *
   * @param e New extents for the shape.
   * @since 0.8.5
   */
  set extents(e) {
    this.extents.set(e);
  }
  /**
   * The shape extents for collision detection.
   */
  get extents() {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_physx_component_get_extents(this._id);
    return new Float32Array(wasm.HEAPF32.buffer, ptr, 3);
  }
  /**
   * Get staticFriction.
   */
  get staticFriction() {
    return this._engine.wasm._wl_physx_component_get_staticFriction(this._id);
  }
  /**
   * Set staticFriction.
   * @param v New staticFriction.
   */
  set staticFriction(v) {
    this._engine.wasm._wl_physx_component_set_staticFriction(this._id, v);
  }
  /**
   * Get dynamicFriction.
   */
  get dynamicFriction() {
    return this._engine.wasm._wl_physx_component_get_dynamicFriction(this._id);
  }
  /**
   * Set dynamicFriction
   * @param v New dynamicDamping.
   */
  set dynamicFriction(v) {
    this._engine.wasm._wl_physx_component_set_dynamicFriction(this._id, v);
  }
  /**
   * Get bounciness.
   * @since 0.9.0
   */
  get bounciness() {
    return this._engine.wasm._wl_physx_component_get_bounciness(this._id);
  }
  /**
   * Set bounciness.
   * @param v New bounciness.
   * @since 0.9.0
   */
  set bounciness(v) {
    this._engine.wasm._wl_physx_component_set_bounciness(this._id, v);
  }
  /**
   * Get linearDamping/
   */
  get linearDamping() {
    return this._engine.wasm._wl_physx_component_get_linearDamping(this._id);
  }
  /**
   * Set linearDamping.
   * @param v New linearDamping.
   */
  set linearDamping(v) {
    this._engine.wasm._wl_physx_component_set_linearDamping(this._id, v);
  }
  /** Get angularDamping. */
  get angularDamping() {
    return this._engine.wasm._wl_physx_component_get_angularDamping(this._id);
  }
  /**
   * Set angularDamping.
   * @param v New angularDamping.
   */
  set angularDamping(v) {
    this._engine.wasm._wl_physx_component_set_angularDamping(this._id, v);
  }
  /**
   * Set linear velocity.
   *
   * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New linear velocity.
   */
  set linearVelocity(v) {
    this._engine.wasm._wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);
  }
  /** Linear velocity or `[0, 0, 0]` if the component is not active. */
  get linearVelocity() {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_linearVelocity(this._id, wasm._tempMem);
    return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
  }
  /**
   * Set angular velocity
   *
   * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New angular velocity
   */
  set angularVelocity(v) {
    this._engine.wasm._wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);
  }
  /** Angular velocity or `[0, 0, 0]` if the component is not active. */
  get angularVelocity() {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_angularVelocity(this._id, wasm._tempMem);
    return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
  }
  /**
   * Set the components groups mask.
   *
   * @param flags New flags that need to be set.
   */
  set groupsMask(flags) {
    this._engine.wasm._wl_physx_component_set_groupsMask(this._id, flags);
  }
  /**
   * Get the components groups mask flags.
   *
   * Each bit represents membership to group, see example.
   *
   * ```js
   * // Assign c to group 2
   * c.groupsMask = (1 << 2);
   *
   * // Assign c to group 0
   * c.groupsMask  = (1 << 0);
   *
   * // Assign c to group 0 and 2
   * c.groupsMask = (1 << 0) | (1 << 2);
   *
   * (c.groupsMask & (1 << 2)) != 0; // true
   * (c.groupsMask & (1 << 7)) != 0; // false
   * ```
   */
  get groupsMask() {
    return this._engine.wasm._wl_physx_component_get_groupsMask(this._id);
  }
  /**
   * Set the components blocks mask.
   *
   * @param flags New flags that need to be set.
   */
  set blocksMask(flags) {
    this._engine.wasm._wl_physx_component_set_blocksMask(this._id, flags);
  }
  /**
   * Get the components blocks mask flags.
   *
   * Each bit represents membership to the block, see example.
   *
   * ```js
   * // Block overlap with any objects in group 2
   * c.blocksMask = (1 << 2);
   *
   * // Block overlap with any objects in group 0
   * c.blocksMask  = (1 << 0)
   *
   * // Block overlap with any objects in group 0 and 2
   * c.blocksMask = (1 << 0) | (1 << 2);
   *
   * (c.blocksMask & (1 << 2)) != 0; // true
   * (c.blocksMask & (1 << 7)) != 0; // false
   * ```
   */
  get blocksMask() {
    return this._engine.wasm._wl_physx_component_get_blocksMask(this._id);
  }
  /**
   * Set axes to lock for linear velocity.
   *
   * @param lock The Axis that needs to be set.
   *
   * Combine flags with Bitwise OR.
   * ```js
   * body.linearLockAxis = LockAxis.X | LockAxis.Y; // x and y set
   * body.linearLockAxis = LockAxis.X; // y unset
   * ```
   *
   * @note This has no effect if the component is static.
   */
  set linearLockAxis(lock) {
    this._engine.wasm._wl_physx_component_set_linearLockAxis(this._id, lock);
  }
  /**
   * Get the linear lock axes flags.
   *
   * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
   *
   * ```js
   * if(body.linearLockAxis & LockAxis.Y) {
   *     console.log("The Y flag was set!");
   * }
   * ```
   *
   * @return axes that are currently locked for linear movement.
   */
  get linearLockAxis() {
    return this._engine.wasm._wl_physx_component_get_linearLockAxis(this._id);
  }
  /**
   * Set axes to lock for angular velocity.
   *
   * @param lock The Axis that needs to be set.
   *
   * ```js
   * body.angularLockAxis = LockAxis.X | LockAxis.Y; // x and y set
   * body.angularLockAxis = LockAxis.X; // y unset
   * ```
   *
   * @note This has no effect if the component is static.
   */
  set angularLockAxis(lock) {
    this._engine.wasm._wl_physx_component_set_angularLockAxis(this._id, lock);
  }
  /**
   * Get the angular lock axes flags.
   *
   * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
   *
   * ```js
   * if(body.angularLockAxis & LockAxis.Y) {
   *     console.log("The Y flag was set!");
   * }
   * ```
   *
   * @return axes that are currently locked for angular movement.
   */
  get angularLockAxis() {
    return this._engine.wasm._wl_physx_component_get_angularLockAxis(this._id);
  }
  /**
   * Set mass.
   *
   * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
   *
   * @param m New mass.
   */
  set mass(m) {
    this._engine.wasm._wl_physx_component_set_mass(this._id, m);
  }
  /** Mass */
  get mass() {
    return this._engine.wasm._wl_physx_component_get_mass(this._id);
  }
  /**
   * Set mass space interia tensor.
   *
   * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New mass space interatia tensor.
   */
  set massSpaceInteriaTensor(v) {
    this._engine.wasm._wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);
  }
  /**
   * Apply a force.
   *
   * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
   *
   * Has no effect, if the component is not active.
   *
   * @param f Force vector.
   * @param m Force mode, see {@link ForceMode}, default `Force`.
   * @param localForce Whether the force vector is in local space, default `false`.
   * @param p Position to apply force at, default is center of mass.
   * @param local Whether position is in local space, default `false`.
   */
  addForce(f, m = ForceMode2.Force, localForce = false, p, local = false) {
    const wasm = this._engine.wasm;
    if (!p) {
      wasm._wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, localForce);
      return;
    }
    wasm._wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, localForce, p[0], p[1], p[2], local);
  }
  /**
   * Apply torque.
   *
   * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
   *
   * Has no effect, if the component is not active.
   *
   * @param f Force vector.
   * @param m Force mode, see {@link ForceMode}, default `Force`.
   */
  addTorque(f, m = ForceMode2.Force) {
    this._engine.wasm._wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);
  }
  /**
   * Add on collision callback.
   *
   * @param callback Function to call when this rigid body (un)collides with any other.
   *
   * ```js
   *  let rigidBody = this.object.getComponent('physx');
   *  rigidBody.onCollision(function(type, other) {
   *      // Ignore uncollides
   *      if(type == CollisionEventType.TouchLost) return;
   *
   *      // Take damage on collision with enemies
   *      if(other.object.name.startsWith('enemy-')) {
   *          this.applyDamage(10);
   *      }
   *  }.bind(this));
   * ```
   *
   * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
   */
  onCollision(callback) {
    return this.onCollisionWith(this, callback);
  }
  /**
   * Add filtered on collision callback.
   *
   * @param otherComp Component for which callbacks will
   *        be triggered. If you pass this component, the method is equivalent to.
   *        {@link PhysXComponent#onCollision}.
   * @param callback Function to call when this rigid body
   *        (un)collides with `otherComp`.
   * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
   */
  onCollisionWith(otherComp, callback) {
    const physics = this._engine.physics;
    physics._callbacks[this._id] = physics._callbacks[this._id] || [];
    physics._callbacks[this._id].push(callback);
    return this._engine.wasm._wl_physx_component_addCallback(this._id, otherComp._id || this._id);
  }
  /**
   * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
   *
   * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
   * @throws When the callback does not belong to the component.
   * @throws When the callback does not exist.
   */
  removeCollisionCallback(callbackId) {
    const physics = this._engine.physics;
    const r = this._engine.wasm._wl_physx_component_removeCallback(this._id, callbackId);
    if (r)
      physics._callbacks[this._id].splice(-r);
  }
};
/** @override */
__publicField(PhysXComponent2, "TypeName", "physx");
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "static", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "kinematic", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "gravity", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "simulate", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "allowSimulation", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "allowQuery", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "trigger", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "shape", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "shapeData", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "extents", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "staticFriction", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "dynamicFriction", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "bounciness", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "linearDamping", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "angularDamping", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "linearVelocity", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "angularVelocity", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "groupsMask", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "blocksMask", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "linearLockAxis", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "angularLockAxis", null);
__decorate7([
  nativeProperty2()
], PhysXComponent2.prototype, "mass", null);
var MeshIndexType2;
(function(MeshIndexType3) {
  MeshIndexType3[MeshIndexType3["UnsignedByte"] = 1] = "UnsignedByte";
  MeshIndexType3[MeshIndexType3["UnsignedShort"] = 2] = "UnsignedShort";
  MeshIndexType3[MeshIndexType3["UnsignedInt"] = 4] = "UnsignedInt";
})(MeshIndexType2 || (MeshIndexType2 = {}));
var MeshSkinningType2;
(function(MeshSkinningType3) {
  MeshSkinningType3[MeshSkinningType3["None"] = 0] = "None";
  MeshSkinningType3[MeshSkinningType3["FourJoints"] = 1] = "FourJoints";
  MeshSkinningType3[MeshSkinningType3["EightJoints"] = 2] = "EightJoints";
})(MeshSkinningType2 || (MeshSkinningType2 = {}));
var Mesh2 = class {
  /**
   * Index of the mesh in the manager.
   *
   * @hidden
   */
  _index = -1;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new instance.
   *
   * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
   *    For more information, please have a look at the {@link MeshParameters} interface.
   */
  constructor(engine2, params) {
    this._engine = engine2 ?? WL;
    this._index = -1;
    if (isNumber2(params)) {
      this._index = params;
      return;
    }
    if (!params.vertexCount)
      throw new Error("Missing parameter 'vertexCount'");
    const wasm = this._engine.wasm;
    let indexData = 0;
    let indexType = 0;
    let indexDataSize = 0;
    if (params.indexData) {
      indexType = params.indexType || MeshIndexType2.UnsignedShort;
      indexDataSize = params.indexData.length * indexType;
      indexData = wasm._malloc(indexDataSize);
      switch (indexType) {
        case MeshIndexType2.UnsignedByte:
          wasm.HEAPU8.set(params.indexData, indexData);
          break;
        case MeshIndexType2.UnsignedShort:
          wasm.HEAPU16.set(params.indexData, indexData >> 1);
          break;
        case MeshIndexType2.UnsignedInt:
          wasm.HEAPU32.set(params.indexData, indexData >> 2);
          break;
      }
    }
    const { skinningType = MeshSkinningType2.None } = params;
    this._index = wasm._wl_mesh_create(indexData, indexDataSize, indexType, params.vertexCount, skinningType);
  }
  /** Number of vertices in this mesh. */
  get vertexCount() {
    return this._engine.wasm._wl_mesh_get_vertexCount(this._index);
  }
  /** Index data (read-only) or `null` if the mesh is not indexed. */
  get indexData() {
    const wasm = this._engine.wasm;
    const tempMem = wasm._tempMem;
    const ptr = wasm._wl_mesh_get_indexData(this._index, tempMem, tempMem + 4);
    if (ptr === null)
      return null;
    const indexCount = wasm.HEAPU32[tempMem / 4];
    const indexSize = wasm.HEAPU32[tempMem / 4 + 1];
    switch (indexSize) {
      case MeshIndexType2.UnsignedByte:
        return new Uint8Array(wasm.HEAPU8.buffer, ptr, indexCount);
      case MeshIndexType2.UnsignedShort:
        return new Uint16Array(wasm.HEAPU16.buffer, ptr, indexCount);
      case MeshIndexType2.UnsignedInt:
        return new Uint32Array(wasm.HEAPU32.buffer, ptr, indexCount);
    }
    return null;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Apply changes to {@link attribute | vertex attributes}.
   *
   * Uploads the updated vertex attributes to the GPU and updates the bounding
   * sphere to match the new vertex positions.
   *
   * Since this is an expensive operation, call it only once you have performed
   * all modifications on a mesh and avoid calling if you did not perform any
   * modifications at all.
   */
  update() {
    this._engine.wasm._wl_mesh_update(this._index);
  }
  getBoundingSphere(out = new Float32Array(4)) {
    const tempMemFloat = this._engine.wasm._tempMemFloat;
    this._engine.wasm._wl_mesh_get_boundingSphere(this._index, this._engine.wasm._tempMem);
    out[0] = tempMemFloat[0];
    out[1] = tempMemFloat[1];
    out[2] = tempMemFloat[2];
    out[3] = tempMemFloat[3];
    return out;
  }
  attribute(attr) {
    if (typeof attr != "number")
      throw new TypeError("Expected number, but got " + typeof attr);
    const tempMemUint32 = this._engine.wasm._tempMemUint32;
    this._engine.wasm._wl_mesh_get_attribute(this._index, attr, this._engine.wasm._tempMem);
    if (tempMemUint32[0] == 255)
      return null;
    const arraySize = tempMemUint32[5];
    return new MeshAttributeAccessor2(this._engine, {
      attribute: tempMemUint32[0],
      offset: tempMemUint32[1],
      stride: tempMemUint32[2],
      formatSize: tempMemUint32[3],
      componentCount: tempMemUint32[4],
      /* The WASM API returns `0` for a scalar value. We clamp it to 1 as we strictly use it as a multiplier for get/set operations */
      arraySize: arraySize ? arraySize : 1,
      length: this.vertexCount,
      bufferType: attr !== MeshAttribute2.JointId ? Float32Array : Uint16Array
    });
  }
  /**
   * Destroy and free the meshes memory.
   *
   * It is best practice to set the mesh variable to `null` after calling
   * destroy to prevent accidental use:
   *
   * ```js
   *   mesh.destroy();
   *   mesh = null;
   * ```
   *
   * Accessing the mesh after destruction behaves like accessing an empty
   * mesh.
   *
   * @since 0.9.0
   */
  destroy() {
    this._engine.wasm._wl_mesh_destroy(this._index);
  }
  /**
   * Checks equality by comparing whether the wrapped native mesh ids are
   * equal.
   *
   * @param otherMesh Mesh to check equality with.
   * @returns Whether this mesh equals the given mesh.
   *
   * @since 1.0.0
   */
  equals(otherMesh) {
    if (!otherMesh)
      return false;
    return this._index === otherMesh._index;
  }
};
var MeshAttributeAccessor2 = class {
  /** Max number of elements. */
  length = 0;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Attribute index. @hidden */
  _attribute = -1;
  /** Attribute offset. @hidden */
  _offset = 0;
  /** Attribute stride. @hidden */
  _stride = 0;
  /** Format size native enum. @hidden */
  _formatSize = 0;
  /** Number of components per vertex. @hidden */
  _componentCount = 0;
  /** Number of values per vertex. @hidden */
  _arraySize = 1;
  /**
   * Class to instantiate an ArrayBuffer to get/set values.
   */
  _bufferType;
  /**
   * Function to allocate temporary WASM memory. It is cached in the accessor to avoid
   * conditionals during get/set.
   */
  _tempBufferGetter;
  /**
   * Create a new instance.
   *
   * @note Please use {@link Mesh.attribute} to create a new instance.
   *
   * @param options Contains information about how to read the data.
   * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
   *
   * @hidden
   */
  constructor(engine2, options) {
    this._engine = engine2;
    const wasm = this._engine.wasm;
    this._attribute = options.attribute;
    this._offset = options.offset;
    this._stride = options.stride;
    this._formatSize = options.formatSize;
    this._componentCount = options.componentCount;
    this._arraySize = options.arraySize;
    this._bufferType = options.bufferType;
    this.length = options.length;
    this._tempBufferGetter = this._bufferType === Float32Array ? wasm.getTempBufferF32.bind(wasm) : wasm.getTempBufferU16.bind(wasm);
  }
  /**
   * Create a new TypedArray to hold this attribute's values.
   *
   * This method is useful to create a view to hold the data to
   * pass to {@link get} and {@link set}
   *
   * Example:
   *
   * ```js
   * const vertexCount = 4;
   * const positionAttribute = mesh.attribute(MeshAttributes.Position);
   *
   * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
   * const positions = positionAttribute.createArray(vertexCount);
   * ```
   *
   * @param count The number of **vertices** expected.
   * @returns A TypedArray with the appropriate format to access the data
   */
  createArray(count = 1) {
    count = count > this.length ? this.length : count;
    return new this._bufferType(count * this._componentCount * this._arraySize);
  }
  get(index, out = this.createArray()) {
    if (out.length % this._componentCount !== 0) {
      throw new Error(`out.length, ${out.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
    }
    const dest = this._tempBufferGetter(out.length);
    const elementSize = this._bufferType.BYTES_PER_ELEMENT;
    const destSize = elementSize * out.length;
    const srcFormatSize = this._formatSize * this._arraySize;
    const destFormatSize = this._componentCount * elementSize * this._arraySize;
    this._engine.wasm._wl_mesh_get_attribute_values(this._attribute, srcFormatSize, this._offset + index * this._stride, this._stride, destFormatSize, dest.byteOffset, destSize);
    for (let i = 0; i < out.length; ++i)
      out[i] = dest[i];
    return out;
  }
  /**
   * Set attribute element.
   *
   * @param i Index
   * @param v Value to set the element to
   *
   * `v.length` needs to be a multiple of the attributes component count, see
   * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
   * filled with the next n attribute elements, which can reduce overhead
   * of this call.
   *
   * @returns Reference to self (for method chaining)
   */
  set(i, v) {
    if (v.length % this._componentCount !== 0)
      throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
    const elementSize = this._bufferType.BYTES_PER_ELEMENT;
    const srcSize = elementSize * v.length;
    const srcFormatSize = this._componentCount * elementSize * this._arraySize;
    const destFormatSize = this._formatSize * this._arraySize;
    const wasm = this._engine.wasm;
    if (v.buffer != wasm.HEAPU8.buffer) {
      const dest = this._tempBufferGetter(v.length);
      dest.set(v);
      v = dest;
    }
    wasm._wl_mesh_set_attribute_values(this._attribute, srcFormatSize, v.byteOffset, srcSize, destFormatSize, this._offset + i * this._stride, this._stride);
    return this;
  }
};
var Material2 = class {
  /**
   * Index of this material in the manager.
   *
   * @hidden
   */
  _index;
  /**
   * Material definition index in the scene.
   *
   * @hidden
   */
  _definition;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new Material.
   *
   * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
   * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
   */
  constructor(engine2, params) {
    this._engine = engine2;
    if (typeof params !== "number") {
      if (!params?.pipeline)
        throw new Error("Missing parameter 'pipeline'");
      const wasm = this._engine.wasm;
      const pipeline = params.pipeline;
      this._index = wasm._wl_material_create(wasm.tempUTF8(pipeline));
      if (this._index < 0)
        throw new Error(`No such pipeline '${pipeline}'`);
    } else {
      this._index = params;
    }
    this._definition = this._engine.wasm._wl_material_get_definition(this._index);
    if (!this._engine.wasm._materialDefinitions[this._definition])
      throw new Error(`Material Definition ${this._definition} not found for material with index ${this._index}`);
    return new Proxy(this, {
      get(target, prop) {
        const wasm = engine2.wasm;
        const definition = wasm._materialDefinitions[target._definition];
        const param = definition.get(prop);
        if (!param)
          return target[prop];
        if (wasm._wl_material_get_param_value(target._index, param.index, wasm._tempMem)) {
          const type = param.type;
          switch (type.type) {
            case MaterialParamType2.UnsignedInt:
              return type.componentCount == 1 ? wasm._tempMemUint32[0] : new Uint32Array(wasm.HEAPU32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType2.Int:
              return type.componentCount == 1 ? wasm._tempMemInt[0] : new Int32Array(wasm.HEAP32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType2.Float:
              return type.componentCount == 1 ? wasm._tempMemFloat[0] : new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType2.Sampler:
              return engine2.textures.wrap(wasm._tempMemInt[0]);
            default:
              throw new Error(`Invalid type ${type.type} on parameter ${param.index} for material ${target._index}`);
          }
        }
      },
      set(target, prop, value) {
        const wasm = engine2.wasm;
        const definition = wasm._materialDefinitions[target._definition];
        const param = definition.get(prop);
        if (!param) {
          target[prop] = value;
          return true;
        }
        const type = param.type;
        switch (type.type) {
          case MaterialParamType2.UnsignedInt:
          case MaterialParamType2.Int:
          case MaterialParamType2.Sampler:
            const v = value.id ?? value;
            wasm._wl_material_set_param_value_uint(target._index, param.index, v);
            break;
          case MaterialParamType2.Float:
            let count = 1;
            if (typeof value === "number") {
              wasm._tempMemFloat[0] = value;
            } else {
              count = value.length;
              for (let i = 0; i < count; ++i)
                wasm._tempMemFloat[i] = value[i];
            }
            wasm._wl_material_set_param_value_float(target._index, param.index, wasm._tempMem, count);
            break;
          case MaterialParamType2.Font:
            throw new Error("Setting font properties is currently unsupported.");
        }
        return true;
      }
    });
  }
  /** @deprecated Use {@link #pipeline} instead. */
  get shader() {
    return this.pipeline;
  }
  /** Name of the pipeline used by this material. */
  get pipeline() {
    const wasm = this._engine.wasm;
    return wasm.UTF8ToString(wasm._wl_material_get_pipeline(this._index));
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Create a copy of the underlying native material.
   *
   * @returns Material clone.
   */
  clone() {
    const id = this._engine.wasm._wl_material_clone(this._index);
    return id > 0 ? new Material2(this._engine, id) : null;
  }
  /**
   * Checks equality by comparing whether the wrapped native material ids are
   * equal.
   *
   * @param otherMaterial Material to check equality with.
   * @returns Whether this material equals the given material.
   *
   * @since 1.0.0
   */
  equals(otherMaterial) {
    if (!otherMaterial)
      return false;
    return this._index === otherMaterial._index;
  }
  /**
   * Wrap a native material index.
   *
   * @param engine Engine instance.
   * @param index The index.
   * @returns Material instance or `null` if index <= 0.
   *
   * @deprecated Please use `new Material()` instead.
   */
  static wrap(engine2, index) {
    return index > 0 ? new Material2(engine2, index) : null;
  }
};
var Animation2 = class {
  /** Index of the mesh in the manager. @hidden */
  _index;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * @param index Index in the manager
   */
  constructor(engine2 = WL, index) {
    this._engine = engine2;
    this._index = index;
  }
  /** Duration of this animation. */
  get duration() {
    return this._engine.wasm._wl_animation_get_duration(this._index);
  }
  /** Number of tracks in this animation. */
  get trackCount() {
    return this._engine.wasm._wl_animation_get_trackCount(this._index);
  }
  /**
   * Clone this animation retargeted to a new set of objects.
   *
   * The clone shares most of the data with the original and is therefore
   * light-weight.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * If retargeting to {@link Skin}, the join names will be used to determine a mapping
   * from the previous skin to the new skin. The source skin will be retrieved from
   * the first track in the animation that targets a joint.
   *
   * @param newTargets New targets per track. Expected to have
   *      {@link Animation#trackCount} elements or to be a {@link Skin}.
   * @returns The retargeted clone of this animation.
   */
  retarget(newTargets) {
    const wasm = this._engine.wasm;
    if (newTargets instanceof Skin2) {
      const animId2 = wasm._wl_animation_retargetToSkin(this._index, newTargets._index);
      return new Animation2(this._engine, animId2);
    }
    if (newTargets.length != this.trackCount) {
      throw Error("Expected " + this.trackCount.toString() + " targets, but got " + newTargets.length.toString());
    }
    const ptr = wasm._malloc(2 * newTargets.length);
    for (let i = 0; i < newTargets.length; ++i) {
      wasm.HEAPU16[ptr >> 1 + i] = newTargets[i].objectId;
    }
    const animId = wasm._wl_animation_retarget(this._index, ptr);
    wasm._free(ptr);
    return new Animation2(this._engine, animId);
  }
  /**
   * Checks equality by comparing whether the wrapped native animation ids
   * are equal.
   *
   * @param otherAnimation Animation to check equality with.
   * @returns Whether this animation equals the given animation.
   *
   * @since 1.0.0
   */
  equals(otherAnimation) {
    if (!otherAnimation)
      return false;
    return this._index === otherAnimation._index;
  }
};
var Skin2 = class {
  /**
   * Index of the skin in the manager.
   * @hidden
   */
  _index;
  /** Wonderland Engine instance. @hidden */
  _engine;
  constructor(engine2, index) {
    this._engine = engine2;
    this._index = index;
  }
  /** Amount of joints in this skin. */
  get jointCount() {
    return this._engine.wasm._wl_skin_get_joint_count(this._index);
  }
  /** Joints object ids for this skin */
  get jointIds() {
    const wasm = this._engine.wasm;
    return new Uint16Array(wasm.HEAPU16.buffer, wasm._wl_skin_joint_ids(this._index), this.jointCount);
  }
  /**
   * Dual quaternions in a flat array of size 8 times {@link jointCount}.
   *
   * Inverse bind transforms of the skin.
   */
  get inverseBindTransforms() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_transforms(this._index), 8 * this.jointCount);
  }
  /**
   * Vectors in a flat array of size 3 times {@link jointCount}.
   *
   * Inverse bind scalings of the skin.
   */
  get inverseBindScalings() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_scalings(this._index), 3 * this.jointCount);
  }
  /**
   * Checks equality by comparing whether the wrapped native skin ids are
   * equal.
   *
   * @param otherSkin Skin to check equality with.
   * @returns Whether this skin equals the given skin.
   *
   * @since 1.0.0
   */
  equals(otherSkin) {
    if (!otherSkin)
      return false;
    return this._index === otherSkin._index;
  }
};

// ../node_modules/@wonderlandengine/api/dist/wasm.js
var _componentDefaults2 = /* @__PURE__ */ new Map([
  [Type2.Bool, false],
  [Type2.Int, 0],
  [Type2.Float, 0],
  [Type2.String, ""],
  [Type2.Enum, void 0],
  [Type2.Object, null],
  [Type2.Mesh, null],
  [Type2.Texture, null],
  [Type2.Material, null],
  [Type2.Animation, null],
  [Type2.Skin, null],
  [Type2.Color, [0, 0, 0, 1]]
]);

// ../node_modules/@wonderlandengine/components/dist/utils/webxr.js
var tempVec4 = new Float32Array(3);
var tempQuat3 = new Float32Array(4);
function setXRRigidTransformLocal2(o, transform) {
  const r = transform.orientation;
  tempQuat3[0] = r.x;
  tempQuat3[1] = r.y;
  tempQuat3[2] = r.z;
  tempQuat3[3] = r.w;
  const t = transform.position;
  tempVec4[0] = t.x;
  tempVec4[1] = t.y;
  tempVec4[2] = t.z;
  o.resetTranslationRotation();
  o.transformLocal.set(tempQuat3);
  o.translate(tempVec4);
}

// ../looking-glass.js
var LookingGlassComponent = class extends Component2 {
  start() {
    this.viewObjects = [];
    this.spawnViews(45 - 2);
    this.engine.onXRSessionStart.add(() => {
      this.active = true;
      this.viewObjects.forEach((v) => v.active = true);
    });
    this.engine.onXRSessionEnd.add(() => {
      this.active = false;
      this.viewObjects.forEach((v) => v.active = false);
    });
    if (typeof document !== "undefined") {
      var LookingGlassWebXRPolyfill = require_webxr_umd().LookingGlassWebXRPolyfill;
      new LookingGlassWebXRPolyfill({
        tileHeight: this.tileHeight,
        numViews: this.viewCount,
        targetY: 0,
        targetZ: 0,
        targetDiam: this.targetDiameter,
        fovy: this.fovYDeg * Math.PI / 180,
        depthiness: this.depthiness
      });
    }
    this.active = false;
  }
  update() {
    const pose = this.engine.xr.frame.getViewerPose(
      this.engine.xr.currentReferenceSpace
    );
    const views = pose.views;
    if (views.length - 2 > this.viewObjects.length) {
      this.spawnViews(views.length - 2 - this.viewObjects.length, true);
    }
    for (let i = 2; i < views.length; ++i) {
      setXRRigidTransformLocal2(this.viewObjects[i - 2], views[i].transform);
    }
  }
  spawnViews(viewCount, active = false) {
    const newViews = this.engine.scene.addObjects(viewCount, this.head, viewCount);
    newViews.forEach((v) => v.addComponent(ViewComponent2, { active }));
    this.viewObjects.push(...newViews);
  }
};
__publicField(LookingGlassComponent, "TypeName", "looking-glass");
__publicField(LookingGlassComponent, "Properties", {
  /** Object that acts as the center of the display */
  head: Property2.object(),
  /** Looking Glass displays require rendering an array of tiles
   * that is interleaved */
  tileHeight: Property2.int(512),
  /** Number of views to render. The more, the clearer the image, but
   * the more performance is required to render a frame */
  viewCount: Property2.int(86),
  /** Diameter of the looking glass display */
  targetDiameter: Property2.int(3),
  /** Vertical field of view to render */
  fovYDeg: Property2.int(14),
  /** Depth separation factor. the more, the deeper the image appears,
   * but the higher potential artefacts might be. */
  depthiness: Property2.float(1.1)
});

// js/floating-animation.js
var FloatingAnimation = class extends Component {
  init() {
    this.time = Math.random() * 10;
    this.startPos = new Float32Array(3);
    this.lastPos = new Float32Array(3);
  }
  start() {
    this.object.getPositionLocal(this.startPos);
  }
  update(dt) {
    this.time += this.speed * dt;
    this.object.setPositionLocal(
      vec3_exports.add(this.lastPos, this.startPos, [
        this.sizeX * Math.sin(0.8 * this.time),
        this.sizeY * Math.sin(0.9 * this.time),
        this.sizeZ * Math.sin(0.7 * this.time)
      ])
    );
  }
};
__publicField(FloatingAnimation, "TypeName", "floating-animation");
__publicField(FloatingAnimation, "Properties", {
  speed: { type: Type.Float, default: 0.8 },
  sizeX: { type: Type.Float, default: 0.01 },
  sizeY: { type: Type.Float, default: 0.02 },
  sizeZ: { type: Type.Float, default: 0 }
});

// js/index.js
var RuntimeOptions = {
  physx: false,
  loader: false,
  xrFramebufferScaleFactor: 1,
  canvas: "canvas"
};
var Constants = {
  ProjectName: "LookingGlass",
  RuntimeBaseName: "WonderlandRuntime",
  WebXRRequiredFeatures: ["local"],
  WebXROptionalFeatures: ["local", "hand-tracking", "hit-test"]
};
var engine = await loadRuntime(Constants.RuntimeBaseName, RuntimeOptions);
Object.assign(engine, dist_exports);
window.WL = engine;
engine.onSceneLoaded.once(() => {
  const el = document.getElementById("version");
  if (el)
    setTimeout(() => el.remove(), 2e3);
});
function requestSession(mode) {
  engine.requestXRSession(
    mode,
    Constants.WebXRRequiredFeatures,
    Constants.WebXROptionalFeatures
  ).catch((e) => console.error(e));
}
function setupButtonsXR() {
  const arButton = document.getElementById("ar-button");
  if (arButton) {
    arButton.dataset.supported = engine.arSupported;
    arButton.addEventListener("click", () => requestSession("immersive-ar"));
  }
  const vrButton = document.getElementById("vr-button");
  if (vrButton) {
    vrButton.dataset.supported = engine.vrSupported;
    vrButton.addEventListener("click", () => requestSession("immersive-vr"));
  }
}
if (document.readyState === "loading") {
  window.addEventListener("load", setupButtonsXR);
} else {
  setupButtonsXR();
}
engine.registerComponent(MouseLookComponent);
engine.registerComponent(WasdControlsComponent);
engine.registerComponent(LookingGlassComponent);
engine.registerComponent(FloatingAnimation);
engine.scene.load(`${Constants.ProjectName}.bin`);
/*! Bundled license information:

howler/dist/howler.js:
  (*!
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)

cardboard-vr-display/dist/cardboard-vr-display.js:
  (**
   * @license
   * cardboard-vr-display
   * Copyright (c) 2015-2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * gl-preserve-state
   * Copyright (c) 2016, Brandon Jones.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
  (**
   * @license
   * webvr-polyfill-dpdb
   * Copyright (c) 2015-2017 Google
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * nosleep.js
   * Copyright (c) 2017, Rich Tibbett
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

holoplay-core/dist/holoplaycore.js:
  (**
   * This files defines the HoloPlayClient class and Message class.
   *
   * Copyright (c) [2019] [Looking Glass Factory]
   *
   * @link    https://lookingglassfactory.com/
   * @file    This files defines the HoloPlayClient class and Message class.
   * @author  Looking Glass Factory.
   * @version 0.0.8
   * @license SEE LICENSE IN LICENSE.md
   *)

gl-matrix/dist/gl-matrix.js:
  (*!
  @fileoverview gl-matrix - High performance matrix and vector operations
  @author Brandon Jones
  @author Colin MacKenzie IV
  @version 2.7.0
  
  Copyright (c) 2015-2018, Brandon Jones, Colin MacKenzie IV.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  *)
*/
//# sourceMappingURL=LookingGlass-bundle.js.map
